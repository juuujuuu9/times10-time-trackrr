# Time Tracking App - Cursor Rules

## Manual Duration Entry Patterns

### Critical Rule: Manual Duration Entries
- **ALWAYS** set `startTime: null` and `endTime: null` for manual duration entries
- **NEVER** set `startTime` and `endTime` to date ranges for manual entries
- Manual entries should only have `durationManual` field populated
- Use `createdAt` for date association, not `startTime`

### API Endpoint Patterns
- When creating manual duration entries, use this pattern:
  ```typescript
  const newEntry = {
    userId,
    projectId,
    startTime: null,        // ALWAYS null for manual entries
    endTime: null,          // ALWAYS null for manual entries  
    durationManual: parsedDuration,
    notes: 'Manual duration entry',
    createdAt: new Date(),
    updatedAt: new Date()
  };
  ```

### Database Query Patterns
- For manual duration entries, use `createdAt` for date filtering, not `startTime`
- Always check for both timer entries AND manual entries:
  ```sql
  WHERE (startTime IS NOT NULL AND endTime IS NOT NULL) 
     OR (durationManual IS NOT NULL)
  ```

## React Component Patterns

### Event Handler Dependencies
- **ALWAYS** wrap data loading functions with `useCallback` and proper dependencies
- **ALWAYS** memoize event handlers to prevent infinite re-renders
- Pattern:
  ```typescript
  const loadData = useCallback(async () => {
    // loading logic
  }, [dependency1, dependency2]);
  
  const handleDataChange = useCallback(() => {
    loadData();
  }, [loadData]);
  ```

### Data Refresh Patterns
- **ALWAYS** dispatch custom events after successful API calls
- **ALWAYS** call both direct refresh AND event-based refresh
- Pattern:
  ```typescript
  // Direct refresh (immediate)
  await loadData();
  
  // Event-based refresh (backup)
  setTimeout(() => {
    window.dispatchEvent(new CustomEvent('dataUpdated'));
  }, 100);
  ```

### Date Handling Patterns
- **ALWAYS** use local date components for date construction to avoid timezone issues
- **NEVER** rely on `toISOString().split('T')[0]` for date strings
- Pattern:
  ```typescript
  const year = targetDate.getFullYear();
  const month = targetDate.getMonth() + 1;
  const day = targetDate.getDate();
  const dateString = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
  ```

## API Response Patterns

### Consistent Error Handling
- **ALWAYS** return consistent error response format
- **ALWAYS** include success/error status in responses
- Pattern:
  ```typescript
  return new Response(JSON.stringify({
    success: true/false,
    message: 'Description',
    data: result,
    error: errorMessage
  }), {
    status: 200/400/500,
    headers: { 'Content-Type': 'application/json' }
  });
  ```

### Validation Patterns
- **ALWAYS** validate required fields at the start of API handlers
- **ALWAYS** use consistent field names (projectId vs taskId)
- **ALWAYS** support backward compatibility with legacy field names

## Database Migration Patterns

### Schema Changes
- **ALWAYS** create migration scripts for data fixes
- **ALWAYS** verify fixes with count queries
- **ALWAYS** test migrations on development data first

### Data Consistency
- **ALWAYS** check for data inconsistencies after schema changes
- **ALWAYS** provide both SQL and API-based fix options
- **ALWAYS** include verification steps in migration scripts

## Testing Patterns

### Manual Testing Checklist
- [ ] Test manual duration entries save with correct date
- [ ] Test manual entries display as `--:-- --:--` for start/stop times
- [ ] Test daily totals update immediately after manual entry
- [ ] Test week navigation preserves correct dates
- [ ] Test both create and update operations for manual entries

### Debug Patterns
- **ALWAYS** add console logs for date calculations
- **ALWAYS** log API request/response data for debugging
- **ALWAYS** verify database state after operations

## Common Anti-Patterns to Avoid

### ❌ DON'T
- Set `startTime` and `endTime` for manual duration entries
- Use `toISOString()` for date string construction
- Forget to memoize functions used in `useCallback` dependencies
- Create manual entries without proper date association
- Mix timer-based and manual entry logic

### ✅ DO
- Use `null` for start/end times on manual entries
- Use local date components for date strings
- Memoize all functions used in event handlers
- Associate manual entries with correct dates via `createdAt`
- Keep timer and manual entry logic separate

## Time Entry Types

### Timer-Based Entries
- Have `startTime` and `endTime` populated
- Have `durationManual: null`
- Duration calculated from `endTime - startTime`

### Manual Duration Entries  
- Have `startTime: null` and `endTime: null`
- Have `durationManual` populated
- Use `createdAt` for date association

### Ongoing Timer Entries
- Have `startTime` populated, `endTime: null`
- Have `durationManual: null`
- Duration calculated from `NOW() - startTime`

## Event System Patterns

### Custom Events
- `timerStarted` - When a timer begins
- `timerStopped` - When a timer ends
- `timeEntryAdded` - When a new entry is created
- `timeEntryUpdated` - When an entry is modified
- `timeEntryDeleted` - When an entry is removed

### Event Handling
- Always add event listeners in `useEffect` with cleanup
- Always remove event listeners in cleanup function
- Use consistent event names across components
- Dispatch events after successful API operations

## Date Calculation Patterns

### Week Navigation
- Use `computeWeekRange(offset)` for week calculations
- Sunday = 0, Monday = 1, ..., Saturday = 6
- Always use local timezone for date calculations
- Store week start/end dates in component state

### Day of Week Mapping
- Map dayOfWeek (0-6) to actual dates using selectedWeekStart
- Use `selectedWeekStart.getDate() + dayOfWeek` for target date
- Always construct date strings manually to avoid timezone issues

## Component State Management

### Loading States
- Use separate loading states for different operations
- Show loading indicators during API calls
- Disable inputs during loading states
- Provide user feedback for all operations

### Error Handling
- Show user-friendly error messages
- Log detailed errors to console
- Provide retry mechanisms where appropriate
- Handle network errors gracefully

## API Design Patterns

### Consistent Field Names
- Use `projectId` as primary field name
- Support `taskId` for backward compatibility
- Always validate required fields
- Use consistent parameter naming

### Response Format
- Always include `success` boolean
- Include descriptive `message` field
- Return `data` object with results
- Include `error` field for failures
- Use appropriate HTTP status codes

## Database Query Patterns

### Time Entry Queries
- Always join with users, projects, and clients tables
- Filter out archived records
- Use proper date filtering for manual vs timer entries
- Include calculated duration fields

### Duration Calculations
- Use SQL CASE statements for duration logic
- Handle both manual and timer-based entries
- Exclude ongoing timers from completed entry queries
- Use proper timezone handling in queries