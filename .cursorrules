# Time Tracking App - Cursor Rules

## Manual Duration Entry Patterns

### Critical Rule: Manual Duration Entries
- **ALWAYS** set `startTime: null` and `endTime: null` for manual duration entries
- **NEVER** set `startTime` and `endTime` to date ranges for manual entries
- Manual entries should only have `durationManual` field populated
- Use `createdAt` for date association, not `startTime`

### API Endpoint Patterns
- When creating manual duration entries, use this pattern:
  ```typescript
  const newEntry = {
    userId,
    projectId,
    startTime: null,        // ALWAYS null for manual entries
    endTime: null,          // ALWAYS null for manual entries  
    durationManual: parsedDuration,
    notes: 'Manual duration entry',
    createdAt: new Date(),
    updatedAt: new Date()
  };
  ```

### Database Query Patterns
- For manual duration entries, use `createdAt` for date filtering, not `startTime`
- Always check for both timer entries AND manual entries:
  ```sql
  WHERE (startTime IS NOT NULL AND endTime IS NOT NULL) 
     OR (durationManual IS NOT NULL)
  ```

## React Component Patterns

### Event Handler Dependencies
- **ALWAYS** wrap data loading functions with `useCallback` and proper dependencies
- **ALWAYS** memoize event handlers to prevent infinite re-renders
- Pattern:
  ```typescript
  const loadData = useCallback(async () => {
    // loading logic
  }, [dependency1, dependency2]);
  
  const handleDataChange = useCallback(() => {
    loadData();
  }, [loadData]);
  ```

### Data Refresh Patterns
- **ALWAYS** dispatch custom events after successful API calls
- **ALWAYS** call both direct refresh AND event-based refresh
- Pattern:
  ```typescript
  // Direct refresh (immediate)
  await loadData();
  
  // Event-based refresh (backup)
  setTimeout(() => {
    window.dispatchEvent(new CustomEvent('dataUpdated'));
  }, 100);
  ```

### Date Handling Patterns
- **ALWAYS** use local date components for date construction to avoid timezone issues
- **NEVER** rely on `toISOString().split('T')[0]` for date strings
- Pattern:
  ```typescript
  const year = targetDate.getFullYear();
  const month = targetDate.getMonth() + 1;
  const day = targetDate.getDate();
  const dateString = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
  ```

## API Response Patterns

### Consistent Error Handling
- **ALWAYS** return consistent error response format
- **ALWAYS** include success/error status in responses
- Pattern:
  ```typescript
  return new Response(JSON.stringify({
    success: true/false,
    message: 'Description',
    data: result,
    error: errorMessage
  }), {
    status: 200/400/500,
    headers: { 'Content-Type': 'application/json' }
  });
  ```

### Validation Patterns
- **ALWAYS** validate required fields at the start of API handlers
- **ALWAYS** use consistent field names (projectId vs taskId)
- **ALWAYS** support backward compatibility with legacy field names

## Database Migration Patterns

### Schema Changes
- **ALWAYS** create migration scripts for data fixes
- **ALWAYS** verify fixes with count queries
- **ALWAYS** test migrations on development data first

### Data Consistency
- **ALWAYS** check for data inconsistencies after schema changes
- **ALWAYS** provide both SQL and API-based fix options
- **ALWAYS** include verification steps in migration scripts

## Testing Patterns

### Manual Testing Checklist
- [ ] Test manual duration entries save with correct date
- [ ] Test manual entries display as `--:-- --:--` for start/stop times
- [ ] Test daily totals update immediately after manual entry
- [ ] Test week navigation preserves correct dates
- [ ] Test both create and update operations for manual entries

### Debug Patterns
- **ALWAYS** add console logs for date calculations
- **ALWAYS** log API request/response data for debugging
- **ALWAYS** verify database state after operations

## Common Anti-Patterns to Avoid

### ❌ DON'T
- Set `startTime` and `endTime` for manual duration entries
- Use `toISOString()` for date string construction
- Forget to memoize functions used in `useCallback` dependencies
- Create manual entries without proper date association
- Mix timer-based and manual entry logic

### ✅ DO
- Use `null` for start/end times on manual entries
- Use local date components for date strings
- Memoize all functions used in event handlers
- Associate manual entries with correct dates via `createdAt`
- Keep timer and manual entry logic separate

## Time Entry Types

### Timer-Based Entries
- Have `startTime` and `endTime` populated
- Have `durationManual: null`
- Duration calculated from `endTime - startTime`

### Manual Duration Entries  
- Have `startTime: null` and `endTime: null`
- Have `durationManual` populated
- Use `createdAt` for date association

### Ongoing Timer Entries
- Have `startTime` populated, `endTime: null`
- Have `durationManual: null`
- Duration calculated from `NOW() - startTime`

## Event System Patterns

### Custom Events
- `timerStarted` - When a timer begins
- `timerStopped` - When a timer ends
- `timeEntryAdded` - When a new entry is created
- `timeEntryUpdated` - When an entry is modified
- `timeEntryDeleted` - When an entry is removed

### Event Handling
- Always add event listeners in `useEffect` with cleanup
- Always remove event listeners in cleanup function
- Use consistent event names across components
- Dispatch events after successful API operations

## Date Calculation Patterns

### Week Navigation
- Use `computeWeekRange(offset)` for week calculations
- Sunday = 0, Monday = 1, ..., Saturday = 6
- Always use local timezone for date calculations
- Store week start/end dates in component state

### Day of Week Mapping
- Map dayOfWeek (0-6) to actual dates using selectedWeekStart
- Use `selectedWeekStart.getDate() + dayOfWeek` for target date
- Always construct date strings manually to avoid timezone issues

## Component State Management

### Loading States
- Use separate loading states for different operations
- Show loading indicators during API calls
- Disable inputs during loading states
- Provide user feedback for all operations

### Error Handling
- Show user-friendly error messages
- Log detailed errors to console
- Provide retry mechanisms where appropriate
- Handle network errors gracefully

## API Design Patterns

### Consistent Field Names
- Use `projectId` as primary field name
- Support `taskId` for backward compatibility
- Always validate required fields
- Use consistent parameter naming

### Response Format
- Always include `success` boolean
- Include descriptive `message` field
- Return `data` object with results
- Include `error` field for failures
- Use appropriate HTTP status codes

## Database Query Patterns

### Time Entry Queries
- Always join with users, projects, and clients tables
- Filter out archived records
- Use proper date filtering for manual vs timer entries
- Include calculated duration fields

### Duration Calculations
- Use SQL CASE statements for duration logic
- Handle both manual and timer-based entries
- Exclude ongoing timers from completed entry queries
- Use proper timezone handling in queries

## Timezone Issue Prevention Patterns

### Manual Duration Entry Timezone Issues
- **CRITICAL**: Manual duration entries MUST have `startTime: null` and `endTime: null`
- **NEVER** set `startTime` to a date for manual duration entries - this causes timezone conversion issues
- Use `createdAt` field for date association with manual entries, not `startTime`
- When displaying manual entries, check `if (entry.startTime)` to determine date source

### Date Display Logic
- For timer entries: Use `entry.startTime` for date calculation
- For manual entries: Use `entry.createdAt` for date calculation
- Pattern:
  ```typescript
  const taskDate = entry.startTime ? 
    (() => {
      const date = new Date(entry.startTime);
      const year = date.getFullYear();
      const month = date.getMonth() + 1;
      const day = date.getDate();
      return new Date(year, month - 1, day, 0, 0, 0, 0);
    })() : 
    new Date(entry.createdAt);
  ```

### Timezone-Safe Date Construction
- **ALWAYS** construct dates using local date components to avoid timezone issues
- **NEVER** use `new Date(dateString)` for date construction in production
- Pattern:
  ```typescript
  const [year, month, day] = dateString.split('-').map(Number);
  const targetDate = new Date(year, month - 1, day, 0, 0, 0, 0);
  ```

## Data Migration Patterns

### Fixing Existing Data Issues
- **ALWAYS** create API endpoints to fix existing data issues
- **ALWAYS** provide both detection and fix functionality
- **ALWAYS** include verification steps in fix scripts
- Pattern for manual duration entry fixes:
  ```typescript
  // Find problematic entries
  const problematicEntries = await db
    .select()
    .from(timeEntries)
    .where(
      and(
        isNotNull(timeEntries.durationManual),
        isNotNull(timeEntries.startTime)  // This is the problem
      )
    );
  
  // Fix them
  await db
    .update(timeEntries)
    .set({
      startTime: null,
      endTime: null,
      updatedAt: new Date()
    })
    .where(/* same condition */);
  ```

## Service Layer Patterns

### Time Entry Service Consistency
- **ALWAYS** ensure service layer follows the same patterns as API endpoints
- **ALWAYS** check service layer when fixing API endpoint issues
- **ALWAYS** maintain consistency between different creation paths (API vs Service)

### Multiple Creation Paths
- Manual duration entries can be created via:
  - `/api/time-entries/duration` (duration editing)
  - `/api/admin/time-entries` (admin creation)
  - `TimeEntryService.createTimeEntry()` (service layer)
- **ALWAYS** ensure all paths follow the same manual entry patterns
- **ALWAYS** test all creation paths when fixing manual entry issues

## Debugging and Investigation Patterns

### Timezone Issue Investigation
- **ALWAYS** check both creation logic AND display logic when investigating date issues
- **ALWAYS** examine all code paths that create manual duration entries
- **ALWAYS** verify that manual entries use `createdAt` for date association, not `startTime`
- **ALWAYS** check service layer consistency when fixing API issues

### Production Issue Debugging
- **ALWAYS** create migration scripts for data fixes
- **ALWAYS** provide API endpoints for fixing existing data
- **ALWAYS** include verification steps in fix operations
- **ALWAYS** test fixes on development data before production

### Code Search Patterns
- Use `grep` to find all instances of problematic patterns
- Search for `durationManual` to find all manual entry logic
- Search for `startTime.*targetDate` to find timezone issues
- Check both API endpoints and service layers for consistency