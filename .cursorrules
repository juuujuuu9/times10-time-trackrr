# Cursor Rules Addendum: Time Editing

- When modifying any time editing or creation UI/logic, first read /docs/TIME_EDITING_GUIDE.md.
- Apply the guide's rules: local date construction, ISO string payloads, always send both times, data attributes, refresh row data.
- If you add or change patterns, update /docs/TIME_EDITING_GUIDE.md in the same PR.
- Map UI taskId to DB projectId in service layer for create/update.
- Avoid timezone offset math unless explicitly required; prefer ISO strings.

# Dashboard Auto-Refresh Patterns

- When adding inline editing to dashboard tables, ALWAYS add loadDashboardData() calls after successful updates.
- Use data-listeners-attached attributes to prevent duplicate event listener attachment in MutationObserver patterns.
- For sortable tables that auto-refresh, ensure ALL update paths (modal, inline, date picker) trigger the same refresh mechanism.
- When debugging auto-refresh issues, add console.log statements to track: update trigger → loadDashboardData() → updateRecentEntries() → MutationObserver re-attachment.
- Dashboard tables with dynamic content need MutationObserver to re-attach event listeners after DOM replacement.

# Development Efficiency Rules

## Avoid Overcomplication
- Start with simple solutions and add complexity only when needed
- Don't add server-side filtering unless there's a clear performance need (e.g., thousands of entries)
- Keep parsing logic focused on common use cases (80/20 rule)
- Don't add features "just in case" - wait for actual user needs

## UI Structure Changes
- When changing from text to input fields, search for ALL references to the old structure
- Update filtering, sorting, and validation logic to work with new structure
- Test all related functionality after structural changes
- Always check if filtering logic reads from the correct DOM properties (`value` vs `textContent`)

## Event Handlers and Data Flow
- When adding new event handlers, ensure they trigger all related updates (filtering, sorting, validation)
- When adding new features, trace the complete data flow from UI to API to database
- Ensure all related functions (filtering, sorting, validation) are updated together
- Test the complete user journey, not just individual components

## Debugging and Development
- Remove debugging code immediately after fixing issues
- Use proper debugging tools instead of console.log in production
- Fix TypeScript linting errors immediately - they often reveal logical issues
- When using dynamic content, ensure all event handlers are re-attached properly

## API Consistency and Data Accuracy
- When multiple components display the same data (e.g., dashboard sidebar vs timer list), use the SAME API endpoints
- If one component shows accurate data and another doesn't, align the inaccurate one with the accurate one's API calls
- Avoid creating separate API endpoints for similar data - prefer reusing existing endpoints with parameters
- When debugging data discrepancies, check which API endpoints each component uses first
- If API endpoints have different filtering logic (e.g., including/excluding ongoing timers), document this clearly
- Prefer the simpler, more consistent API approach over creating new endpoints

# Database Schema Changes & Migration Rules

## Critical Database Migration Workflow
- When renaming database columns, ALWAYS run the migration immediately after code changes
- Use `grep -r "oldColumnName" src/` to find ALL references before making changes
- Search for both camelCase (taskId) and snake_case (task_id) versions
- Test ALL admin pages after database migrations: /admin/clients, /admin/time-entries, /admin/reports, /admin/tasks

## SQL Query Validation
- After modifying joins, validate SQL syntax - check for incomplete join conditions
- Remove unnecessary table joins when schema changes eliminate the need for them
- Test queries with actual database connections, not just code changes
- Watch for "syntax error at or near 'group'" - usually indicates incomplete JOIN conditions

## Environment & Configuration Issues
- Always verify DATABASE_URL is properly formatted (no concatenated URLs)
- Check for malformed .env files that can cause connection issues
- Restart development server after environment variable changes

## Error Pattern Recognition
- "column does not exist" errors = schema mismatch between code and database
- "syntax error at or near 'group'" = incomplete JOIN conditions
- 500 errors on admin pages = usually database query issues
- Port conflicts = kill existing processes before restarting

## Code Update Patterns
- When renaming database fields, update both the schema references AND the query logic
- Remove references to tables that are no longer needed after schema changes
- Update both the database queries AND the UI components that display the data
- Check for duplicate joins that can cause SQL syntax errors

## Testing & Validation
- After database changes, test ALL affected endpoints
- Use `curl -I` to quickly test HTTP status codes
- Check server logs for detailed error information
- Verify both the database schema AND the application code are in sync
