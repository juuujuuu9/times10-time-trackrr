# .cursorrules

ruleset: 1.0.0

## Meta-Directive
This file defines how Cursor should interpret, enforce, and adapt to this project's evolving codebase. Cursor must treat this as a living contract that reflects actual development patterns.

## Core Principles
- Explicit > implicit
- Determinism > magic  
- Local clarity > global cleverness
- **Simple > clever: Choose the most straightforward solution**
- **Minimal > maximal: Solve the immediate problem, not hypothetical futures**
- **Direct > abstracted: Avoid premature optimization and over-engineering**
- Enforce conventions through inline diagnostics and autofix suggestions
- Reference rules by ID (RULE-###) in all completions and refactors

## Simplicity Mandate

### Default to Minimal Solutions
- Solve the actual problem at hand, not imagined edge cases
- Add complexity only when justified by real requirements
- Prefer boring, proven patterns over novel approaches
- Question every abstraction: "Does this add value now?"

### Anti-Bloat Checklist
Before suggesting code, verify:
- ✓ Is this the simplest approach that works?
- ✓ Can this be solved with existing tools/patterns?
- ✓ Am I adding layers that aren't needed yet?
- ✓ Would a junior developer understand this in 6 months?

### Red Flags to Avoid
- Generic wrappers around single-use functions
- Premature abstraction of logic used once
- Complex inheritance hierarchies
- Over-engineered state management for simple data
- Dependency injection where direct imports suffice
- Configuration systems for static values
- Middleware for operations that could be inline

### When to Add Complexity
Only introduce abstractions when:
1. Pattern appears ≥3 times across codebase
2. Complexity reduces cognitive load (not just lines of code)
3. Change frequency justifies the indirection
4. Team explicitly requests the pattern

## Active Learning Protocol

### 1. Pattern Recognition
- Scan repo on initialization to infer architecture, stack, and conventions
- Monitor for repeated patterns (≥3 occurrences across distinct files)
- Detect anti-patterns and rule violations
- **Flag over-engineered solutions and suggest simplifications**
- Propose rule additions when stable patterns emerge
- Suggest rule refinement when violations are frequent and justified

### 2. Auto-Documentation
- Maintain `/cursor-guides/` directory with:
  - `RULE-###.md` for each rule (rationale, examples, cross-references)
  - `index.json` manifest linking rule IDs to files
  - `audit.log` for all rule modifications
- Generate documentation automatically when rules change
- Include code examples from actual project files
- **Document why simple solutions were chosen over complex alternatives**

### 3. Enforcement Mechanism
- Provide inline diagnostics for rule violations
- Show rule references in completion tooltips
- Suggest autofixes with rule context
- Flag critical violations that should block commits
- **Warn when solutions introduce unnecessary complexity**

## Project Rules

### RULE-000: Simplicity First
- Choose the most direct path to solve the problem
- Avoid speculative generalization
- Refactor toward simplicity, not complexity
- Delete code more often than you add it
- Inline small abstractions that obscure rather than clarify
**Severity:** Warning  
**Applies to:** All code suggestions and refactors

### RULE-001: TypeScript Configuration
- Strict mode enabled
- No `any` type usage
- Prefer explicit return types for exported functions
- **Avoid complex generic gymnastics; use simple unions/intersections**
**Severity:** Error

### RULE-002: Project Structure  
- Organize by feature, not file type
- Use path aliases (`@/`, `@components/`, etc.)
- Keep related code colocated
- **Flat structure > deep nesting; avoid folder hierarchies beyond 3 levels**
**Severity:** Warning

### RULE-003: Styling Standards
- Tailwind utilities are default
- No inline `style` props
- Use design tokens for spacing/colors
- **Compose utilities inline; avoid @apply unless truly repetitive (≥5 uses)**
**Severity:** Warning

### RULE-004: Font Handling
- Omit `"Satoshi Variable"` references
- Map `"Lexend Mega"` → `.font-lexend-mega` class
- Map `"Roboto"` → `.font-roboto` class  
- Expand CSS variables manually
- Add `/* VAR_NEEDED:<name> */` comment if variable is unresolved
**Severity:** Error

### RULE-005: Framework Architecture
- Keep Astro pages minimal (routing/layout only)
- Extract logic into typed modules/components
- Share stateful logic through explicit imports
- **No framework wrappers or abstract base classes; use composition**
**Severity:** Warning

### RULE-006: Data Validation
- Validate all external data with Zod or schema guards
- No unvalidated API responses or user input
- Type guards for runtime checks
- **Simple schemas only; avoid complex transforms unless necessary**
**Severity:** Error

### RULE-007: State Management
- Prefer server-side caching over global stores
- Use explicit state hydration patterns
- Document state dependencies
- **Start with component state; introduce stores only when sharing across ≥3 components**
**Severity:** Warning

### RULE-008: Accessibility
- Enforce keyboard navigation support
- Include ARIA attributes where semantic HTML insufficient
- Test focus management in interactive components
- **Use semantic HTML first; ARIA only when HTML semantics are insufficient**
**Severity:** Error

### RULE-009: Performance
- Optimize all images before commit
- Limit client-side hydration (`client:load` sparingly)
- Lazy load heavy components
- **Measure before optimizing; avoid speculative performance code**
**Severity:** Warning

### RULE-010: Security
- No secrets in client-side code
- Use parameterized queries only (no string concatenation)
- Sanitize user-generated content
- **Use framework/library security features; avoid custom crypto/auth**
**Severity:** Error

### RULE-011: Development Workflow
- Use conventional commits (feat:, fix:, docs:, etc.)
- Include "Rule Impact: RULE-###" in PR descriptions when relevant
- Update tests when changing rule-enforced patterns
- **Write tests for behavior, not implementation; avoid brittle tests**
**Severity:** Warning

### RULE-012: Dependency Management
- Justify every new dependency
- Prefer platform/framework features over libraries
- Remove unused dependencies immediately
- **Ask: "Can I write this in 20 lines instead of importing a package?"**
**Severity:** Warning

### RULE-013: No Mock Data for Missing APIs
- **NEVER** create mock data, placeholder data, or generated fake data when API endpoints are missing
- **ALWAYS** ask the user if they want to create the missing API endpoint instead
- **ALWAYS** identify what data should come from the database and suggest the proper API structure
- **ALWAYS** show loading states or "Feature not implemented" messages rather than fake data
- **ALWAYS** provide clear guidance on what API endpoint needs to be created
**Severity:** Error

## Cursor Behavior Instructions

### Code Completion
- Always check completion against active rules
- Annotate suggestions with relevant rule IDs
- Prefer rule-compliant alternatives over raw suggestions
- **Default to the simplest approach that satisfies requirements**
- **Avoid suggesting abstractions, helpers, or utilities for single-use code**
- **RULE-013: Never suggest mock data; always ask about creating missing API endpoints**

### Refactoring
- Verify refactor maintains rule compliance
- Flag rules that would be violated by proposed changes
- Suggest rule-aligned alternative approaches
- **Prioritize clarity over cleverness in all refactors**
- **Remove unnecessary indirection and abstraction layers**
- **Inline small functions that are only called once**

### Problem-Solving Approach
1. Understand the immediate requirement (not future possibilities)
2. Identify the most direct solution using existing code
3. Check if the solution can be simpler
4. Only then suggest the code
5. Note when resisting the urge to over-engineer

### Code Review Mindset
When reviewing or suggesting code, ask:
- "What's the simplest thing that could work?"
- "Am I solving a problem that doesn't exist yet?"
- "Will this be obvious to someone new in 6 months?"
- "Can I delete code instead of adding it?"

### Rule Updates
1. Detect pattern requiring new rule
2. Draft rule with ID, description, severity
3. Generate `/cursor-guides/RULE-###.md` with examples
4. Update `index.json` and `audit.log`
5. Present proposal to developer for approval
6. **Include simplicity analysis: Why this rule prevents bloat**

### Audit Log Format

[YYYY-MM-DD HH:MM] ACTION: RULE-### | DESCRIPTION | AUTHOR

## Integration Points

### CI/CD
- `scripts/rules-check.ts` validates compliance
- `.github/workflows/rules.yml` runs on PR
- Critical rule violations block merge

### Documentation Sync
- Rules changes trigger docs regeneration
- Examples pulled from real project code
- Cross-references maintained automatically
- **Include "simple vs. complex" comparison examples**

## Evolution Protocol
1. New patterns emerge → Cursor proposes rule
2. Rule violations spike → Cursor suggests refinement  
3. Rules unused for 90 days → Cursor flags for deprecation
4. Deprecated rules stay in history (never deleted)
5. **Complexity detected → Cursor suggests simplification and documents rationale**

## Complexity Warnings
Cursor will flag and suggest alternatives for:
- Functions longer than 50 lines without clear reason
- Files longer than 300 lines
- Nesting depth > 4 levels
- Cyclomatic complexity > 10
- Abstractions used only once
- More than 2 layers of indirection to accomplish a task

---

# Time Tracking App - Specific Rules

## Manual Duration Entry Patterns

### Critical Rule: Manual Duration Entries
- **ALWAYS** set `startTime: null` and `endTime: null` for manual duration entries
- **NEVER** set `startTime` and `endTime` to date ranges for manual entries
- Manual entries should only have `durationManual` field populated
- Use `createdAt` for date association, not `startTime`

### API Endpoint Patterns
- When creating manual duration entries, use this pattern:
  ```typescript
  const newEntry = {
    userId,
    projectId,
    startTime: null,        // ALWAYS null for manual entries
    endTime: null,          // ALWAYS null for manual entries  
    durationManual: parsedDuration,
    notes: 'Manual duration entry',
    createdAt: new Date(),
    updatedAt: new Date()
  };
  ```

### Database Query Patterns
- For manual duration entries, use `createdAt` for date filtering, not `startTime`
- Always check for both timer entries AND manual entries:
  ```sql
  WHERE (startTime IS NOT NULL AND endTime IS NOT NULL) 
     OR (durationManual IS NOT NULL)
  ```

## React Component Patterns

### Event Handler Dependencies
- **ALWAYS** wrap data loading functions with `useCallback` and proper dependencies
- **ALWAYS** memoize event handlers to prevent infinite re-renders
- Pattern:
  ```typescript
  const loadData = useCallback(async () => {
    // loading logic
  }, [dependency1, dependency2]);
  
  const handleDataChange = useCallback(() => {
    loadData();
  }, [loadData]);
  ```

### Data Refresh Patterns
- **ALWAYS** dispatch custom events after successful API calls
- **ALWAYS** call both direct refresh AND event-based refresh
- Pattern:
  ```typescript
  // Direct refresh (immediate)
  await loadData();
  
  // Event-based refresh (backup)
  setTimeout(() => {
    window.dispatchEvent(new CustomEvent('dataUpdated'));
  }, 100);
  ```

### Date Handling Patterns
- **ALWAYS** use local date components for date construction to avoid timezone issues
- **NEVER** rely on `toISOString().split('T')[0]` for date strings
- Pattern:
  ```typescript
  const year = targetDate.getFullYear();
  const month = targetDate.getMonth() + 1;
  const day = targetDate.getDate();
  const dateString = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
  ```

## API Response Patterns

### Consistent Error Handling
- **ALWAYS** return consistent error response format
- **ALWAYS** include success/error status in responses
- Pattern:
  ```typescript
  return new Response(JSON.stringify({
    success: true/false,
    message: 'Description',
    data: result,
    error: errorMessage
  }), {
    status: 200/400/500,
    headers: { 'Content-Type': 'application/json' }
  });
  ```

### Validation Patterns
- **ALWAYS** validate required fields at the start of API handlers
- **ALWAYS** use consistent field names (projectId vs taskId)
- **ALWAYS** support backward compatibility with legacy field names

## Database Migration Patterns

### Schema Changes
- **ALWAYS** create migration scripts for data fixes
- **ALWAYS** verify fixes with count queries
- **ALWAYS** test migrations on development data first

### Data Consistency
- **ALWAYS** check for data inconsistencies after schema changes
- **ALWAYS** provide both SQL and API-based fix options
- **ALWAYS** include verification steps in migration scripts

## Testing Patterns

### Manual Testing Checklist
- [ ] Test manual duration entries save with correct date
- [ ] Test manual entries display as `--:-- --:--` for start/stop times
- [ ] Test daily totals update immediately after manual entry
- [ ] Test week navigation preserves correct dates
- [ ] Test both create and update operations for manual entries

### Debug Patterns
- **ALWAYS** add console logs for date calculations
- **ALWAYS** log API request/response data for debugging
- **ALWAYS** verify database state after operations

## Common Anti-Patterns to Avoid

### ❌ DON'T
- Set `startTime` and `endTime` for manual duration entries
- Use `toISOString()` for date string construction
- Forget to memoize functions used in `useCallback` dependencies
- Create manual entries without proper date association
- Mix timer-based and manual entry logic

### ✅ DO
- Use `null` for start/end times on manual entries
- Use local date components for date strings
- Memoize all functions used in event handlers
- Associate manual entries with correct dates via `createdAt`
- Keep timer and manual entry logic separate

## Time Entry Types

### Timer-Based Entries
- Have `startTime` and `endTime` populated
- Have `durationManual: null`
- Duration calculated from `endTime - startTime`

### Manual Duration Entries  
- Have `startTime: null` and `endTime: null`
- Have `durationManual` populated
- Use `createdAt` for date association

### Ongoing Timer Entries
- Have `startTime` populated, `endTime: null`
- Have `durationManual: null`
- Duration calculated from `NOW() - startTime`

## Event System Patterns

### Custom Events
- `timerStarted` - When a timer begins
- `timerStopped` - When a timer ends
- `timeEntryAdded` - When a new entry is created
- `timeEntryUpdated` - When an entry is modified
- `timeEntryDeleted` - When an entry is removed

### Event Handling
- Always add event listeners in `useEffect` with cleanup
- Always remove event listeners in cleanup function
- Use consistent event names across components
- Dispatch events after successful API operations

## Date Calculation Patterns

### Week Navigation
- Use `computeWeekRange(offset)` for week calculations
- Sunday = 0, Monday = 1, ..., Saturday = 6
- Always use local timezone for date calculations
- Store week start/end dates in component state

### Day of Week Mapping
- Map dayOfWeek (0-6) to actual dates using selectedWeekStart
- Use `selectedWeekStart.getDate() + dayOfWeek` for target date
- Always construct date strings manually to avoid timezone issues

## Component State Management

### Loading States
- Use separate loading states for different operations
- Show loading indicators during API calls
- Disable inputs during loading states
- Provide user feedback for all operations

### Error Handling
- Show user-friendly error messages
- Log detailed errors to console
- Provide retry mechanisms where appropriate
- Handle network errors gracefully

## API Design Patterns

### Consistent Field Names
- Use `projectId` as primary field name
- Support `taskId` for backward compatibility
- Always validate required fields
- Use consistent parameter naming

### Response Format
- Always include `success` boolean
- Include descriptive `message` field
- Return `data` object with results
- Include `error` field for failures
- Use appropriate HTTP status codes

### Missing API Endpoint Protocol (RULE-013)
- **NEVER** create mock data when API endpoints are missing
- **ALWAYS** ask: "Would you like me to create the missing API endpoint for [specific functionality]?"
- **ALWAYS** identify the required data structure and database relationships
- **ALWAYS** suggest the proper API endpoint path and implementation
- **ALWAYS** show loading states or "Feature not implemented" instead of fake data
- **ALWAYS** provide clear guidance on what needs to be built

## Database Query Patterns

### Time Entry Queries
- Always join with users, projects, and clients tables
- Filter out archived records
- Use proper date filtering for manual vs timer entries
- Include calculated duration fields

### Duration Calculations
- Use SQL CASE statements for duration logic
- Handle both manual and timer-based entries
- Exclude ongoing timers from completed entry queries
- Use proper timezone handling in queries

## Timezone Issue Prevention Patterns

### Manual Duration Entry Timezone Issues
- **CRITICAL**: Manual duration entries MUST have `startTime: null` and `endTime: null`
- **NEVER** set `startTime` to a date for manual duration entries - this causes timezone conversion issues
- Use `createdAt` field for date association with manual entries, not `startTime`
- When displaying manual entries, check `if (entry.startTime)` to determine date source

### Date Display Logic
- For timer entries: Use `entry.startTime` for date calculation
- For manual entries: Use `entry.createdAt` for date calculation
- Pattern:
  ```typescript
  const taskDate = entry.startTime ? 
    (() => {
      const date = new Date(entry.startTime);
      const year = date.getFullYear();
      const month = date.getMonth() + 1;
      const day = date.getDate();
      return new Date(year, month - 1, day, 0, 0, 0, 0);
    })() : 
    new Date(entry.createdAt);
  ```

### Timezone-Safe Date Construction
- **ALWAYS** construct dates using local date components to avoid timezone issues
- **NEVER** use `new Date(dateString)` for date construction in production
- Pattern:
  ```typescript
  const [year, month, day] = dateString.split('-').map(Number);
  const targetDate = new Date(year, month - 1, day, 0, 0, 0, 0);
  ```

## Data Migration Patterns

### Fixing Existing Data Issues
- **ALWAYS** create API endpoints to fix existing data issues
- **ALWAYS** provide both detection and fix functionality
- **ALWAYS** include verification steps in fix scripts
- Pattern for manual duration entry fixes:
  ```typescript
  // Find problematic entries
  const problematicEntries = await db
    .select()
    .from(timeEntries)
    .where(
      and(
        isNotNull(timeEntries.durationManual),
        isNotNull(timeEntries.startTime)  // This is the problem
      )
    );
  
  // Fix them
  await db
    .update(timeEntries)
    .set({
      startTime: null,
      endTime: null,
      updatedAt: new Date()
    })
    .where(/* same condition */);
  ```

## Service Layer Patterns

### Time Entry Service Consistency
- **ALWAYS** ensure service layer follows the same patterns as API endpoints
- **ALWAYS** check service layer when fixing API endpoint issues
- **ALWAYS** maintain consistency between different creation paths (API vs Service)

### Multiple Creation Paths
- Manual duration entries can be created via:
  - `/api/time-entries/duration` (duration editing)
  - `/api/admin/time-entries` (admin creation)
  - `TimeEntryService.createTimeEntry()` (service layer)
- **ALWAYS** ensure all paths follow the same manual entry patterns
- **ALWAYS** test all creation paths when fixing manual entry issues

## Debugging and Investigation Patterns

### Timezone Issue Investigation
- **ALWAYS** check both creation logic AND display logic when investigating date issues
- **ALWAYS** examine all code paths that create manual duration entries
- **ALWAYS** verify that manual entries use `createdAt` for date association, not `startTime`
- **ALWAYS** check service layer consistency when fixing API issues

### Production Issue Debugging
- **ALWAYS** create migration scripts for data fixes
- **ALWAYS** provide API endpoints for fixing existing data
- **ALWAYS** include verification steps in fix operations
- **ALWAYS** test fixes on development data before production

### Code Search Patterns
- Use `grep` to find all instances of problematic patterns
- Search for `durationManual` to find all manual entry logic
- Search for `startTime.*targetDate` to find timezone issues
- Check both API endpoints and service layers for consistency

## Date Editing Patterns

### Manual Duration Entry Date Updates
- **CRITICAL**: Manual duration entries use `createdAt` for date association, not `startTime`
- **ALWAYS** check entry type before updating dates in date picker logic
- **ALWAYS** handle both timer-based and manual duration entries differently
- Pattern for date change logic:
  ```typescript
  // Check if this is a manual duration entry
  const isManualDurationEntry = currentEntry.durationManual && !currentEntry.startTime && !currentEntry.endTime;
  
  if (isManualDurationEntry) {
    // For manual duration entries, update createdAt
    const newCreatedAt = new Date(year, month - 1, day, 12, 0, 0, 0);
    updateData.createdAt = newCreatedAt.toISOString();
  } else {
    // For timer-based entries, update startTime and endTime
    if (currentEntry.startTime) {
      // Update startTime logic
    }
    if (currentEntry.endTime) {
      // Update endTime logic
    }
  }
  ```

### Date Picker Implementation
- **ALWAYS** test date picker functionality for both entry types
- **ALWAYS** ensure manual duration entries can have their dates changed
- **ALWAYS** verify that date changes persist correctly in the database
- **ALWAYS** check that date changes update the correct field (createdAt vs startTime)

### Service Layer Date Updates
- **ALWAYS** support `createdAt` updates in UpdateTimeEntryRequest interface
- **ALWAYS** handle `createdAt` field in service layer update methods
- **ALWAYS** ensure API endpoints can accept and process `createdAt` updates