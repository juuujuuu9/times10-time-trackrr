# .cursorrules

ruleset: 2.0.0

## Meta-Directive
This file defines how Cursor should interpret, enforce, and adapt to this project's evolving codebase. Cursor must treat this as a living contract that reflects actual development patterns.

## Core Principles
- **Simplicity First**: Choose the most straightforward solution that works
- **Explicit > implicit**: Make intentions clear through code
- **Local clarity > global cleverness**: Optimize for readability
- **Production-ready**: All code must be deployable and maintainable
- **Rule compliance**: Reference rules by ID (RULE-###) in all completions

## Rule Hierarchy & Conflict Resolution

### 1. FOUNDATIONAL (RULE-001): Simplicity First - Warning
- **OVERRIDES**: All other rules when they conflict with simplicity
- **PRINCIPLE**: The simplest solution that works is always preferred
- **APPLICATION**: When rules conflict, choose the simpler approach

### 2. ARCHITECTURAL (RULE-002-010): Code Quality - Error/Warning
- **FOLLOWS**: RULE-001 (Simplicity First)
- **COVERS**: TypeScript, Structure, Security, Performance, Accessibility

### 3. DOMAIN-SPECIFIC (RULE-011-015): Application Logic - Warning
- **FOLLOWS**: RULE-001 (Simplicity First)
- **COVERS**: Time tracking, database operations, API patterns

### 4. OPERATIONAL (RULE-016-020): Production Safety - Error
- **FOLLOWS**: RULE-001 (Simplicity First)
- **COVERS**: Database management, deployment, debugging

---

## Core Rules

### RULE-001: Simplicity First
- Choose the most direct path to solve the problem
- Avoid speculative generalization
- Refactor toward simplicity, not complexity
- Delete code more often than you add it
- **When in doubt, choose the simpler solution**
**Severity:** Warning (guiding principle)
**Applies to:** All code suggestions and refactors

### RULE-002: TypeScript Configuration
- Strict mode enabled
- No `any` type usage
- Prefer explicit return types for exported functions
- Use simple unions/intersections over complex generics
**Severity:** Error
**Applies to:** All TypeScript code

### RULE-003: Project Structure
- Organize by feature, not file type
- Use path aliases (`@/`, `@components/`, etc.)
- Keep related code colocated
- Flat structure > deep nesting (max 3 levels)
**Severity:** Warning
**Applies to:** File organization

### RULE-004: Code Quality Standards
- Functions max 50 lines without clear reason
- Files max 300 lines
- Nesting depth max 4 levels
- Cyclomatic complexity max 10
- Use semantic HTML first, ARIA when insufficient
**Severity:** Warning
**Applies to:** All code

### RULE-005: Security Requirements
- No secrets in client-side code
- Use parameterized queries only (no string concatenation)
- Sanitize user-generated content
- Use framework security features, avoid custom crypto/auth
**Severity:** Error
**Applies to:** All security-sensitive code

### RULE-006: Performance Guidelines
- Optimize images before commit
- Limit client-side hydration (`client:load` sparingly)
- Lazy load heavy components
- Measure before optimizing; avoid speculative performance code
**Severity:** Warning
**Applies to:** Performance-critical code

### RULE-007: Accessibility Standards
- Enforce keyboard navigation support
- Include ARIA attributes where semantic HTML insufficient
- Test focus management in interactive components
- Use semantic HTML first; ARIA only when HTML semantics insufficient
**Severity:** Error
**Applies to:** All user-facing code

### RULE-008: Testing Requirements
- Write tests for behavior, not implementation
- Avoid brittle tests that break with refactoring
- Test critical user flows
- Include edge cases for time-sensitive features
**Severity:** Warning
**Applies to:** All feature development

### RULE-009: Documentation Standards
- Document complex business logic
- Include "why" explanations for non-obvious decisions
- Keep README files current
- Document API endpoints with examples
**Severity:** Warning
**Applies to:** All code and features

### RULE-010: Deployment Safety
- Use conventional commits (feat:, fix:, docs:, etc.)
- Include "Rule Impact: RULE-###" in PR descriptions when relevant
- Test in staging before production
- Verify database migrations before deployment
**Severity:** Error
**Applies to:** All deployments

---

## Domain-Specific Rules

### RULE-011: Date/Time Handling
- **CRITICAL**: Manual duration entries MUST have `startTime: null` and `endTime: null`
- Use `createdAt` field for date association with manual entries, not `startTime`
- Always use local date components for date construction to avoid timezone issues
- Never use `toISOString().split('T')[0]` for date strings
- Use timezone utilities from `src/utils/timezoneUtils.ts`
**Severity:** Error
**Applies to:** All date/time operations

### RULE-012: Database Operations
- Always run schema audits before and after migrations
- Verify all expected tables exist in production
- Check foreign key constraints and indexes
- Validate data integrity before applying schema changes
- Use `drizzle-kit push --force` for production schema updates
- Delete in dependency order: child tables first, then parent tables
**Severity:** Error
**Applies to:** All database operations

### RULE-013: API Design
- Always return consistent error response format
- Include success/error status in responses
- Use `projectId` as primary field name, support `taskId` for backward compatibility
- Never create mock data when API endpoints are missing
- Always ask: "Would you like me to create the missing API endpoint?"
**Severity:** Error
**Applies to:** All API development

### RULE-014: Error Handling
- Use try-catch blocks for all async operations
- Provide user-friendly error messages
- Log detailed errors to console for debugging
- Handle both network errors and application errors
- Distinguish between user errors and system errors
**Severity:** Error
**Applies to:** All async operations

### RULE-015: Real-time Features
- Implement real-time updates using custom events for cross-component communication
- Clean up event listeners in `useEffect` cleanup functions
- Include comprehensive data in custom events to avoid additional API calls
- Test real-time updates across different components
- Include fallback mechanisms when real-time updates fail
**Severity:** Warning
**Applies to:** Real-time feature development

---

## Operational Rules

### RULE-016: Debugging Practices
- Add comprehensive logging to API calls during development
- Use distinctive console log prefixes for easy filtering
- Remove debug logs before production deployment
- Test database connections before performing operations
- Create minimal test endpoints to isolate issues
**Severity:** Warning
**Applies to:** Development and debugging

### RULE-017: Code Review Standards
- Verify refactor maintains rule compliance
- Flag rules that would be violated by proposed changes
- Suggest rule-aligned alternative approaches
- Prioritize clarity over cleverness in all refactors
- Remove unnecessary indirection and abstraction layers
**Severity:** Warning
**Applies to:** All code reviews

### RULE-018: Dependency Management
- Justify every new dependency
- Prefer platform/framework features over libraries
- Remove unused dependencies immediately
- Ask: "Can I write this in 20 lines instead of importing a package?"
**Severity:** Warning
**Applies to:** Package management

### RULE-019: Environment Configuration
- Use environment-specific database URLs for audits
- Create environment-agnostic audit scripts
- Provide clear error messages for missing environment variables
- Test in multiple environments before production
**Severity:** Warning
**Applies to:** Environment setup

### RULE-020: Production Readiness
- All code must be deployable without manual intervention
- Include comprehensive error handling for missing tables
- Test error states in production environments
- Verify all collaborative features work without 500 errors
- Document the impact of schema changes on application functionality
**Severity:** Error
**Applies to:** Production deployments

### RULE-021: Frontend Terminology
- **CRITICAL**: Never use "Discussions" in frontend text - use "Insights" instead
- All user-facing text must use "Insights" for collaborative content
- API responses and error messages must use "Insights" terminology
- Search functionality must reference "insights" not "discussions"
- Database schema names can remain as `taskDiscussions` for consistency
**Severity:** Error
**Applies to:** All frontend development and API responses

---

## Cursor Behavior Instructions

### Code Completion
- Always check completion against active rules
- Annotate suggestions with relevant rule IDs
- Prefer rule-compliant alternatives over raw suggestions
- Default to the simplest approach that satisfies requirements
- Never suggest mock data; always ask about creating missing API endpoints

### Refactoring
- Verify refactor maintains rule compliance
- Flag rules that would be violated by proposed changes
- Suggest rule-aligned alternative approaches
- Prioritize clarity over cleverness in all refactors
- Remove unnecessary indirection and abstraction layers

### Problem-Solving Approach
1. Understand the immediate requirement (not future possibilities)
2. Identify the most direct solution using existing code
3. Check if the solution can be simpler
4. Only then suggest the code
5. Note when resisting the urge to over-engineer

### Code Review Mindset
When reviewing or suggesting code, ask:
- "What's the simplest thing that could work?"
- "Am I solving a problem that doesn't exist yet?"
- "Will this be obvious to someone new in 6 months?"
- "Can I delete code instead of adding it?"

---

## Time Tracking App - Specific Patterns

### Manual Duration Entry Patterns
- **CRITICAL**: Manual duration entries MUST have `startTime: null` and `endTime: null`
- Use `createdAt` field for date association, not `startTime`
- Pattern for manual entry creation:
  ```typescript
  const newEntry = {
    userId,
    projectId,
    startTime: null,        // ALWAYS null for manual entries
    endTime: null,          // ALWAYS null for manual entries  
    durationManual: parsedDuration,
    notes: 'Manual duration entry',
    createdAt: new Date(),
    updatedAt: new Date()
  };
  ```

### Database Query Patterns
- For manual duration entries, use `createdAt` for date filtering, not `startTime`
- Always check for both timer entries AND manual entries:
  ```sql
  WHERE (startTime IS NOT NULL AND endTime IS NOT NULL) 
     OR (durationManual IS NOT NULL)
  ```

### React Component Patterns
- Always wrap data loading functions with `useCallback` and proper dependencies
- Always memoize event handlers to prevent infinite re-renders
- Always dispatch custom events after successful API calls
- Always use local date components for date construction to avoid timezone issues

### API Response Patterns
- Always return consistent error response format:
  ```typescript
  return new Response(JSON.stringify({
    success: true/false,
    message: 'Description',
    data: result,
    error: errorMessage
  }), {
    status: 200/400/500,
    headers: { 'Content-Type': 'application/json' }
  });
  ```

### Common Anti-Patterns to Avoid
- ❌ Set `startTime` and `endTime` for manual duration entries
- ❌ Use `toISOString()` for date string construction
- ❌ Forget to memoize functions used in `useCallback` dependencies
- ❌ Create manual entries without proper date association
- ❌ Mix timer-based and manual entry logic

### ✅ Best Practices
- Use `null` for start/end times on manual entries
- Use local date components for date strings
- Memoize all functions used in event handlers
- Associate manual entries with correct dates via `createdAt`
- Keep timer and manual entry logic separate

---

## Rule Updates Protocol
1. Detect pattern requiring new rule
2. Draft rule with ID, description, severity
3. Present proposal to developer for approval
4. Update documentation when rules change
5. Include simplicity analysis: Why this rule prevents bloat

## Complexity Warnings
Cursor will flag and suggest alternatives for:
- Functions longer than 50 lines without clear reason
- Files longer than 300 lines
- Nesting depth > 4 levels
- Cyclomatic complexity > 10
- Abstractions used only once
- More than 2 layers of indirection to accomplish a task