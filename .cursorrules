# .cursorrules

ruleset: 2.0.0

## Meta-Directive
This file defines how Cursor should interpret, enforce, and adapt to this project's evolving codebase. Cursor must treat this as a living contract that reflects actual development patterns.

## Core Principles
- **Simplicity First**: Choose the most straightforward solution that works
- **Explicit > implicit**: Make intentions clear through code
- **Local clarity > global cleverness**: Optimize for readability
- **Production-ready**: All code must be deployable and maintainable
- **Rule compliance**: Reference rules by ID (RULE-###) in all completions

## Rule Hierarchy & Conflict Resolution

### 1. FOUNDATIONAL (RULE-001): Simplicity First - Warning
- **OVERRIDES**: All other rules when they conflict with simplicity
- **PRINCIPLE**: The simplest solution that works is always preferred
- **APPLICATION**: When rules conflict, choose the simpler approach

### 2. ARCHITECTURAL (RULE-002-010): Code Quality - Error/Warning
- **FOLLOWS**: RULE-001 (Simplicity First)
- **COVERS**: TypeScript, Structure, Security, Performance, Accessibility

### 3. DOMAIN-SPECIFIC (RULE-011-015): Application Logic - Warning
- **FOLLOWS**: RULE-001 (Simplicity First)
- **COVERS**: Time tracking, database operations, API patterns

### 4. OPERATIONAL (RULE-016-020): Production Safety - Error
- **FOLLOWS**: RULE-001 (Simplicity First)
- **COVERS**: Database management, deployment, debugging

---

## Core Rules

### RULE-001: Simplicity First
- Choose the most direct path to solve the problem
- Avoid speculative generalization
- Refactor toward simplicity, not complexity
- Delete code more often than you add it
- **When in doubt, choose the simpler solution**
**Severity:** Warning (guiding principle)
**Applies to:** All code suggestions and refactors

### RULE-002: TypeScript Configuration
- Strict mode enabled
- No `any` type usage
- Prefer explicit return types for exported functions
- Use simple unions/intersections over complex generics
**Severity:** Error
**Applies to:** All TypeScript code

### RULE-003: Project Structure
- Organize by feature, not file type
- Use path aliases (`@/`, `@components/`, etc.)
- Keep related code colocated
- Flat structure > deep nesting (max 3 levels)
**Severity:** Warning
**Applies to:** File organization

### RULE-004: Code Quality Standards
- Functions max 50 lines without clear reason
- Files max 300 lines
- Nesting depth max 4 levels
- Cyclomatic complexity max 10
- Use semantic HTML first, ARIA when insufficient
**Severity:** Warning
**Applies to:** All code

### RULE-005: UI Design Standards
- **NO BLUE BUTTONS**: Use `bg-gray-600` for prominent buttons, not blue
- **NO HOVER SCALE EFFECTS**: Never use `hover:scale-105` or similar transform effects
- Keep hover effects simple: color changes only (`hover:bg-gray-700`)
- Avoid `transform` and `scale` classes in hover states
**Severity:** Error
**Applies to:** All UI components and buttons

### RULE-006: Security Requirements
- No secrets in client-side code
- Use parameterized queries only (no string concatenation)
- Sanitize user-generated content
- Use framework security features, avoid custom crypto/auth
**Severity:** Error
**Applies to:** All security-sensitive code

### RULE-007: Performance Guidelines
- Optimize images before commit
- Limit client-side hydration (`client:load` sparingly)
- Lazy load heavy components
- Measure before optimizing; avoid speculative performance code
**Severity:** Warning
**Applies to:** Performance-critical code

### RULE-008: Accessibility Standards
- Enforce keyboard navigation support
- Include ARIA attributes where semantic HTML insufficient
- Test focus management in interactive components
- Use semantic HTML first; ARIA only when HTML semantics insufficient
**Severity:** Error
**Applies to:** All user-facing code

### RULE-009: Testing Requirements
- Write tests for behavior, not implementation
- Avoid brittle tests that break with refactoring
- Test critical user flows
- Include edge cases for time-sensitive features
**Severity:** Warning
**Applies to:** All feature development

### RULE-010: Documentation Standards
- Document complex business logic
- Include "why" explanations for non-obvious decisions
- Keep README files current
- Document API endpoints with examples
**Severity:** Warning
**Applies to:** All code and features

### RULE-011: Deployment Safety
- Use conventional commits (feat:, fix:, docs:, etc.)
- Include "Rule Impact: RULE-###" in PR descriptions when relevant
- Test in staging before production
- Verify database migrations before deployment
**Severity:** Error
**Applies to:** All deployments

---

## Domain-Specific Rules

### RULE-011: Date/Time Handling
- **CRITICAL**: Manual duration entries MUST have `startTime: null` and `endTime: null`
- Use `createdAt` field for date association with manual entries, not `startTime`
- Always use local date components for date construction to avoid timezone issues
- Never use `toISOString().split('T')[0]` for date strings
- Use timezone utilities from `src/utils/timezoneUtils.ts`
**Severity:** Error
**Applies to:** All date/time operations

### RULE-012: Database Operations
- Always run schema audits before and after migrations
- Verify all expected tables exist in production
- Check foreign key constraints and indexes
- Validate data integrity before applying schema changes
- Use `drizzle-kit push --force` for production schema updates
- Delete in dependency order: child tables first, then parent tables
**Severity:** Error
**Applies to:** All database operations

### RULE-013: API Design
- Always return consistent error response format
- Include success/error status in responses
- Use `projectId` as primary field name, support `taskId` for backward compatibility
- Never create mock data when API endpoints are missing
- Always ask: "Would you like me to create the missing API endpoint?"
**Severity:** Error
**Applies to:** All API development

### RULE-014: Error Handling
- Use try-catch blocks for all async operations
- Provide user-friendly error messages
- Log detailed errors to console for debugging
- Handle both network errors and application errors
- Distinguish between user errors and system errors
**Severity:** Error
**Applies to:** All async operations

### RULE-015: Real-time Features
- Implement real-time updates using custom events for cross-component communication
- Clean up event listeners in `useEffect` cleanup functions
- Include comprehensive data in custom events to avoid additional API calls
- Test real-time updates across different components
- Include fallback mechanisms when real-time updates fail
**Severity:** Warning
**Applies to:** Real-time feature development

---

## Operational Rules

### RULE-016: Debugging Practices
- Add comprehensive logging to API calls during development
- Use distinctive console log prefixes for easy filtering
- Remove debug logs before production deployment
- Test database connections before performing operations
- Create minimal test endpoints to isolate issues
**Severity:** Warning
**Applies to:** Development and debugging

### RULE-017: Code Review Standards
- Verify refactor maintains rule compliance
- Flag rules that would be violated by proposed changes
- Suggest rule-aligned alternative approaches
- Prioritize clarity over cleverness in all refactors
- Remove unnecessary indirection and abstraction layers
**Severity:** Warning
**Applies to:** All code reviews

### RULE-018: Dependency Management
- Justify every new dependency
- Prefer platform/framework features over libraries
- Remove unused dependencies immediately
- Ask: "Can I write this in 20 lines instead of importing a package?"
**Severity:** Warning
**Applies to:** Package management

### RULE-019: Environment Configuration
- Use environment-specific database URLs for audits
- Create environment-agnostic audit scripts
- Provide clear error messages for missing environment variables
- Test in multiple environments before production
**Severity:** Warning
**Applies to:** Environment setup

### RULE-020: Production Readiness
- All code must be deployable without manual intervention
- Include comprehensive error handling for missing tables
- Test error states in production environments
- Verify all collaborative features work without 500 errors
- Document the impact of schema changes on application functionality
**Severity:** Error
**Applies to:** Production deployments

### RULE-021: API Endpoint Structure
- **CRITICAL**: Always use Astro context pattern: `async (context)` not `async ({ request, cookies })`
- Use `context.request.json()` not `request.json()`
- Use `getSessionUser(context)` not `getSessionUser({ cookies } as any)`
- All API endpoints must follow consistent error response format
- Include detailed logging for database operations
- Test API endpoints with proper context structure
**Severity:** Error
**Applies to:** All API endpoint development

### RULE-022: Permission System Patterns
- **CRITICAL**: Create collaboration-specific endpoints instead of reusing admin endpoints
- Check collaboration membership, not just admin roles for collaboration features
- Use direct database queries for team members instead of complex relationship queries
- Validate team membership with explicit user ID checks
- Include detailed debugging for permission validation
- Never assume relationship queries work - test with direct queries
**Severity:** Error
**Applies to:** All permission-sensitive features

### RULE-023: Database Relationship Queries
- **CRITICAL**: When relationship queries fail, use direct table queries as fallback
- Always test relationship queries with actual data
- Include debugging logs for relationship query results
- Prefer explicit joins over complex relationship queries for critical operations
- Validate that relationship queries return expected data structure
**Severity:** Warning
**Applies to:** All database operations using relationships

### RULE-024: Error Handling and Debugging
- **CRITICAL**: Include detailed error logging with error names, messages, and stack traces
- Log database operation inputs and outputs for debugging
- Provide specific error messages that help identify the root cause
- Include debugging information in error responses (in development)
- Test error scenarios to ensure proper error handling
**Severity:** Error
**Applies to:** All error handling code

### RULE-025: Task Assignment Validation
- **CRITICAL**: Validate that users are team members before task assignment
- Use direct team member queries, not relationship queries
- Include detailed logging for team member validation
- Check both direct team association and project association for tasks
- Provide clear error messages for invalid user assignments
**Severity:** Error
**Applies to:** All task assignment operations

### RULE-026: Frontend Terminology
- **CRITICAL**: Never use "Discussions" in frontend text - use "Insights" instead
- All user-facing text must use "Insights" for collaborative content
- API responses and error messages must use "Insights" terminology
- Search functionality must reference "insights" not "discussions"
- Database schema names can remain as `taskDiscussions` for consistency
**Severity:** Error
**Applies to:** All frontend development and API responses

### RULE-027: Collaboration System Architecture
- **CRITICAL**: Tasks created in collaborations may not have direct teamId association
- Use project-based association for task validation when teamId is null
- Create collaboration-specific API endpoints for all collaboration operations
- Never reuse admin endpoints for collaboration features
- Include both teamId and projectId validation for task operations
- Test task operations with both direct team association and project association
**Severity:** Error
**Applies to:** All collaboration-related features

### RULE-022: Database Synchronization Workflow
- **CRITICAL**: Always run `node comprehensive-db-audit.js` before making schema changes
- Use `./sync-databases.sh` for quick local-to-production deployment
- Use `./deploy-to-production.sh` for major schema changes requiring backups
- Never deploy schema changes without running audit first
- Always verify schemas are in sync before and after deployment
- Keep audit results in `audit-results/` directory for tracking
**Severity:** Error
**Applies to:** All database schema changes and deployments

### RULE-023: Database Deployment Safety
- Always create production backup before major schema changes
- Test schema changes locally before deploying to production
- Use force mode (`--force`) only when absolutely necessary
- Monitor application after deployment for any issues
- Keep backup files safe for emergency rollback
- Document any manual schema changes in deployment notes
**Severity:** Error
**Applies to:** All production database operations

---

## Cursor Behavior Instructions

### Code Completion
- Always check completion against active rules
- Annotate suggestions with relevant rule IDs
- Prefer rule-compliant alternatives over raw suggestions
- Default to the simplest approach that satisfies requirements
- Never suggest mock data; always ask about creating missing API endpoints

### Refactoring
- Verify refactor maintains rule compliance
- Flag rules that would be violated by proposed changes
- Suggest rule-aligned alternative approaches
- Prioritize clarity over cleverness in all refactors
- Remove unnecessary indirection and abstraction layers

### Problem-Solving Approach
1. Understand the immediate requirement (not future possibilities)
2. Identify the most direct solution using existing code
3. Check if the solution can be simpler
4. Only then suggest the code
5. Note when resisting the urge to over-engineer

### Code Review Mindset
When reviewing or suggesting code, ask:
- "What's the simplest thing that could work?"
- "Am I solving a problem that doesn't exist yet?"
- "Will this be obvious to someone new in 6 months?"
- "Can I delete code instead of adding it?"

---

## Time Tracking App - Specific Patterns

### Manual Duration Entry Patterns
- **CRITICAL**: Manual duration entries MUST have `startTime: null` and `endTime: null`
- Use `createdAt` field for date association, not `startTime`
- Pattern for manual entry creation:
  ```typescript
  const newEntry = {
    userId,
    projectId,
    startTime: null,        // ALWAYS null for manual entries
    endTime: null,          // ALWAYS null for manual entries  
    durationManual: parsedDuration,
    notes: 'Manual duration entry',
    createdAt: new Date(),
    updatedAt: new Date()
  };
  ```

### Database Query Patterns
- For manual duration entries, use `createdAt` for date filtering, not `startTime`
- Always check for both timer entries AND manual entries:
  ```sql
  WHERE (startTime IS NOT NULL AND endTime IS NOT NULL) 
     OR (durationManual IS NOT NULL)
  ```

### React Component Patterns
- Always wrap data loading functions with `useCallback` and proper dependencies
- Always memoize event handlers to prevent infinite re-renders
- Always dispatch custom events after successful API calls
- Always use local date components for date construction to avoid timezone issues

### API Response Patterns
- Always return consistent error response format:
  ```typescript
  return new Response(JSON.stringify({
    success: true/false,
    message: 'Description',
    data: result,
    error: errorMessage
  }), {
    status: 200/400/500,
    headers: { 'Content-Type': 'application/json' }
  });
  ```

### Common Anti-Patterns to Avoid
- ❌ Set `startTime` and `endTime` for manual duration entries
- ❌ Use `toISOString()` for date string construction
- ❌ Forget to memoize functions used in `useCallback` dependencies
- ❌ Create manual entries without proper date association
- ❌ Mix timer-based and manual entry logic

### ✅ Best Practices
- Use `null` for start/end times on manual entries
- Use local date components for date strings
- Memoize all functions used in event handlers
- Associate manual entries with correct dates via `createdAt`
- Keep timer and manual entry logic separate

### Database Synchronization Patterns
- **CRITICAL**: Always run audit before schema changes: `node comprehensive-db-audit.js`
- Quick sync for small changes: `./sync-databases.sh`
- Full deployment for major changes: `./deploy-to-production.sh`
- Pattern for schema change workflow:
  ```bash
  # 1. Make schema changes in src/db/schema.ts
  # 2. Run audit to check current state
  node comprehensive-db-audit.js
  # 3. Deploy changes
  ./sync-databases.sh
  # 4. Verify deployment
  node comprehensive-db-audit.js
  ```

### Database Deployment Anti-Patterns
- ❌ Deploy schema changes without running audit first
- ❌ Skip backup creation for major schema changes
- ❌ Use force mode without understanding the impact
- ❌ Deploy to production without testing locally first
- ❌ Ignore audit warnings or critical differences

### ✅ Database Deployment Best Practices
- Always audit before and after deployment
- Create backups for major changes
- Test locally before production deployment
- Monitor application after deployment
- Keep audit results for tracking changes

---

## Rule Updates Protocol
1. Detect pattern requiring new rule
2. Draft rule with ID, description, severity
3. Present proposal to developer for approval
4. Update documentation when rules change
5. Include simplicity analysis: Why this rule prevents bloat

## Complexity Warnings
Cursor will flag and suggest alternatives for:
- Functions longer than 50 lines without clear reason
- Files longer than 300 lines
- Nesting depth > 4 levels
- Cyclomatic complexity > 10
- Abstractions used only once
- More than 2 layers of indirection to accomplish a task