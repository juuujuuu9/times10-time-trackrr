---
import DashboardLayout from '../layouts/DashboardLayout.astro';
import { requireAuth } from '../utils/session';
import { db } from '../db/index';
import { timeEntries, users, tasks, projects, clients } from '../db/schema';
import { sql, eq, and, gte, lte, isNotNull } from 'drizzle-orm';
import { formatTimeForDisplay } from '../utils/timezoneUtils';

// Require authentication
const user = await requireAuth(Astro, '/') as any;

// Format duration in seconds to "Xh Xm" format
function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  return `${hours}h ${minutes}m`;
}

// Calculate this week (Sunday to Saturday) to match dashboard
const now = new Date();
const dayOfWeek = now.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
const daysToSubtract = dayOfWeek === 0 ? 0 : dayOfWeek; // If today is Sunday, don't subtract any days

const weekStart = new Date(now);
weekStart.setDate(now.getDate() - daysToSubtract);
weekStart.setHours(0, 0, 0, 0);

const weekEnd = new Date(weekStart);
weekEnd.setDate(weekStart.getDate() + 6);
weekEnd.setHours(23, 59, 59, 999);

// Get current user's time entries with related data (only non-archived activities)
// Filter by the current week range (Sunday to Saturday)
const userTimeEntries = await db
  .select({
    id: timeEntries.id,
    startTime: timeEntries.startTime,
    endTime: timeEntries.endTime,
    durationManual: timeEntries.durationManual,
    notes: timeEntries.notes,
    createdAt: timeEntries.createdAt,
    userName: users.name,
    taskName: sql<string>`'General'`.as('taskName'), // Since we're now using projects as tasks
    projectName: projects.name,
    clientName: clients.name,
    duration: sql<number>`CASE 
      WHEN ${timeEntries.durationManual} IS NOT NULL 
      THEN ${timeEntries.durationManual}
      WHEN ${timeEntries.endTime} IS NOT NULL 
      THEN EXTRACT(EPOCH FROM (${timeEntries.endTime} - ${timeEntries.startTime}))
      ELSE 0
    END`.as('duration')
  })
  .from(timeEntries)
  .innerJoin(users, eq(timeEntries.userId, users.id))
  .innerJoin(projects, eq(timeEntries.projectId, projects.id))
  .innerJoin(clients, eq(projects.clientId, clients.id))
  .where(and(
    eq(timeEntries.userId, user.id),
    // Include completed time entries (with endTime) OR manual duration entries (with durationManual)
    sql`(${timeEntries.endTime} IS NOT NULL OR ${timeEntries.durationManual} IS NOT NULL)`,
    eq(clients.archived, false),
    eq(projects.archived, false)
  ))
  .orderBy(sql`COALESCE(${timeEntries.startTime}, ${timeEntries.createdAt}) DESC`);

// Get all clients for filtering (only those the user has worked on - non-archived activities)
const userClients = await db
  .selectDistinct({ name: clients.name })
  .from(timeEntries)
  .innerJoin(projects, eq(timeEntries.projectId, projects.id))
  .innerJoin(clients, eq(projects.clientId, clients.id))
  .where(and(
    eq(timeEntries.userId, user.id),
    eq(clients.archived, false),
    eq(projects.archived, false)
  ))
  .orderBy(clients.name);


// Format date range for display (matching dashboard format: M/D-M/D)
const formatDateRange = (start: Date, end: Date) => {
  const formatDateForDisplay = (date: Date) => {
    const month = date.getMonth() + 1; // getMonth() returns 0-11
    const day = date.getDate();
    return `${month}/${day}`;
  };
  
  return `${formatDateForDisplay(start)}-${formatDateForDisplay(end)}`;
};

const currentWeekRange = formatDateRange(weekStart, weekEnd);
---

<DashboardLayout title="My Time Entries - Times10 Time Tracker">

    <div class="max-w-7xl mx-auto p-2 sm:p-4 lg:p-8">
      <div class="space-y-2 sm:space-y-4 lg:space-y-8">
        <!-- Header -->
        <div class="flex flex-col lg:flex-row lg:justify-between lg:items-center space-y-4 lg:space-y-0">
          <div class="w-full lg:w-auto">
            <h1 class="text-2xl font-bold text-gray-900">My Time Entries</h1>
            <p class="text-gray-600">View and manage your time tracking data</p>
          </div>
          <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-3 w-full lg:w-auto">
            <button
              id="exportCsvBtn"
              class="inline-flex items-center justify-center px-4 py-2 text-white font-medium rounded-lg transition-all duration-200 shadow-sm hover:shadow-md w-full sm:w-1/2 lg:w-auto"
              style="background-color: #1F292E;"
              onmouseover="this.style.backgroundColor='#000000'"
              onmouseout="this.style.backgroundColor='#1F292E'"
            >
              <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
              </svg>
              Export CSV
            </button>
            <a
              href={user?.role === 'admin' ? '/admin' : '/dashboard'}
              class="inline-flex items-center justify-center px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white font-medium rounded-lg transition-all duration-200 shadow-sm hover:shadow-md w-full sm:w-1/2 lg:w-auto"
            >
              <span class="mr-2">‚Üê</span>
              {user?.role === 'admin' ? 'Back to Dashboard' : 'Back to Timer'}
            </a>
          </div>
        </div>

        <!-- Filters -->
        <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-2 sm:p-4 lg:p-6">
          <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div>
              <label for="search" class="block text-sm font-medium text-gray-700 mb-1">Search</label>
              <input
                type="text"
                id="search"
                placeholder="Search entries..."
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#415058] focus:border-[#415058]"
              />
            </div>
            <div>
              <label for="clientFilter" class="block text-sm font-medium text-gray-700 mb-1">Client</label>
              <select
                id="clientFilter"
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#415058] focus:border-[#415058]"
              >
                <option value="">All Clients</option>
                {userClients.map((client) => (
                  <option value={client.name}>{client.name}</option>
                ))}
              </select>
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">Date Range</label>
              <div class="flex items-center space-x-2 border border-gray-300 rounded-md px-3 py-2 bg-white">
                <button
                  id="prevWeekBtn"
                  class="text-gray-600 hover:text-gray-900 transition-colors p-1"
                  title="Previous Week"
                >
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                  </svg>
                </button>
                
                <span id="weekRangeDisplay" class="text-gray-700 font-medium text-sm flex-1 text-center">{currentWeekRange}</span>
                
                <button
                  id="nextWeekBtn"
                  class="text-gray-600 hover:text-gray-900 transition-colors p-1"
                  title="Next Week"
                >
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                  </svg>
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Time Entries Table -->
        <div class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
          <!-- Results Counter -->
          <div class="px-2 sm:px-4 lg:px-6 py-3 bg-gray-50 border-b border-gray-200">
            <div class="flex justify-between items-center">
              <span id="resultsCounter" class="text-sm text-gray-600">
                Showing {userTimeEntries.length} time entries
              </span>
              <span class="text-xs text-gray-500">
                Total entries: {userTimeEntries.length}
              </span>
            </div>
          </div>
          <div class="overflow-x-auto">
            <style>
              .table-column-separator {
                position: relative;
              }
              .table-column-separator:not(:last-child)::after {
                content: '';
                position: absolute;
                right: 0;
                top: 20%;
                bottom: 20%;
                width: 1px;
                background-color: #e5e7eb;
                opacity: 0.6;
              }
              .table-column-separator-header:not(:last-child)::after {
                content: '';
                position: absolute;
                right: 0;
                top: 15%;
                bottom: 15%;
                width: 1px;
                background-color: #d1d5db;
                opacity: 0.8;
              }
            </style>
            <table class="min-w-full divide-y divide-gray-200">
              <thead class="bg-gray-50">
                <tr>
                  <th class="table-column-separator-header px-2 sm:px-4 lg:px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Client
                  </th>
                  <th class="table-column-separator-header px-2 sm:px-4 lg:px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Project
                  </th>
                  <th class="table-column-separator-header px-2 sm:px-4 lg:px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    <div class="flex items-center justify-between">
                      <span>Date</span>
                      <div class="flex flex-col ml-2">
                        <button id="dateSortUp" class="text-gray-400 hover:text-gray-600 transition-colors p-1" title="Sort by date (newest first)">
                          <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path>
                          </svg>
                        </button>
                        <button id="dateSortDown" class="text-gray-400 hover:text-gray-600 transition-colors p-1" title="Sort by date (oldest first)">
                          <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                          </svg>
                        </button>
                      </div>
                    </div>
                  </th>
                  <th class="table-column-separator-header px-2 sm:px-4 lg:px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Start
                  </th>
                  <th class="table-column-separator-header px-2 sm:px-4 lg:px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Stop
                  </th>
                  <th class="table-column-separator-header px-2 sm:px-4 lg:px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Duration
                  </th>
                  <th class="table-column-separator-header px-2 sm:px-4 lg:px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Notes
                  </th>
                  <th class="table-column-separator-header px-2 sm:px-4 lg:px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody class="bg-white divide-y divide-gray-200">
                {userTimeEntries.map((entry) => {
                  // Display using the user's local date so late-night entries show on the intended day
                  // For manual duration entries, use createdAt; for timer entries, use startTime
                  const taskDate = entry.startTime ? 
                    (() => {
                      const date = new Date(entry.startTime);
                      const year = date.getFullYear();
                      const month = date.getMonth() + 1;
                      const day = date.getDate();
                      return new Date(year, month - 1, day, 0, 0, 0, 0);
                    })() : 
                    (() => {
                      const date = new Date(entry.createdAt);
                      const year = date.getFullYear();
                      const month = date.getMonth() + 1;
                      const day = date.getDate();
                      return new Date(year, month - 1, day, 0, 0, 0, 0);
                    })();
                  const duration = entry.duration ? entry.duration / 3600 : 0;
                  
                  // Check if this is a manual duration entry (no meaningful start/end times)
                  // Manual duration entries have startTime set to task date but endTime is null
                  const isManualDurationEntry = entry.durationManual && !entry.endTime;
                  const startTime = (!isManualDurationEntry && entry.startTime) ? new Date(entry.startTime) : null;
                  const endTime = (!isManualDurationEntry && entry.endTime) ? new Date(entry.endTime) : null;
                  
                  return (
                    <tr class="hover:bg-gray-50" data-entry-id={entry.id}>
                      <td class="table-column-separator px-2 sm:px-4 lg:px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {entry.clientName}
                      </td>
                      <td class="table-column-separator px-2 sm:px-4 lg:px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {entry.projectName}
                      </td>
                      <td class="table-column-separator px-2 sm:px-4 lg:px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        <input
                          type="text"
                          class="date-input w-24 px-2 py-1 text-xs border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                          value={taskDate.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: 'numeric' })}
                          data-entry-id={entry.id}
                          data-current-date={taskDate.toISOString().split('T')[0]}
                          placeholder="mm/dd/yyyy"
                          title="Click to open date picker"
                        />
                      </td>
                      <td class="table-column-separator px-2 sm:px-4 lg:px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        <input
                          type="text"
                          class={`time-input w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent hover:border-blue-400 cursor-pointer ${isManualDurationEntry ? 'bg-gray-100 cursor-not-allowed' : ''}`}
                          value={startTime ? formatTimeForDisplay(startTime) : '--:-- --'}
                          data-entry-id={entry.id}
                          data-time-type="start"
                          placeholder="9:30 AM"
                          title={isManualDurationEntry ? 'Manual duration entry - use edit button to modify' : 'Click to edit start time'}
                          {...(isManualDurationEntry ? { readonly: true } : {})}
                        />
                      </td>
                      <td class="table-column-separator px-2 sm:px-4 lg:px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        <input
                          type="text"
                          class={`time-input w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-transparent hover:border-blue-400 cursor-pointer ${isManualDurationEntry ? 'bg-gray-100 cursor-not-allowed' : ''}`}
                          value={endTime ? formatTimeForDisplay(endTime) : '--:-- --'}
                          data-entry-id={entry.id}
                          data-time-type="end"
                          placeholder="9:30 AM"
                          title={isManualDurationEntry ? 'Manual duration entry - use edit button to modify' : 'Click to edit end time'}
                          {...(isManualDurationEntry ? { readonly: true } : {})}
                        />
                      </td>
                      <td class="table-column-separator px-2 sm:px-4 lg:px-6 py-4 whitespace-nowrap text-sm text-gray-900" data-role="duration">
                        <input
                          type="text"
                          class="duration-input w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent hover:border-blue-400 cursor-pointer"
                          value={(() => {
                            const seconds = entry.duration || 0;
                            const hours = Math.floor(seconds / 3600);
                            const minutes = Math.floor((seconds % 3600) / 60);
                            return `${hours}h ${minutes}m`;
                          })()}
                          data-entry-id={entry.id}
                          data-time-type="duration"
                          placeholder="2h 30m"
                          title="Click to edit duration"
                        />
                      </td>
                      <td class="table-column-separator px-2 sm:px-4 lg:px-6 py-4 text-sm text-gray-500 max-w-xs">
                        <input
                          type="text"
                          class="notes-input w-full px-2 py-1 text-xs border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                          data-entry-id={entry.id}
                          placeholder="Add Note"
                          value={entry.notes || ''}
                          title="Click to add or edit notes"
                        />
                      </td>
                      <td class="table-column-separator px-2 sm:px-4 lg:px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <button
                          class="edit-time-entry-btn p-2 text-gray-400 hover:text-[#415058] hover:bg-gray-50 rounded-md transition-colors"
                          data-entry-id={entry.id}
                          data-entry={JSON.stringify(entry)}
                          title="Edit time entry"
                        >
                          <img src="/icons/pencil.svg" alt="Edit" class="w-4 h-4" />
                        </button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>

        {userTimeEntries.length === 0 && (
          <div class="text-center py-12">
            <div class="text-6xl mb-4">‚è±Ô∏è</div>
            <h3 class="text-lg font-medium text-gray-900 mb-2">No time entries yet</h3>
            <p class="text-gray-600 mb-4">Start tracking time to see entries here</p>
            <a
              href={user?.role === 'admin' ? '/admin' : '/dashboard'}
              class="bg-[#415058] hover:bg-[#1F292E] text-white font-medium py-2 px-4 rounded-lg transition-colors"
            >
              {user?.role === 'admin' ? 'Go to Dashboard' : 'Go to Timer'}
            </a>
          </div>
        )}
      </div>
    </div>
  </div>

  <!-- Edit Time Entry Modal -->
  <div id="editTimeEntryModal" class="fixed inset-0 bg-black/50 hidden z-50">
    <div class="flex items-center justify-center min-h-screen p-4">
      <div class="bg-white rounded-lg shadow-xl max-w-md w-full max-h-[90vh] border border-gray-200 flex flex-col">
        <div class="px-6 py-4 border-b border-gray-200 flex-shrink-0">
          <h3 class="text-lg font-medium text-gray-900">Edit Time Entry</h3>
        </div>
        <div class="flex-1 overflow-y-auto">
          <form id="editTimeEntryForm" class="px-6 py-4">
            <input type="hidden" id="editTimeEntryId" />
            
            <!-- Task Selection -->
            <div class="mb-4">
              <label for="editTimeEntryTask" class="block text-sm font-medium text-gray-700 mb-1">
                Task <span class="text-gray-500 font-normal">(required)</span>
              </label>
              <div class="relative">
                <input
                  type="text"
                  id="editTimeEntryTask"
                  placeholder="üîç Search tasks..."
                  required
                  autocomplete="off"
                  class="w-full px-3 py-2 pr-10 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                  oninput="handleEditTaskSearch(this.value)"
                  onfocus="showEditTaskDropdown()"
                />
                <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-gray-500">
                  <svg id="editTaskDropdownArrow" class="fill-current h-5 w-5 transition-transform duration-200 cursor-pointer pointer-events-auto" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" onclick="toggleEditTaskDropdown()">
                    <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/>
                  </svg>
                </div>
                <input type="hidden" id="editTimeEntryTaskId" />
                <div id="editTaskDropdown" class="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-y-auto hidden">
                  <!-- Task results will be populated here -->
                </div>
              </div>
            </div>
            
            <!-- Time Entry Method Selection -->
            <div class="mb-6">
              <label class="block text-sm font-medium text-gray-700 mb-3">Edit Method</label>
              <div class="space-y-3">
                <label class="flex items-center">
                  <input type="radio" name="editMethod" value="times" class="mr-2" checked>
                  <span class="text-sm">Adjust start/end times</span>
                </label>
                <label class="flex items-center">
                  <input type="radio" name="editMethod" value="duration" class="mr-2">
                  <span class="text-sm">Manual duration entry</span>
                </label>
              </div>
            </div>

            <!-- Start/End Times Section -->
            <div id="timesSection" class="space-y-4">
              <div>
                <label for="editStartTime" class="block text-sm font-medium text-gray-700 mb-1">
                  Start Time
                </label>
                <input
                  type="text"
                  id="editStartTime"
                  placeholder="9:30 AM"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
              </div>
              <div>
                <label for="editEndTime" class="block text-sm font-medium text-gray-700 mb-1">
                  End Time
                </label>
                <input
                  type="text"
                  id="editEndTime"
                  placeholder="5:30 PM"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
              </div>
              <div>
                <label for="editTimesDate" class="block text-sm font-medium text-gray-700 mb-1">
                  Task Date <span class="text-gray-500 font-normal">(required)</span>
                </label>
                <input
                  type="date"
                  id="editTimesDate"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
                <p class="text-xs text-gray-500 mt-1">
                  When did this task actually occur?
                </p>
              </div>
            </div>

            <!-- Duration Section -->
            <div id="durationSection" class="hidden space-y-4">
              <div>
                <label for="editDuration" class="block text-sm font-medium text-gray-700 mb-1">
                  Duration
                </label>
                <input
                  type="text"
                  id="editDuration"
                  placeholder="e.g., 2h, 3.5hr, 4:15, 90m"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
                <p class="text-xs text-gray-500 mt-1">
                  Supported formats: 2h, 2hr, 3.5hr, 4:15, 90m, 5400s, etc.
                </p>
              </div>
              <div>
                <label for="editDurationDate" class="block text-sm font-medium text-gray-700 mb-1">
                  Task Date <span class="text-gray-500 font-normal">(required)</span>
                </label>
                <input
                  type="date"
                  id="editDurationDate"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
                <p class="text-xs text-gray-500 mt-1">
                  When did this task actually occur?
                </p>
              </div>
            </div>

            <div class="mb-6">
              <label for="editNotes" class="block text-sm font-medium text-gray-700 mb-1">
                Notes
              </label>
              <textarea
                id="editNotes"
                rows="3"
                placeholder="Optional notes about this time entry..."
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
              ></textarea>
            </div>

            <div class="flex justify-between">
              <button
                type="button"
                id="deleteTimeEntryBtn"
                class="px-4 py-2 text-white rounded-md transition-colors"
                style="background-color: #E24236; border: none;"
                onmouseover="this.style.backgroundColor='#D32F2F'"
                onmouseout="this.style.backgroundColor='#E24236'"
              >
                Delete Entry
              </button>
              <div class="flex space-x-3">
                <button
                  type="button"
                  id="cancelEditTimeEntryBtn"
                  class="px-4 py-2 text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  id="saveEditTimeEntryBtn"
                  class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md transition-colors flex items-center space-x-2"
                >
                  <span id="saveEditButtonText">Save Changes</span>
                  <svg id="saveEditButtonSpinner" class="w-4 h-4 animate-spin hidden" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                </button>
              </div>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>

  <!-- Flatpickr CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">

  <script>
    // Import Flatpickr
    import flatpickr from 'flatpickr';
    
    // Helper function to format time
    function formatTimeForUser(date: Date) {
      return new Intl.DateTimeFormat(undefined, {
        hour: '2-digit',
        minute: '2-digit',
        hour12: true
      }).format(date);
    }
    
    // Flexible time parser for natural human shorthand formats
    function parseFlexibleTime(timeString: string): { hours: number; minutes: number } | null {
      if (!timeString) return null;
      
      const trimmed = timeString.trim().toLowerCase();
      
      // Remove any extra spaces and normalize
      const normalized = trimmed.replace(/\s+/g, '');
      
      // Pattern 1: "3p", "3pm", "3PM" -> 3:00 PM
      let match = normalized.match(/^(\d{1,2})(p|pm)$/);
      if (match) {
        let hours = parseInt(match[1]);
        if (hours >= 1 && hours <= 12) {
          if (hours !== 12) hours += 12; // Convert to 24-hour format
          return { hours, minutes: 0 };
        }
      }
      
      // Pattern 2: "3a", "3am", "3AM" -> 3:00 AM
      match = normalized.match(/^(\d{1,2})(a|am)$/);
      if (match) {
        let hours = parseInt(match[1]);
        if (hours >= 1 && hours <= 12) {
          if (hours === 12) hours = 0; // 12 AM = 0:00
          return { hours, minutes: 0 };
        }
      }
      
      // Pattern 3: "300p", "300pm", "300PM" -> 3:00 PM
      match = normalized.match(/^(\d{1,2})(\d{2})(p|pm)$/);
      if (match) {
        let hours = parseInt(match[1]);
        const minutes = parseInt(match[2]);
        if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
          if (hours !== 12) hours += 12;
          return { hours, minutes };
        }
      }
      
      // Pattern 4: "300a", "300am", "300AM" -> 3:00 AM
      match = normalized.match(/^(\d{1,2})(\d{2})(a|am)$/);
      if (match) {
        let hours = parseInt(match[1]);
        const minutes = parseInt(match[2]);
        if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
          if (hours === 12) hours = 0;
          return { hours, minutes };
        }
      }
      
      // Pattern 5: "3:30p", "3:30pm", "3:30PM" -> 3:30 PM
      match = normalized.match(/^(\d{1,2}):(\d{2})(p|pm)$/);
      if (match) {
        let hours = parseInt(match[1]);
        const minutes = parseInt(match[2]);
        if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
          if (hours !== 12) hours += 12;
          return { hours, minutes };
        }
      }
      
      // Pattern 6: "3:30a", "3:30am", "3:30AM" -> 3:30 AM
      match = normalized.match(/^(\d{1,2}):(\d{2})(a|am)$/);
      if (match) {
        let hours = parseInt(match[1]);
        const minutes = parseInt(match[2]);
        if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
          if (hours === 12) hours = 0;
          return { hours, minutes };
        }
      }
      
      // Pattern 7: "3:30 p", "3:30 pm", "3:30 PM" (with space)
      match = normalized.match(/^(\d{1,2}):(\d{2})\s*(p|pm)$/);
      if (match) {
        let hours = parseInt(match[1]);
        const minutes = parseInt(match[2]);
        if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
          if (hours !== 12) hours += 12;
          return { hours, minutes };
        }
      }
      
      // Pattern 8: "3:30 a", "3:30 am", "3:30 AM" (with space)
      match = normalized.match(/^(\d{1,2}):(\d{2})\s*(a|am)$/);
      if (match) {
        let hours = parseInt(match[1]);
        const minutes = parseInt(match[2]);
        if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
          if (hours === 12) hours = 0;
          return { hours, minutes };
        }
      }
      
      // Pattern 9: "12:00pm", "12:00am" (noon/midnight)
      match = normalized.match(/^12:(\d{2})(p|pm)$/);
      if (match) {
        const minutes = parseInt(match[1]);
        if (minutes >= 0 && minutes <= 59) {
          return { hours: 12, minutes }; // 12 PM = 12:00
        }
      }
      
      match = normalized.match(/^12:(\d{2})(a|am)$/);
      if (match) {
        const minutes = parseInt(match[1]);
        if (minutes >= 0 && minutes <= 59) {
          return { hours: 0, minutes }; // 12 AM = 0:00
        }
      }
      
      return null; // No pattern matched
    }

    // Format duration in seconds to "Xh Xm" format
    function formatDuration(seconds: number): string {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      return `${hours}h ${minutes}m`;
    }

    // Parse flexible duration formats (2h 30m, 2.5h, 150m, 2:30, etc.)
    function parseFlexibleDuration(durationString: string): number | null {
      if (!durationString) return null;
      
      const trimmed = durationString.trim().toLowerCase();
      
      // Pattern 1: "2h 30m" or "2h30m"
      let match = trimmed.match(/^(\d+(?:\.\d+)?)h\s*(\d+)m?$/);
      if (match) {
        const hours = parseFloat(match[1]);
        const minutes = parseInt(match[2]);
        return (hours * 3600) + (minutes * 60);
      }
      
      // Pattern 2: "2.5h" or "2h"
      match = trimmed.match(/^(\d+(?:\.\d+)?)h$/);
      if (match) {
        const hours = parseFloat(match[1]);
        return hours * 3600;
      }
      
      // Pattern 3: "150m" or "150 min"
      match = trimmed.match(/^(\d+(?:\.\d+)?)m(?:in)?$/);
      if (match) {
        const minutes = parseFloat(match[1]);
        return minutes * 60;
      }
      
      // Pattern 4: "2:30" (hours:minutes)
      match = trimmed.match(/^(\d+):(\d{2})$/);
      if (match) {
        const hours = parseInt(match[1]);
        const minutes = parseInt(match[2]);
        return (hours * 3600) + (minutes * 60);
      }
      
      // Pattern 5: Just seconds "3600s" or "3600"
      match = trimmed.match(/^(\d+)s?$/);
      if (match) {
        const seconds = parseInt(match[1]);
        return seconds;
      }
      
      return null;
    }

    // Week navigation and filtering
  document.addEventListener('DOMContentLoaded', function() {
    // Populate time inputs using local timezone formatting (initial render)
    const timeInputsInitial = document.querySelectorAll('.time-input') as NodeListOf<HTMLInputElement>;
    timeInputsInitial.forEach((el) => {
      const iso = el.getAttribute('data-iso');
      if (iso) {
        const d = new Date(iso);
        el.value = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', hour12: true }).format(d);
      }
    });
    // Week navigation state - use Sunday-Saturday week to match dashboard
    let currentWeekStart = new Date();
    const dayOfWeek = currentWeekStart.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
    const daysToSubtract = dayOfWeek === 0 ? 0 : dayOfWeek; // If today is Sunday, don't subtract any days
    currentWeekStart.setDate(currentWeekStart.getDate() - daysToSubtract);
    currentWeekStart.setHours(0, 0, 0, 0);

      // Format date range for display (matching dashboard format: M/D-M/D)
      function formatDateRange(start: Date, end: Date): string {
        const formatDateForDisplay = (date: Date): string => {
          const month = date.getMonth() + 1; // getMonth() returns 0-11
          const day = date.getDate();
          return `${month}/${day}`;
        };
        
        return `${formatDateForDisplay(start)}-${formatDateForDisplay(end)}`;
      }

      // Update week display and filter entries
      function updateWeekDisplay() {
        const weekEnd = new Date(currentWeekStart);
        weekEnd.setDate(currentWeekStart.getDate() + 6);
        weekEnd.setHours(23, 59, 59, 999);
        
        const weekRangeDisplay = document.getElementById('weekRangeDisplay');
        if (weekRangeDisplay) {
          weekRangeDisplay.textContent = formatDateRange(currentWeekStart, weekEnd);
        }
        
        filterEntriesByWeek();
      }

      // Filter entries by current week (Sunday-Saturday)
      function filterEntriesByWeek() {
        const weekEnd = new Date(currentWeekStart);
        weekEnd.setDate(currentWeekStart.getDate() + 6);
        weekEnd.setHours(23, 59, 59, 999);
        
        const rows = document.querySelectorAll('tbody tr');
        
        rows.forEach(row => {
          const htmlRow = row as HTMLElement;
          const dateCell = htmlRow.querySelector('td:nth-child(3)'); // Updated to match new column structure
          const dateInput = dateCell?.querySelector('.date-input') as HTMLInputElement;
          const dateText = dateInput?.value || '';
          const entryDate = new Date(dateText);
          
          
          // Check if entry is within the current week (Sunday-Saturday)
          const isInWeek = entryDate >= currentWeekStart && entryDate <= weekEnd;
          
          // Only hide if not already hidden by other filters
          if (!isInWeek && htmlRow.style.display !== 'none') {
            htmlRow.style.display = 'none';
          } else if (isInWeek && htmlRow.style.display === 'none') {
            // Check if it should be visible based on other filters
            const shouldShow = checkOtherFilters(htmlRow);
            htmlRow.style.display = shouldShow ? '' : 'none';
          }
        });
        
        updateResultsCounter();
      }

      // Check if row should be visible based on other filters
      function checkOtherFilters(row: HTMLElement) {
        const searchTerm = (document.getElementById('search') as HTMLInputElement)?.value?.toLowerCase() || '';
        const selectedClient = (document.getElementById('clientFilter') as HTMLSelectElement)?.value || '';
        
        const rowText = row.textContent?.toLowerCase() || '';
        const clientCell = row.querySelector('td:nth-child(1)');
        const clientName = clientCell?.textContent?.trim() || '';
        
        const matchesSearch = !searchTerm || rowText.includes(searchTerm);
        const matchesClient = !selectedClient || clientName === selectedClient;
        
        return matchesSearch && matchesClient;
      }

      // Previous week button
      document.getElementById('prevWeekBtn')?.addEventListener('click', () => {
        currentWeekStart.setDate(currentWeekStart.getDate() - 7);
        updateWeekDisplay();
      });

      // Next week button
      document.getElementById('nextWeekBtn')?.addEventListener('click', () => {
        currentWeekStart.setDate(currentWeekStart.getDate() + 7);
        updateWeekDisplay();
      });

      // Initialize week display
      updateWeekDisplay();


      // Time input handling
      const timeInputs = document.querySelectorAll('.time-input');
      
      timeInputs.forEach(input => {
        // Store the original value when the input is focused
        input.addEventListener('focus', function(this: HTMLInputElement) {
          this.setAttribute('data-original-value', this.value);
        });
        
        // Handle Enter key press
        input.addEventListener('keydown', function(this: HTMLInputElement, e: Event) {
          const keyEvent = e as KeyboardEvent;
          if (keyEvent.key === 'Enter') {
            keyEvent.preventDefault();
            this.blur(); // Trigger the blur event to save
          }
        });
        
        input.addEventListener('blur', async function(this: HTMLInputElement) {
          const entryId = this.getAttribute('data-entry-id');
          const timeType = this.getAttribute('data-time-type');
          const timeValue = this.value.trim();
          
          // Skip if empty or if it's the placeholder value
          if (!timeValue || timeValue === '--:-- --') return;
          
          // Skip if the value hasn't changed
          const originalValue = this.getAttribute('data-original-value');
          if (timeValue === originalValue) return;
          
          // Parse time using flexible parser
          const parsedTime = parseFlexibleTime(timeValue);
          if (!parsedTime) {
            // Show error state
            this.style.borderColor = '#EF4444';
            this.style.backgroundColor = '#FEF2F2';
            alert('Please enter a valid time format (e.g., 3p, 3:30pm, 12am, 300pm, etc.)');
            setTimeout(() => {
              this.style.borderColor = '';
              this.style.backgroundColor = '';
            }, 2000);
            this.focus();
            return;
          }
          
          try {
            // Get the current entry data to determine if this is a manual duration entry
            const row = this.closest('tr') as HTMLElement | null;
            const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement;
            const entryData = editBtn?.getAttribute('data-entry');
            let currentEntry = null;
            
            if (entryData) {
              try {
                currentEntry = JSON.parse(entryData);
              } catch (e) {
                console.error('Error parsing entry data:', e);
              }
            }
            
            // Get the task date from the current entry
            // For manual duration entries, use createdAt; for timer entries, use startTime
            const isManualDurationEntry = currentEntry?.durationManual && !currentEntry?.endTime;
            const taskDate = (!isManualDurationEntry && currentEntry?.startTime) ? 
              new Date(currentEntry.startTime) : 
              new Date(currentEntry?.createdAt);
            
            // Use the parsed time (already in 24-hour format)
            const hours = parsedTime.hours;
            const minutes = parsedTime.minutes;
            
            // Create new datetime using local date construction
            const newDateTime = new Date(
              taskDate.getFullYear(), 
              taskDate.getMonth(), 
              taskDate.getDate(), 
              hours, 
              minutes, 
              0, 
              0
            );
            
            // Build update data with both times (following TIME_EDITING_GUIDE pattern)
            const updateData: { startTime?: string; endTime?: string; durationManual?: number | null } = {};
            if (timeType === 'start') {
              updateData.startTime = newDateTime.toISOString();
              // Include current end time from input
              const endInput = row?.querySelector('input[data-time-type="end"]') as HTMLInputElement | null;
              if (endInput?.value && endInput.value !== '--:-- --') {
                const endParsed = parseFlexibleTime(endInput.value);
                if (endParsed) {
                  const endDateTime = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate(), endParsed.hours, endParsed.minutes, 0, 0);
                  updateData.endTime = endDateTime.toISOString();
                } else if (currentEntry?.endTime) {
                  updateData.endTime = new Date(currentEntry.endTime).toISOString();
                }
              } else if (currentEntry?.endTime) {
                updateData.endTime = new Date(currentEntry.endTime).toISOString();
              }
            } else if (timeType === 'end') {
              updateData.endTime = newDateTime.toISOString();
              // Include current start time from input
              const startInput = row?.querySelector('input[data-time-type="start"]') as HTMLInputElement | null;
              if (startInput?.value && startInput.value !== '--:-- --') {
                const startParsed = parseFlexibleTime(startInput.value);
                if (startParsed) {
                  const startDateTime = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate(), startParsed.hours, startParsed.minutes, 0, 0);
                  updateData.startTime = startDateTime.toISOString();
                } else if (currentEntry?.startTime) {
                  updateData.startTime = new Date(currentEntry.startTime).toISOString();
                }
              } else if (currentEntry?.startTime) {
                updateData.startTime = new Date(currentEntry.startTime).toISOString();
              }
            }
            
            // If this was a manual duration entry and we're adding times, clear the manual duration
            if (currentEntry?.durationManual && !currentEntry?.endTime) {
              updateData.durationManual = null;
            }
            
            
            // Show loading state
            this.style.borderColor = '#3B82F6';
            this.style.backgroundColor = '#F0F9FF';
            
            const response = await fetch(`/api/time-entries-unified/${entryId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(updateData)
            });
            
            if (response.ok) {
              const result = await response.json();
              const row = this.closest('tr') as HTMLElement;
              
              // Update the duration cell using data attribute selector
              const durationCell = row?.querySelector('td[data-role="duration"]');
              if (durationCell && result.data) {
                const duration = result.data.durationManual || result.data.duration || 0;
                const durationInput = durationCell.querySelector('.duration-input') as HTMLInputElement;
                if (durationInput) {
                  const hours = Math.floor(duration / 3600);
                  const minutes = Math.floor((duration % 3600) / 60);
                  durationInput.value = `${hours}h ${minutes}m`;
                }
              }
              
              // Update the time input values to reflect the new data
              if (result.data) {
                const startTimeInput = row?.querySelector('input[data-time-type="start"]') as HTMLInputElement;
                const endTimeInput = row?.querySelector('input[data-time-type="end"]') as HTMLInputElement;
                
                if (startTimeInput && result.data.startTime) {
                  const startDate = new Date(result.data.startTime);
                  startTimeInput.value = formatTimeForUser(startDate);
                  // Re-enable start time input since we now have a start time
                  startTimeInput.readOnly = false;
                  startTimeInput.classList.remove('bg-gray-100', 'cursor-not-allowed');
                  startTimeInput.title = 'Click to edit start time';
                } else if (startTimeInput && !result.data.startTime) {
                  startTimeInput.value = '--:-- --';
                }
                
                if (endTimeInput && result.data.endTime) {
                  const endDate = new Date(result.data.endTime);
                  endTimeInput.value = formatTimeForUser(endDate);
                  // Re-enable end time input since we now have an end time
                  endTimeInput.readOnly = false;
                  endTimeInput.classList.remove('bg-gray-100', 'cursor-not-allowed');
                  endTimeInput.title = 'Click to edit end time';
                } else if (endTimeInput && !result.data.endTime) {
                  endTimeInput.value = '--:-- --';
                }
              }
              
              // Re-sort the table after time changes
              sortTableByDate('desc');
              
              // Show success feedback
              this.style.borderColor = '#10B981';
              this.style.backgroundColor = '#F0FDF4';
              setTimeout(() => {
                this.style.borderColor = '';
                this.style.backgroundColor = '';
              }, 1500);
            } else {
              const error = await response.json();
              
              if (response.status === 401) {
                // Authentication error - redirect to login
                alert('Your session has expired. Please log in again.');
                window.location.href = '/login';
                return;
              }
              
              // Show error state
              this.style.borderColor = '#EF4444';
              this.style.backgroundColor = '#FEF2F2';
              alert(`Error: ${error.error}`);
              setTimeout(() => {
                this.style.borderColor = '';
                this.style.backgroundColor = '';
              }, 2000);
              // Reset to original value on error
              this.focus();
            }
          } catch (error) {
            console.error('Error updating time:', error);
            // Reset styling on error
            this.style.borderColor = '';
            this.style.backgroundColor = '';
            console.error('Error updating time. Please check your input and try again.');
            this.focus();
          }
        });
        
        // Handle Enter key
        input.addEventListener('keydown', (e: Event) => {
          const keyEvent = e as KeyboardEvent;
          if (keyEvent.key === 'Enter') {
            (e.target as HTMLInputElement).blur();
          }
        });
      });

      // Function to handle duration input changes
      function handleDurationInputChange() {
        const durationInputs = document.querySelectorAll('.duration-input');
        
        durationInputs.forEach((input: Element) => {
          const durationInput = input as HTMLInputElement;
          
          // Skip if already has event listeners attached
          if (durationInput.hasAttribute('data-listeners-attached')) {
            return;
          }
          
          // Store the original value when the input is focused
          durationInput.addEventListener('focus', function(this: HTMLInputElement) {
            this.setAttribute('data-original-value', this.value);
          });
          
          // Handle Enter key press
          durationInput.addEventListener('keydown', function(e: KeyboardEvent) {
          if (e.key === 'Enter') {
              e.preventDefault();
              (this as HTMLInputElement).blur(); // Trigger the blur event to save
            }
          });
          
          durationInput.addEventListener('blur', async function(this: HTMLInputElement) {
            const entryId = this.getAttribute('data-entry-id');
            const durationValue = this.value.trim();
            
            // Skip if empty or if it's the placeholder value
            if (!durationValue) return;
            
            // Skip if the value hasn't changed
            const originalValue = this.getAttribute('data-original-value');
            if (durationValue === originalValue) return;
            
            // Parse duration using flexible parser
            const parsedDuration = parseFlexibleDuration(durationValue);
            if (!parsedDuration) {
              // Show error state
              this.style.borderColor = '#EF4444';
              this.style.backgroundColor = '#FEF2F2';
              alert('Please enter a valid duration format (e.g., 2h 30m, 2.5h, 150m, 2:30)');
              setTimeout(() => {
                this.style.borderColor = '';
                this.style.backgroundColor = '';
              }, 2000);
              this.focus();
              return;
            }
            
            try {
              // Show loading state
              this.style.borderColor = '#3B82F6';
              this.style.backgroundColor = '#F0F9FF';
              
              const response = await fetch(`/api/time-entries-unified/${entryId}`, {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  durationManual: parsedDuration
                })
              });
              
              if (response.ok) {
                const result = await response.json();
                const row = this.closest('tr');
                
                // Clear and disable start/stop time fields since we're now using manual duration
                const startTimeInput = row?.querySelector('input[data-time-type="start"]') as HTMLInputElement;
                const endTimeInput = row?.querySelector('input[data-time-type="end"]') as HTMLInputElement;
                
                if (startTimeInput) {
                  startTimeInput.value = '--:-- --';
                  startTimeInput.readOnly = true;
                  startTimeInput.classList.add('bg-gray-100', 'cursor-not-allowed');
                  startTimeInput.title = 'Manual duration entry - use edit button to modify';
                }
                
                if (endTimeInput) {
                  endTimeInput.value = '--:-- --';
                  endTimeInput.readOnly = true;
                  endTimeInput.classList.add('bg-gray-100', 'cursor-not-allowed');
                  endTimeInput.title = 'Manual duration entry - use edit button to modify';
                }
                
                // Update the edit button's data-entry payload so subsequent edits use fresh values
                const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement | null;
                if (editBtn && result.data) {
                  editBtn.setAttribute('data-entry', JSON.stringify(result.data));
                }
                
                // Re-sort the table after duration changes
                sortTableByDate('desc');
                
                // Show success feedback
                this.style.borderColor = '#10B981';
                this.style.backgroundColor = '#F0FDF4';
                setTimeout(() => {
                  this.style.borderColor = '';
                  this.style.backgroundColor = '';
                }, 1500);
              } else {
                const error = await response.json();
                
                if (response.status === 401) {
                  // Authentication error - redirect to login
                  alert('Your session has expired. Please log in again.');
                  window.location.href = '/login';
                  return;
                }
                
                // Show error state
                this.style.borderColor = '#EF4444';
                this.style.backgroundColor = '#FEF2F2';
                alert(`Error: ${error.error}`);
                setTimeout(() => {
                  this.style.borderColor = '';
                  this.style.backgroundColor = '';
                }, 2000);
                this.focus();
              }
            } catch (error) {
              console.error('Error updating duration:', error);
              // Reset styling on error
              this.style.borderColor = '';
              this.style.backgroundColor = '';
              alert('Error updating duration. Please check your input and try again.');
              this.focus();
            }
          });
          
          // Mark as having listeners attached
          durationInput.setAttribute('data-listeners-attached', 'true');
        });
      }

      // Function to handle notes input changes
      function handleNotesInputChange() {
        const notesInputs = document.querySelectorAll('.notes-input');
        
        notesInputs.forEach((input: Element) => {
          const notesInput = input as HTMLInputElement;
          
          // Skip if already has event listeners attached
          if (notesInput.hasAttribute('data-listeners-attached')) {
            return;
          }
          
          // Store the original value when the input is focused
          notesInput.addEventListener('focus', function(this: HTMLInputElement) {
            this.setAttribute('data-original-value', this.value);
          });
          
          // Handle Enter key press
          notesInput.addEventListener('keydown', function(e: KeyboardEvent) {
            if (e.key === 'Enter') {
              e.preventDefault();
              (this as HTMLInputElement).blur(); // Trigger the blur event to save
            }
          });
          
          notesInput.addEventListener('blur', async function(this: HTMLInputElement) {
            const entryId = this.getAttribute('data-entry-id');
            const notesValue = this.value.trim();
            
            // Skip if the value hasn't changed
            const originalValue = this.getAttribute('data-original-value');
            if (notesValue === originalValue) return;
            
            try {
              // Show loading state
              this.style.borderColor = '#3B82F6';
              this.style.backgroundColor = '#F0F9FF';
              
              const response = await fetch(`/api/time-entries-unified/${entryId}`, {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  notes: notesValue || null
                })
              });
              
              if (response.ok) {
                const result = await response.json();
                const row = this.closest('tr');
                
                // Update the edit button's data-entry payload so subsequent edits use fresh values
                const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement | null;
                if (editBtn && result.data) {
                  editBtn.setAttribute('data-entry', JSON.stringify(result.data));
                }
                
                // Show success feedback
                this.style.borderColor = '#10B981';
                this.style.backgroundColor = '#F0FDF4';
                setTimeout(() => {
                  this.style.borderColor = '';
                  this.style.backgroundColor = '';
                }, 1500);
              } else {
                const error = await response.json();
                
                if (response.status === 401) {
                  // Authentication error - redirect to login
                  alert('Your session has expired. Please log in again.');
                  window.location.href = '/login';
                  return;
                }
                
                // Show error state
                this.style.borderColor = '#EF4444';
                this.style.backgroundColor = '#FEF2F2';
                alert(`Error: ${error.error}`);
                setTimeout(() => {
                  this.style.borderColor = '';
                  this.style.backgroundColor = '';
                }, 2000);
                this.focus();
              }
            } catch (error) {
              console.error('Error updating notes:', error);
              // Reset styling on error
              this.style.borderColor = '';
              this.style.backgroundColor = '';
              alert('Error updating notes. Please try again.');
              this.focus();
            }
          });
          
          // Mark as having listeners attached
          notesInput.setAttribute('data-listeners-attached', 'true');
        });
      }

      // Function to handle date input validation and changes
      function handleDateInputChange() {
        const dateInputs = document.querySelectorAll('.date-input');
        
        dateInputs.forEach((input: Element) => {
          const dateInput = input as HTMLInputElement;
          
          // Skip if already has event listeners attached
          if (dateInput.hasAttribute('data-listeners-attached')) {
            return;
          }
          
          // Format validation function
          function validateDateFormat(value: string): boolean {
            const mmddyyyyRegex = /^(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/\d{4}$/;
            return mmddyyyyRegex.test(value);
          }
          
          // Convert mm/dd/yyyy to yyyy-mm-dd for API
          function convertToISODate(dateStr: string): string {
            const [month, day, year] = dateStr.split('/');
            return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
          }
          
          // Convert yyyy-mm-dd to mm/dd/yyyy for display
          function convertToDisplayDate(isoDate: string): string {
            const [year, month, day] = isoDate.split('-');
            return `${month}/${day}/${year}`;
          }
          
          // Handle Enter key press
          dateInput.addEventListener('keydown', function(e: KeyboardEvent) {
            if (e.key === 'Enter') {
              e.preventDefault();
              (this as HTMLInputElement).blur(); // Trigger the blur event to save
            }
          });
          
          // Handle input changes
          dateInput.addEventListener('blur', async function(this: HTMLInputElement) {
            const entryId = this.getAttribute('data-entry-id');
            const currentDate = this.getAttribute('data-current-date');
            const newValue = this.value.trim();
            
            if (!newValue) {
              // Reset to original if empty
              this.value = convertToDisplayDate(currentDate || '');
              return;
            }
            
            if (!validateDateFormat(newValue)) {
              // Show format error dialog
              alert('Please enter the date in mm/dd/yyyy format (e.g., 12/25/2023)');
              this.value = convertToDisplayDate(currentDate || '');
              this.focus();
              return;
            }
            
            const newISODate = convertToISODate(newValue);
            if (newISODate === currentDate) {
              // No change, just return
              return;
            }
            
            try {
              // Show loading state
              this.style.borderColor = '#3B82F6';
              this.style.backgroundColor = '#F0F9FF';
              
              // Parse the new date and get current times from the entry
              const [year, month, day] = newISODate.split('-').map(Number);
              const newDateObj = new Date(year, month - 1, day, 0, 0, 0, 0);
              
              // Get current entry data to preserve times
              const row = dateInput.closest('tr');
              const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement;
              const entryData = editBtn?.getAttribute('data-entry');
              let currentEntry = null;
              
              if (entryData) {
                try {
                  currentEntry = JSON.parse(entryData);
                } catch (e) {
                  console.error('Error parsing entry data:', e);
                }
              }
              
              const updateData: any = {
                taskDate: newISODate
              };
              
              if (currentEntry?.startTime) {
                const startTime = new Date(currentEntry.startTime);
                const newStartTime = new Date(year, month - 1, day, startTime.getHours(), startTime.getMinutes(), 0, 0);
                updateData.startTime = newStartTime.toISOString();
              }
              
              if (currentEntry?.endTime) {
                const endTime = new Date(currentEntry.endTime);
                const newEndTime = new Date(year, month - 1, day, endTime.getHours(), endTime.getMinutes(), 0, 0);
                updateData.endTime = newEndTime.toISOString();
              }
              
              const response = await fetch(`/api/time-entries-unified/${entryId}`, {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(updateData)
              });
              
              if (response.ok) {
                const result = await response.json();
                
                // Update the edit button's data-entry payload so subsequent edits use fresh values
                if (editBtn && result.data) {
                  editBtn.setAttribute('data-entry', JSON.stringify(result.data));
                }
                
                // Update the data-current-date attribute
                this.setAttribute('data-current-date', newISODate);
                
                // Re-filter entries by week and re-sort the table
                filterEntriesByWeek();
                sortTableByDate('desc');
                
                // Show success feedback
                this.style.backgroundColor = '#D1FAE5';
                this.style.borderColor = '#10B981';
                setTimeout(() => {
                  this.style.backgroundColor = '';
                  this.style.borderColor = '';
                }, 1500);
              } else {
                console.error('Failed to update date, status:', response.status);
                // Revert the input value
                this.value = convertToDisplayDate(currentDate || '');
                this.setAttribute('data-current-date', currentDate || '');
              }
            } catch (error) {
              console.error('Error updating date:', error);
              // Revert the input value
              this.value = convertToDisplayDate(currentDate || '');
              this.setAttribute('data-current-date', currentDate || '');
            }
          });
          
          // Mark as having listeners attached
          dateInput.setAttribute('data-listeners-attached', 'true');
        });
      }

      // Function to initialize Flatpickr date pickers
      function initializeFlatpickr() {
        const dateInputs = document.querySelectorAll('.date-input');
        
        dateInputs.forEach((input: Element) => {
          const dateInput = input as HTMLInputElement;
          const entryId = dateInput.getAttribute('data-entry-id');
          const currentDate = dateInput.getAttribute('data-current-date');
          
          if (!dateInput || dateInput.hasAttribute('data-flatpickr-initialized')) {
            return;
          }
          
          // Initialize Flatpickr
          console.log('üîß Initializing Flatpickr for entry:', entryId, 'currentDate:', currentDate);
          const flatpickrInstance = flatpickr(dateInput, {
            dateFormat: 'm/d/Y',
            defaultDate: currentDate ? new Date(currentDate + 'T00:00:00') : new Date(),
            allowInput: true,
            clickOpens: true,
            static: true,
            monthSelectorType: 'static',
            onChange: function(selectedDates: any, dateStr: any, instance: any) {
              console.log('üîß Flatpickr onChange triggered:', { selectedDates, dateStr, entryId });
              if (selectedDates.length > 0) {
                const selectedDate = selectedDates[0];
                const isoDate = selectedDate.toISOString().split('T')[0];
                console.log('üîß Calling saveDateChange with:', { isoDate, entryId });
                saveDateChange(dateInput, entryId || '', isoDate);
              }
            }
          });
          
          // Mark as initialized
          dateInput.setAttribute('data-flatpickr-initialized', 'true');
        });
      }

      // Function to save date changes from Flatpickr
      async function saveDateChange(dateInput: HTMLInputElement, entryId: string, newISODate: string) {
        console.log('üîß saveDateChange called with:', { entryId, newISODate });
        try {
          // Get the current entry data
          const row = dateInput.closest('tr');
          const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement;
          const entryData = editBtn?.getAttribute('data-entry');
          let currentEntry = null;
          
          if (entryData) {
            try {
              currentEntry = JSON.parse(entryData);
            } catch (e) {
              console.error('Error parsing entry data:', e);
            }
          }
          
          if (!currentEntry) {
            console.error('Could not find entry data for date change');
            return;
          }
          
          // Parse the new date
          const [year, month, day] = newISODate.split('-').map(Number);
          
          const updateData: any = {
            taskDate: newISODate
          };
          
          // Check if this is a manual duration entry (has durationManual but no startTime/endTime)
          const isManualDurationEntry = currentEntry.durationManual && !currentEntry.startTime && !currentEntry.endTime;
          
          console.log('üîç Date change debug (time-entries):', {
            entryId,
            currentEntry: {
              durationManual: currentEntry.durationManual,
              startTime: currentEntry.startTime,
              endTime: currentEntry.endTime,
              createdAt: currentEntry.createdAt
            },
            isManualDurationEntry,
            newISODate,
            updateData
          });
          
          console.log('üîç Full currentEntry object (time-entries):', currentEntry);
          
          if (isManualDurationEntry) {
            // For manual duration entries, update createdAt to the new date
            const newCreatedAt = new Date(year, month - 1, day, 12, 0, 0, 0); // Use noon to avoid timezone issues
            updateData.createdAt = newCreatedAt.toISOString();
            console.log('üìù Updating manual duration entry createdAt:', updateData.createdAt);
          } else {
            // For timer-based entries, update startTime and endTime
            if (currentEntry.startTime) {
              const startTime = new Date(currentEntry.startTime);
              const newStartTime = new Date(year, month - 1, day, startTime.getHours(), startTime.getMinutes(), 0, 0);
              updateData.startTime = newStartTime.toISOString();
            }
            
            if (currentEntry.endTime) {
              const endTime = new Date(currentEntry.endTime);
              const newEndTime = new Date(year, month - 1, day, endTime.getHours(), endTime.getMinutes(), 0, 0);
              updateData.endTime = newEndTime.toISOString();
            }
          }
          
          console.log('üîß Making API call to update entry:', { entryId, updateData });
          console.log('üîß Full updateData object:', JSON.stringify(updateData, null, 2));
          const response = await fetch(`/api/time-entries-unified/${entryId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(updateData)
          });
          
          console.log('üîß API response status:', response.status);
          if (response.ok) {
            const result = await response.json();
            
            // Update the edit button's data-entry payload so subsequent edits use fresh values
            if (editBtn && result.data) {
              editBtn.setAttribute('data-entry', JSON.stringify(result.data));
            }
            
            // Update the data-current-date attribute
            dateInput.setAttribute('data-current-date', newISODate);
            
            // Re-filter entries by week and re-sort the table
            filterEntriesByWeek();
            sortTableByDate('desc');
            
            // Show success feedback
            dateInput.style.backgroundColor = '#d4edda';
            dateInput.style.borderColor = '#28a745';
            setTimeout(() => {
              dateInput.style.backgroundColor = '';
              dateInput.style.borderColor = '';
            }, 1500);
          } else {
            const errorData = await response.json();
            console.error('üîß Failed to update date, status:', response.status, 'error:', errorData);
            // Revert the input value
            const originalDate = dateInput.getAttribute('data-current-date');
            if (originalDate) {
              const [origYear, origMonth, origDay] = originalDate.split('-').map(Number);
              dateInput.value = `${String(origMonth).padStart(2, '0')}/${String(origDay).padStart(2, '0')}/${origYear}`;
              dateInput.setAttribute('data-current-date', originalDate);
            }
          }
        } catch (error) {
          console.error('Error updating date:', error);
          // Revert the input value
          const originalDate = dateInput.getAttribute('data-current-date');
          if (originalDate) {
            const [origYear, origMonth, origDay] = originalDate.split('-').map(Number);
            dateInput.value = `${String(origMonth).padStart(2, '0')}/${String(origDay).padStart(2, '0')}/${origYear}`;
            dateInput.setAttribute('data-current-date', originalDate);
          }
        }
      }

      // Initialize all input handlers
      handleDurationInputChange();
      handleNotesInputChange();
      handleDateInputChange();
      initializeFlatpickr();

      // MutationObserver to handle dynamic content updates
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'childList') {
            // Check if time inputs were added
            const timeInputs = document.querySelectorAll('.time-input');
            if (timeInputs.length > 0) {
              console.log('MutationObserver: Re-attaching time input handlers');
              // Re-attach time input handlers for new elements
              timeInputs.forEach((input: Element) => {
                const timeInput = input as HTMLInputElement;
                if (!timeInput.hasAttribute('data-listeners-attached')) {
                  // Store the original value when the input is focused
                  timeInput.addEventListener('focus', function(this: HTMLInputElement) {
                    this.setAttribute('data-original-value', this.value);
                  });
                  
                  // Handle Enter key press
                  timeInput.addEventListener('keydown', function(e: KeyboardEvent) {
                    if (e.key === 'Enter') {
                      e.preventDefault();
                      (this as HTMLInputElement).blur(); // Trigger the blur event to save
                    }
                  });
                  
                  timeInput.addEventListener('blur', async function(this: HTMLInputElement) {
                    const entryId = this.getAttribute('data-entry-id');
                    const timeType = this.getAttribute('data-time-type');
                    const timeValue = this.value.trim();
                    
                    // Skip if empty or if it's the placeholder value
                    if (!timeValue || timeValue === '--:-- --') return;
                    
                    // Skip if the value hasn't changed
                    const originalValue = this.getAttribute('data-original-value');
                    if (timeValue === originalValue) return;
                    
                    // Parse time using flexible parser
                    const parsedTime = parseFlexibleTime(timeValue);
                    if (!parsedTime) {
                      // Show error state
                      this.style.borderColor = '#EF4444';
                      this.style.backgroundColor = '#FEF2F2';
                      alert('Please enter a valid time format (e.g., 3p, 3:30pm, 12am, 300pm, etc.)');
                      setTimeout(() => {
                        this.style.borderColor = '';
                        this.style.backgroundColor = '';
                      }, 2000);
                      this.focus();
                      return;
                    }
                    
                    try {
                      // Get the current entry data to determine if this is a manual duration entry
                      const row = this.closest('tr') as HTMLElement | null;
                      const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement;
                      const entryData = editBtn?.getAttribute('data-entry');
                      let currentEntry = null;
                      
                      if (entryData) {
                        try {
                          currentEntry = JSON.parse(entryData);
                        } catch (e) {
                          console.error('Error parsing entry data:', e);
                        }
                      }
                      
                      // Get the task date from the current entry
                      // For manual duration entries, use createdAt; for timer entries, use startTime
                      const isManualDurationEntry = currentEntry?.durationManual && !currentEntry?.endTime;
                      const taskDate = (!isManualDurationEntry && currentEntry?.startTime) ? 
                        new Date(currentEntry.startTime) : 
                        new Date(currentEntry?.createdAt);
                      
                      // Use the parsed time (already in 24-hour format)
                      const hours = parsedTime.hours;
                      const minutes = parsedTime.minutes;
                      
                      // Create new datetime using local date construction
                      const newDateTime = new Date(
                        taskDate.getFullYear(), 
                        taskDate.getMonth(), 
                        taskDate.getDate(), 
                        hours, 
                        minutes, 
                        0, 
                        0
                      );
                      
                      // Build update data with both times (following TIME_EDITING_GUIDE pattern)
                      const updateData: { startTime?: string; endTime?: string; durationManual?: number | null } = {};
                      if (timeType === 'start') {
                        updateData.startTime = newDateTime.toISOString();
                        // Include current end time from input
                        const endInput = row?.querySelector('input[data-time-type="end"]') as HTMLInputElement | null;
                        if (endInput?.value && endInput.value !== '--:-- --') {
                          const endParsed = parseFlexibleTime(endInput.value);
                          if (endParsed) {
                            const endDateTime = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate(), endParsed.hours, endParsed.minutes, 0, 0);
                            updateData.endTime = endDateTime.toISOString();
                          } else if (currentEntry?.endTime) {
                            updateData.endTime = new Date(currentEntry.endTime).toISOString();
                          }
                        } else if (currentEntry?.endTime) {
                          updateData.endTime = new Date(currentEntry.endTime).toISOString();
                        }
                      } else if (timeType === 'end') {
                        updateData.endTime = newDateTime.toISOString();
                        // Include current start time from input
                        const startInput = row?.querySelector('input[data-time-type="start"]') as HTMLInputElement | null;
                        if (startInput?.value && startInput.value !== '--:-- --') {
                          const startParsed = parseFlexibleTime(startInput.value);
                          if (startParsed) {
                            const startDateTime = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate(), startParsed.hours, startParsed.minutes, 0, 0);
                            updateData.startTime = startDateTime.toISOString();
                          } else if (currentEntry?.startTime) {
                            updateData.startTime = new Date(currentEntry.startTime).toISOString();
                          }
                        } else if (currentEntry?.startTime) {
                          updateData.startTime = new Date(currentEntry.startTime).toISOString();
                        }
                      }
                      
                      // If this was a manual duration entry and we're adding times, clear the manual duration
                      if (currentEntry?.durationManual && !currentEntry?.endTime) {
                        updateData.durationManual = null;
                      }
                      
                      
                      // Show loading state
                      this.style.borderColor = '#3B82F6';
                      this.style.backgroundColor = '#F0F9FF';
                      
                      const response = await fetch(`/api/time-entries-unified/${entryId}`, {
                        method: 'PUT',
                        headers: {
                          'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(updateData)
                      });
                      
                      if (response.ok) {
                        const result = await response.json();
                        const row = this.closest('tr') as HTMLElement | null;
                        
                        // Update the duration cell using data attribute selector
                        const durationCell = row?.querySelector('td[data-role="duration"]');
                        if (durationCell && result.data) {
                          const duration = result.data.durationManual || result.data.duration || 0;
                          const durationInput = durationCell.querySelector('.duration-input') as HTMLInputElement;
                          if (durationInput) {
                            const hours = Math.floor(duration / 3600);
                            const minutes = Math.floor((duration % 3600) / 60);
                            durationInput.value = `${hours}h ${minutes}m`;
                          }
                        }
                        
                        // Update the time input values to reflect the new data
                        if (result.data && row) {
                          const startTimeInput = row.querySelector('input[data-time-type="start"]') as HTMLInputElement;
                          const endTimeInput = row.querySelector('input[data-time-type="end"]') as HTMLInputElement;
                          
                          if (startTimeInput && result.data.startTime) {
                            const startDate = new Date(result.data.startTime);
                            startTimeInput.value = formatTimeForUser(startDate);
                            // Re-enable start time input since we now have a start time
                            startTimeInput.readOnly = false;
                            startTimeInput.classList.remove('bg-gray-100', 'cursor-not-allowed');
                            startTimeInput.title = 'Click to edit start time';
                          } else if (startTimeInput && !result.data.startTime) {
                            startTimeInput.value = '--:-- --';
                          }
                          
                          if (endTimeInput && result.data.endTime) {
                            const endDate = new Date(result.data.endTime);
                            endTimeInput.value = formatTimeForUser(endDate);
                            // Re-enable end time input since we now have an end time
                            endTimeInput.readOnly = false;
                            endTimeInput.classList.remove('bg-gray-100', 'cursor-not-allowed');
                            endTimeInput.title = 'Click to edit end time';
                          } else if (endTimeInput && !result.data.endTime) {
                            endTimeInput.value = '--:-- --';
                          }
                        }
                        
                        // Update the edit button's data-entry payload so subsequent edits use fresh values
                        if (editBtn && result.data) {
                          editBtn.setAttribute('data-entry', JSON.stringify(result.data));
                        }
                        
                        // Show success feedback
                        this.style.borderColor = '#10B981';
                        this.style.backgroundColor = '#F0FDF4';
                        setTimeout(() => {
                          this.style.borderColor = '';
                          this.style.backgroundColor = '';
                        }, 1500);
                      } else {
                        const error = await response.json();
                        
                        if (response.status === 401) {
                          // Authentication error - redirect to login
                          alert('Your session has expired. Please log in again.');
                          window.location.href = '/login';
                          return;
                        }
                        
                        // Show error state
                        this.style.borderColor = '#EF4444';
                        this.style.backgroundColor = '#FEF2F2';
                        alert(`Error: ${error.error}`);
                        setTimeout(() => {
                          this.style.borderColor = '';
                          this.style.backgroundColor = '';
                        }, 2000);
                        // Reset to original value on error
                        this.focus();
                      }
                    } catch (error) {
                      console.error('Error updating time:', error);
                      // Reset styling on error
                      this.style.borderColor = '';
                      this.style.backgroundColor = '';
                      console.error('Error updating time. Please check your input and try again.');
                      this.focus();
                    }
                  });
                  
                  // Handle Enter key
                  timeInput.addEventListener('keydown', function(e: KeyboardEvent) {
                    if (e.key === 'Enter') {
                      (e.target as HTMLInputElement).blur();
                    }
                  });
                  
                  // Mark as having listeners attached
                  timeInput.setAttribute('data-listeners-attached', 'true');
                }
              });
            }
            
            // Check if duration inputs were added
            const durationInputs = document.querySelectorAll('.duration-input');
            if (durationInputs.length > 0) {
              console.log('MutationObserver: Re-attaching duration input handlers');
              handleDurationInputChange();
            }
            
            // Check if notes inputs were added
            const notesInputs = document.querySelectorAll('.notes-input');
            if (notesInputs.length > 0) {
              console.log('MutationObserver: Re-attaching notes input handlers');
              handleNotesInputChange();
            }
            
            // Check if date inputs were added
            const dateInputs = document.querySelectorAll('.date-input');
            if (dateInputs.length > 0) {
              console.log('MutationObserver: Re-attaching date input handlers');
              handleDateInputChange();
              initializeFlatpickr();
            }
          }
        });
      });

      // Start observing the table for changes
      const tableContainer = document.querySelector('tbody');
      if (tableContainer) {
        observer.observe(tableContainer, {
          childList: true,
          subtree: true
        });
      }

      // Helper functions for filters
      function checkSearchFilter(row: HTMLElement): boolean {
        const searchInput = document.getElementById('search') as HTMLInputElement;
        const searchTerm = searchInput?.value?.toLowerCase() || '';
        const text = row.textContent?.toLowerCase() || '';
        return !searchTerm || text.includes(searchTerm);
      }

      function checkWeekFilter(row: HTMLElement): boolean {
        const dateCell = row.querySelector('td:nth-child(3)'); // Updated to match new column structure
        const dateInput = dateCell?.querySelector('.date-input') as HTMLInputElement;
        const dateText = dateInput?.value || '';
        const entryDate = new Date(dateText);
        
        const weekEnd = new Date(currentWeekStart);
        weekEnd.setDate(currentWeekStart.getDate() + 6);
        weekEnd.setHours(23, 59, 59, 999);
        
        // Check if entry is within the current week (Sunday-Saturday)
        return entryDate >= currentWeekStart && entryDate <= weekEnd;
      }

      function checkClientFilter(row: HTMLElement): boolean {
        const clientFilter = document.getElementById('clientFilter') as HTMLSelectElement;
        const selectedClient = clientFilter?.value || '';
        const clientName = row.querySelector('td:nth-child(1)')?.textContent?.trim() || '';
        return !selectedClient || clientName === selectedClient;
      }


      // Search functionality
      const searchInput = document.getElementById('search');
      const clientFilter = document.getElementById('clientFilter');

      if (searchInput) {
        searchInput.addEventListener('input', (e) => {
          const target = e.target as HTMLInputElement;
          const searchTerm = target.value.toLowerCase();
          const rows = document.querySelectorAll('tbody tr');
          
          rows.forEach(row => {
            const text = row.textContent?.toLowerCase() || '';
            const matchesSearch = text.includes(searchTerm);
            const matchesWeek = checkWeekFilter(row as HTMLElement);
            const matchesClient = checkClientFilter(row as HTMLElement);
            
            (row as HTMLElement).style.display = (matchesSearch && matchesWeek && matchesClient) ? '' : 'none';
          });
          
          updateResultsCounter();
        });
      }

      // Client filter functionality
      if (clientFilter) {
        clientFilter.addEventListener('change', (e) => {
          const target = e.target as HTMLSelectElement;
          const selectedClient = target.value;
          const rows = document.querySelectorAll('tbody tr');
          
          rows.forEach(row => {
            const matchesSearch = checkSearchFilter(row as HTMLElement);
            const matchesWeek = checkWeekFilter(row as HTMLElement);
            const matchesClient = !selectedClient || row.querySelector('td:nth-child(1)')?.textContent?.trim() === selectedClient;
            
            (row as HTMLElement).style.display = (matchesSearch && matchesWeek && matchesClient) ? '' : 'none';
          });
          
          updateResultsCounter();
        });
      }

    });

    // Export CSV functionality
    document.getElementById('exportCsvBtn')?.addEventListener('click', () => {
      const rows = document.querySelectorAll('tbody tr:not([style*="display: none"])');
      let csv = 'Client,Project,Task,Date,Start,Stop,Duration,Notes\n';
      
      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        const rowData = Array.from(cells).map(cell => {
          // Handle input elements
          const input = cell.querySelector('input');
          if (input) {
            return `"${input.value.replace(/"/g, '""')}"`;
          }
          const text = cell.textContent?.trim() || '';
          return `"${text.replace(/"/g, '""')}"`;
        });
        csv += rowData.join(',') + '\n';
      });
      
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'my-time-entries.csv';
      a.click();
      window.URL.revokeObjectURL(url);
    });

    // Logout functionality
    async function performLogout() {
      try {
        const response = await fetch('/api/auth/logout', {
          method: 'POST',
        });
        
        if (response.ok) {
          window.location.href = '/';
        }
      } catch (error) {
        console.error('Logout error:', error);
      }
    }

    // Desktop logout (if it still exists)
    document.getElementById('logoutButton')?.addEventListener('click', performLogout);



    // Date sorting functionality
    const dateSortUp = document.getElementById('dateSortUp');
    const dateSortDown = document.getElementById('dateSortDown');
    let currentSortDirection: 'asc' | 'desc' | null = null; // null = no sort, 'desc' = newest first, 'asc' = oldest first
    
    if (dateSortUp) {
      dateSortUp.addEventListener('click', () => {
        currentSortDirection = 'desc';
        updateSortButtonStates();
        sortTableByDate('desc');
      });
    }
    
    if (dateSortDown) {
      dateSortDown.addEventListener('click', () => {
        currentSortDirection = 'asc';
        updateSortButtonStates();
        sortTableByDate('asc');
      });
    }
    
    function updateSortButtonStates() {
      if (dateSortUp && dateSortDown) {
        if (currentSortDirection === 'desc') {
          dateSortUp.classList.remove('text-gray-400');
          dateSortUp.classList.add('text-blue-600');
          dateSortDown.classList.remove('text-blue-600');
          dateSortDown.classList.add('text-gray-400');
        } else if (currentSortDirection === 'asc') {
          dateSortDown.classList.remove('text-gray-400');
          dateSortDown.classList.add('text-blue-600');
          dateSortUp.classList.remove('text-blue-600');
          dateSortUp.classList.add('text-gray-400');
        } else {
          dateSortUp.classList.remove('text-blue-600');
          dateSortUp.classList.add('text-gray-400');
          dateSortDown.classList.remove('text-blue-600');
          dateSortDown.classList.add('text-gray-400');
        }
      }
    }
    
    function sortTableByDate(direction: 'asc' | 'desc') {
      const tbody = document.querySelector('tbody') as HTMLElement;
      if (!tbody) return;
      
      const rows = Array.from(tbody.querySelectorAll('tr'));
      
      rows.sort((a, b) => {
        const dateCellA = a.querySelector('td:nth-child(3)') as HTMLElement; // Updated to match new column structure
        const dateCellB = b.querySelector('td:nth-child(3)') as HTMLElement; // Updated to match new column structure
        const dateInputA = dateCellA?.querySelector('.date-input') as HTMLInputElement;
        const dateInputB = dateCellB?.querySelector('.date-input') as HTMLInputElement;
        const dateTextA = dateInputA?.value || '';
        const dateTextB = dateInputB?.value || '';
        
        const dateA = new Date(dateTextA);
        const dateB = new Date(dateTextB);
        
        if (isNaN(dateA.getTime()) || isNaN(dateB.getTime())) {
          return 0;
        }
        
        if (direction === 'desc') {
          return dateB.getTime() - dateA.getTime();
        } else {
          return dateA.getTime() - dateB.getTime();
        }
      });
      
      rows.forEach(row => tbody.appendChild(row));
      updateResultsCounter();
    }

    function updateResultsCounter() {
      const visibleRows = document.querySelectorAll('tbody tr:not([style*="display: none"])');
      const resultsCounter = document.getElementById('resultsCounter');
      
      if (resultsCounter) {
        resultsCounter.textContent = `Showing ${visibleRows.length} time entries`;
      }
    }

    // Edit Time Entry Modal Functionality
    const editTimeEntryModal = document.getElementById('editTimeEntryModal');
    const editTimeEntryForm = document.getElementById('editTimeEntryForm');
    const cancelEditTimeEntryBtn = document.getElementById('cancelEditTimeEntryBtn');
    const deleteTimeEntryBtn = document.getElementById('deleteTimeEntryBtn');
    let currentEditingEntry: any = null; // Store the current entry being edited


    // Add event listeners for edit buttons (delegated event handling)
    document.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      const editBtn = target.closest('.edit-time-entry-btn') as HTMLElement;
      
      if (editBtn) {
        const entryId = editBtn.getAttribute('data-entry-id');
        const entryData = editBtn.getAttribute('data-entry');
        
        if (entryId && entryData) {
          try {
            const entry = JSON.parse(entryData);
            openEditTimeEntryModal(entry);
          } catch (error) {
            console.error('Error parsing entry data:', error);
          }
        }
      }
    });

    function openEditTimeEntryModal(entry: any) {
      if (!editTimeEntryModal) return;

      // Store the current entry being edited
      currentEditingEntry = entry;

      // Populate form fields
      const entryIdInput = document.getElementById('editTimeEntryId') as HTMLInputElement;
      const editTaskInput = document.getElementById('editTimeEntryTask') as HTMLInputElement;
      const editTaskIdInput = document.getElementById('editTimeEntryTaskId') as HTMLInputElement;
      const startTimeInput = document.getElementById('editStartTime') as HTMLInputElement;
      const endTimeInput = document.getElementById('editEndTime') as HTMLInputElement;
      const durationInput = document.getElementById('editDuration') as HTMLInputElement;
      const notesInput = document.getElementById('editNotes') as HTMLTextAreaElement;
      const editTimesDateInput = document.getElementById('editTimesDate') as HTMLInputElement;
      const editDurationDateInput = document.getElementById('editDurationDate') as HTMLInputElement;

      if (entryIdInput) entryIdInput.value = entry.id;
      if (notesInput) notesInput.value = entry.notes || '';

      // Populate task information
      if (editTaskInput && editTaskIdInput) {
        editTaskInput.value = `${entry.taskName} (${entry.projectName} - ${entry.clientName})`;
        editTaskIdInput.value = entry.taskId ? entry.taskId.toString() : '';
      }

      // Check if this is a manual duration entry (same logic as table rendering)
      const isManualDurationEntry = entry.durationManual && !entry.endTime;
      
      // Format time inputs (12-hour format) - only if times exist and it's not a manual duration entry
      if (startTimeInput) {
        if (entry.startTime && !isManualDurationEntry) {
          const startDate = new Date(entry.startTime);
          startTimeInput.value = formatTimeForUser(startDate);
        } else {
          startTimeInput.value = '';
        }
      }
      
      if (endTimeInput) {
        if (entry.endTime && !isManualDurationEntry) {
          const endDate = new Date(entry.endTime);
          endTimeInput.value = formatTimeForUser(endDate);
        } else {
          endTimeInput.value = '';
        }
      }

      // Set duration based on entry duration
      if (durationInput && entry.durationManual) {
        const hours = Math.floor(entry.durationManual / 3600);
        const minutes = Math.floor((entry.durationManual % 3600) / 60);
        durationInput.value = `${hours}h ${minutes}m`;
      }

      // Set date fields based on entry type
      if (entry.startTime) {
        const startDate = new Date(entry.startTime);
        const dateString = startDate.toISOString().split('T')[0];
        if (editTimesDateInput) {
          editTimesDateInput.value = dateString;
        }
      }

      if (entry.durationManual && entry.startTime) {
        const startDate = new Date(entry.startTime);
        const dateString = startDate.toISOString().split('T')[0];
        if (editDurationDateInput) {
          editDurationDateInput.value = dateString;
        }
      }

      // Determine which method to show based on entry type
      const timesSection = document.getElementById('timesSection');
      const durationSection = document.getElementById('durationSection');
      
      // If this is a manual duration entry, show duration method
      if (isManualDurationEntry) {
        const durationRadio = document.querySelector('input[name="editMethod"][value="duration"]') as HTMLInputElement;
        if (durationRadio) {
          durationRadio.checked = true;
        }
        timesSection?.classList.add('hidden');
        durationSection?.classList.remove('hidden');
      } else {
        // Default to "times" method (start/end times)
        const timesRadio = document.querySelector('input[name="editMethod"][value="times"]') as HTMLInputElement;
        if (timesRadio) {
          timesRadio.checked = true;
        }
        timesSection?.classList.remove('hidden');
        durationSection?.classList.add('hidden');
      }

      // Show modal
      editTimeEntryModal.classList.remove('hidden');
    }

    function closeEditTimeEntryModal() {
      if (editTimeEntryModal) {
        editTimeEntryModal.classList.add('hidden');
        currentEditingEntry = null; // Clear the stored entry
        if (editTimeEntryForm && editTimeEntryForm instanceof HTMLFormElement) {
          editTimeEntryForm.reset();
        }
        
        // Clear task fields
        const editTaskInput = document.getElementById('editTimeEntryTask') as HTMLInputElement;
        const editTaskIdInput = document.getElementById('editTimeEntryTaskId') as HTMLInputElement;
        if (editTaskInput) editTaskInput.value = '';
        if (editTaskIdInput) editTaskIdInput.value = '';
        
        // Hide task dropdown
        const editTaskDropdown = document.getElementById('editTaskDropdown');
        if (editTaskDropdown) {
          editTaskDropdown.classList.add('hidden');
        }
        
        // Reset radio button to default selection
        const timesRadio = document.querySelector('input[name="editMethod"][value="times"]') as HTMLInputElement;
        if (timesRadio) {
          timesRadio.checked = true;
        }
        
        // Ensure correct sections are shown
        const timesSection = document.getElementById('timesSection');
        const durationSection = document.getElementById('durationSection');
        timesSection?.classList.remove('hidden');
        durationSection?.classList.add('hidden');
      }
    }

    // Edit Task Search Functions
    let editTaskSearchTimeout: NodeJS.Timeout;
    let editTaskDropdownOpen = false;

    function handleEditTaskSearch(searchTerm: string) {
      clearTimeout(editTaskSearchTimeout);
      
      if (searchTerm.length < 1) {
        searchAllEditTasks();
        return;
      }
      
      editTaskSearchTimeout = setTimeout(() => {
        searchEditTasks(searchTerm);
      }, 300);
    }

    async function searchEditTasks(searchTerm: string) {
      try {
        const response = await fetch(`/api/tasks/search?q=${encodeURIComponent(searchTerm)}`);
        if (response.ok) {
          const tasks = await response.json();
          displayEditTaskDropdown(tasks);
        }
      } catch (error) {
        console.error('Error searching tasks:', error);
      }
    }

    async function searchAllEditTasks() {
      try {
        const response = await fetch('/api/tasks/search');
        if (response.ok) {
          const tasks = await response.json();
          displayEditTaskDropdown(tasks);
        }
      } catch (error) {
        console.error('Error fetching all tasks:', error);
      }
    }

    function showEditTaskDropdown() {
      const editTaskDropdown = document.getElementById('editTaskDropdown');
      if (editTaskDropdown) {
        editTaskDropdown.classList.remove('hidden');
        editTaskDropdownOpen = true;
        searchAllEditTasks();
      }
    }

    function hideEditTaskDropdown() {
      const editTaskDropdown = document.getElementById('editTaskDropdown');
      if (editTaskDropdown) {
        editTaskDropdown.classList.add('hidden');
        editTaskDropdownOpen = false;
      }
    }

    function toggleEditTaskDropdown() {
      if (editTaskDropdownOpen) {
        hideEditTaskDropdown();
      } else {
        showEditTaskDropdown();
      }
    }

    function displayEditTaskDropdown(tasks: any[]) {
      const editTaskDropdown = document.getElementById('editTaskDropdown');
      if (!editTaskDropdown) return;

      if (tasks.length === 0) {
        editTaskDropdown.innerHTML = '<div class="px-3 py-2 text-gray-500 text-sm">No tasks found</div>';
        editTaskDropdown.classList.remove('hidden');
        return;
      }

      // Group tasks by client for better organization
      const tasksByClient: { [key: string]: any[] } = {};
      tasks.forEach(task => {
        const clientName = task.clientName || 'Unknown Client';
        if (!tasksByClient[clientName]) {
          tasksByClient[clientName] = [];
        }
        tasksByClient[clientName].push(task);
      });

      let dropdownHTML = '';
      
      Object.keys(tasksByClient).forEach(clientName => {
        const clientTasks = tasksByClient[clientName];
        
        // Add client header
        dropdownHTML += `
          <div class="px-3 py-2 bg-gray-50 text-xs font-semibold text-gray-600 uppercase tracking-wide border-b border-gray-200">
            ${clientName}
          </div>
        `;
        
        // Add tasks for this client
        clientTasks.forEach(task => {
          dropdownHTML += `
            <div 
              class="px-3 py-2 hover:bg-gray-100 cursor-pointer text-sm pl-6 border-b border-gray-100 last:border-b-0"
              onclick="selectEditTask(${task.id}, '${task.name.replace(/'/g, "\\'")}', '${task.projectName.replace(/'/g, "\\'")}', '${task.clientName.replace(/'/g, "\\'")}')"
            >
              <div class="font-medium text-gray-900">${task.name}</div>
              <div class="text-xs text-gray-500">${task.projectName}</div>
            </div>
          `;
        });
      });

      editTaskDropdown.innerHTML = dropdownHTML;
      editTaskDropdown.classList.remove('hidden');
    }

    function selectEditTask(taskId: number, taskName: string, projectName: string, clientName: string) {
      const editTaskInput = document.getElementById('editTimeEntryTask') as HTMLInputElement;
      const editTaskIdInput = document.getElementById('editTimeEntryTaskId') as HTMLInputElement;
      
      if (editTaskInput && editTaskIdInput) {
        editTaskInput.value = `${taskName} (${projectName} - ${clientName})`;
        editTaskIdInput.value = taskId.toString();
        hideEditTaskDropdown();
      }
    }

    // Make edit task functions available globally for HTML event handlers
    (window as any).handleEditTaskSearch = handleEditTaskSearch;
    (window as any).toggleEditTaskDropdown = toggleEditTaskDropdown;
    (window as any).searchEditTasks = searchEditTasks;
    (window as any).searchAllEditTasks = searchAllEditTasks;
    (window as any).showEditTaskDropdown = showEditTaskDropdown;
    (window as any).hideEditTaskDropdown = hideEditTaskDropdown;
    (window as any).selectEditTask = selectEditTask;

    // Close edit modal when Cancel button is clicked
    if (cancelEditTimeEntryBtn) {
      cancelEditTimeEntryBtn.addEventListener('click', closeEditTimeEntryModal);
    }

    // Close edit modal when clicking outside
    document.addEventListener('click', (e) => {
      if (editTimeEntryModal && e.target === editTimeEntryModal) {
        closeEditTimeEntryModal();
      }
    });

    // Close edit modal with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && editTimeEntryModal && !editTimeEntryModal.classList.contains('hidden')) {
        closeEditTimeEntryModal();
      }
    });

    // Handle edit method radio button changes
    document.addEventListener('change', (e) => {
      const target = e.target as HTMLInputElement;
      if (target.name === 'editMethod') {
        const timesSection = document.getElementById('timesSection');
        const durationSection = document.getElementById('durationSection');
        
        if (target.value === 'times') {
          timesSection?.classList.remove('hidden');
          durationSection?.classList.add('hidden');
        } else {
          timesSection?.classList.add('hidden');
          durationSection?.classList.remove('hidden');
        }
      }
    });

    // Handle edit form submission
    if (editTimeEntryForm) {
      editTimeEntryForm.addEventListener('submit', async (e: Event) => {
        e.preventDefault();
        
        const target = e.target as HTMLFormElement;
        const submitButton = target.querySelector('button[type="submit"]') as HTMLButtonElement;
        const saveButtonText = document.getElementById('saveEditButtonText') as HTMLSpanElement;
        const saveButtonSpinner = document.getElementById('saveEditButtonSpinner') as HTMLElement;
        const originalText = saveButtonText.textContent;
        
        // Show loading state
        submitButton.disabled = true;
        saveButtonText.textContent = 'Saving...';
        saveButtonSpinner.classList.remove('hidden');
        
        const entryId = document.getElementById('editTimeEntryId') as HTMLInputElement;
        const editTaskIdInput = document.getElementById('editTimeEntryTaskId') as HTMLInputElement;
        const editMethod = document.querySelector('input[name="editMethod"]:checked') as HTMLInputElement;
        const startTimeInput = document.getElementById('editStartTime') as HTMLInputElement;
        const endTimeInput = document.getElementById('editEndTime') as HTMLInputElement;
        const durationInput = document.getElementById('editDuration') as HTMLInputElement;
        const notesInput = document.getElementById('editNotes') as HTMLTextAreaElement;
        const editTimesDateInput = document.getElementById('editTimesDate') as HTMLInputElement;
        const editDurationDateInput = document.getElementById('editDurationDate') as HTMLInputElement;
        
        let updateData: any = {
          notes: notesInput?.value || null
        };

        // Add task ID if changed
        if (editTaskIdInput?.value) {
          updateData.taskId = parseInt(editTaskIdInput.value);
        }

        if (editMethod?.value === 'times') {
          if (!startTimeInput?.value || !endTimeInput?.value || !editTimesDateInput?.value) {
            alert('Please fill in start time, end time, and task date');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          
          // Parse start time using flexible parser
          const startParsedTime = parseFlexibleTime(startTimeInput.value);
          if (!startParsedTime) {
            alert('Invalid start time format. Please use formats like 3p, 3:30pm, 12am, 300pm, etc.');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          
          // Parse end time using flexible parser
          const endParsedTime = parseFlexibleTime(endTimeInput.value);
          if (!endParsedTime) {
            alert('Invalid end time format. Please use formats like 3p, 3:30pm, 12am, 300pm, etc.');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          
          
          // Create datetime objects using local date construction
          const [year, month, day] = editTimesDateInput.value.split('-').map(Number);
          const startDateTime = new Date(year, month - 1, day, startParsedTime.hours, startParsedTime.minutes, 0, 0);
          const endDateTime = new Date(year, month - 1, day, endParsedTime.hours, endParsedTime.minutes, 0, 0);
          
          updateData.startTime = startDateTime.toISOString();
          updateData.endTime = endDateTime.toISOString();
          updateData.taskDate = editTimesDateInput.value;
          // Clear manual duration since we're now using start/end times
          updateData.durationManual = null;
        } else {
          if (!durationInput?.value || !editDurationDateInput?.value) {
            alert('Please enter duration and task date');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          // Parse the duration input and convert to server format
          const parsedDuration = parseFlexibleDuration(durationInput.value);
          if (!parsedDuration) {
            alert('Please enter a valid duration format (e.g., 2h 30m, 2.5h, 150m, 2:30)');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          
          updateData.durationManual = parsedDuration;
          updateData.taskDate = editDurationDateInput.value;
          // Clear start and end times for manual duration entries
          updateData.startTime = null;
          updateData.endTime = null;
        }

        try {
          const response = await fetch(`/api/time-entries-unified/${entryId?.value}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updateData),
          });
          
          if (response.ok) {
            // Show success message
            saveButtonText.textContent = 'Saved!';
            submitButton.classList.add('bg-gray-800');
            saveButtonSpinner.classList.add('hidden');
            
            // Close modal and reload page after a brief delay
            setTimeout(() => {
              closeEditTimeEntryModal();
              window.location.reload(); // Reload page to show updated data
            }, 1000);
          } else {
            const errorData = await response.json();
            alert(`Error updating time entry: ${errorData.error || 'Unknown error'}`);
            // Reset button state on error
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            submitButton.classList.remove('bg-gray-800');
            saveButtonSpinner.classList.add('hidden');
          }
        } catch (error) {
          console.error('Error:', error);
          alert('Error updating time entry. Please try again.');
          // Reset button state on error
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          submitButton.classList.remove('bg-gray-800');
          saveButtonSpinner.classList.add('hidden');
        }
      });
    }

    // Handle delete time entry
    if (deleteTimeEntryBtn) {
      deleteTimeEntryBtn.addEventListener('click', async () => {
        const entryId = document.getElementById('editTimeEntryId') as HTMLInputElement;
        
        if (!entryId?.value) {
          // No time entry selected for deletion
          return;
        }

        if (!confirm('Are you sure you want to delete this time entry? This action cannot be undone.')) {
          return;
        }

        try {
        const response = await fetch(`/api/time-entries-unified/${entryId.value}`, {
          method: 'DELETE',
        });
          
          if (response.ok) {
            // Close modal and reload page
            closeEditTimeEntryModal();
            window.location.reload(); // Reload page to reflect deletion
          } else {
            const errorData = await response.json();
            console.error(`Error deleting time entry: ${errorData.error || 'Unknown error'}`);
          }
        } catch (error) {
          console.error('Error:', error);
          console.error('Error deleting time entry');
        }
      });
    }
  </script>
</DashboardLayout>
