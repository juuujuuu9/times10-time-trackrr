---
import Layout from '../layouts/Layout.astro';
import { requireAuth } from '../utils/session';
import { db } from '../db/index';
import { timeEntries, users, tasks, projects, clients } from '../db/schema';
import { sql, eq } from 'drizzle-orm';

// Require authentication
const user = await requireAuth('/')(Astro) as any;

// Get current user's time entries with related data
const userTimeEntries = await db
  .select({
    id: timeEntries.id,
    startTime: timeEntries.startTime,
    endTime: timeEntries.endTime,
    durationManual: timeEntries.durationManual,
    notes: timeEntries.notes,
    createdAt: timeEntries.createdAt,
    userName: users.name,
    taskName: tasks.name,
    projectName: projects.name,
    clientName: clients.name,
  })
  .from(timeEntries)
  .innerJoin(users, sql`${timeEntries.userId} = ${users.id}`)
  .innerJoin(tasks, sql`${timeEntries.taskId} = ${tasks.id}`)
  .innerJoin(projects, sql`${tasks.projectId} = ${projects.id}`)
  .innerJoin(clients, sql`${projects.clientId} = ${clients.id}`)
  .where(eq(timeEntries.userId, user.id))
  .orderBy(sql`${timeEntries.createdAt} DESC`);

// Get all clients for filtering (only those the user has worked on)
const userClients = await db
  .selectDistinct({ name: clients.name })
  .from(timeEntries)
  .innerJoin(tasks, sql`${timeEntries.taskId} = ${tasks.id}`)
  .innerJoin(projects, sql`${tasks.projectId} = ${projects.id}`)
  .innerJoin(clients, sql`${projects.clientId} = ${clients.id}`)
  .where(eq(timeEntries.userId, user.id))
  .orderBy(clients.name);

// Get all tasks for filtering (only those the user has worked on)
const userTasks = await db
  .selectDistinct({
    id: tasks.id,
    name: tasks.name,
    projectName: projects.name,
    clientName: clients.name,
  })
  .from(timeEntries)
  .innerJoin(tasks, sql`${timeEntries.taskId} = ${tasks.id}`)
  .innerJoin(projects, sql`${tasks.projectId} = ${projects.id}`)
  .innerJoin(clients, sql`${projects.clientId} = ${clients.id}`)
  .where(eq(timeEntries.userId, user.id))
  .orderBy(clients.name, projects.name, tasks.name);
---

<Layout title="My Time Entries - Times10 Time Tracker">
  <div class="min-h-screen bg-gray-50">
    <!-- Header -->
    <header class="bg-white shadow-sm border-b border-gray-200 flex items-center" style="height: 58px;">
      <div class="max-w-7xl mx-auto px-8 w-full">
        <div class="flex justify-between items-center">
          <div class="flex items-center">
            <img src="/trackr-icon.png" alt="Times10 Logo" class="w-auto mr-3 py-0" style="height: calc(58px - 1rem);" />
          </div>
          <div class="flex items-center space-x-4">
            <span class="text-sm text-gray-600">Welcome, {user?.name || 'User'}</span>
            <span class="px-3 py-1 text-xs font-medium bg-gray-100 text-gray-800 rounded-full">
              Team Member
            </span>
            <button
              id="logoutButton"
              class="text-sm text-gray-600 hover:text-gray-900 transition-colors"
            >
              Sign Out
            </button>
          </div>
        </div>
      </div>
    </header>

    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      <div class="space-y-6">
        <!-- Header -->
        <div class="flex justify-between items-center">
          <div>
            <h1 class="text-2xl font-bold text-gray-900">My Time Entries</h1>
            <p class="text-gray-600">View and manage your time tracking data</p>
          </div>
          <div class="flex space-x-3">
            <button
              id="exportCsvBtn"
              class="inline-flex items-center px-4 py-2 text-white font-medium rounded-lg transition-all duration-200 shadow-sm hover:shadow-md"
              style="background-color: #1F292E;"
              onmouseover="this.style.backgroundColor='#000000'"
              onmouseout="this.style.backgroundColor='#1F292E'"
            >
              <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
              </svg>
              Export CSV
            </button>
            <a
              href="/dashboard"
              class="inline-flex items-center px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white font-medium rounded-lg transition-all duration-200 shadow-sm hover:shadow-md"
            >
              <span class="mr-2">‚Üê</span>
              Back to Timer
            </a>
          </div>
        </div>

        <!-- Filters -->
        <div class="bg-white rounded-lg shadow border border-gray-200 p-6">
          <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            <div>
              <label for="search" class="block text-sm font-medium text-gray-700 mb-1">Search</label>
              <input
                type="text"
                id="search"
                placeholder="Search entries..."
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#415058] focus:border-[#415058]"
              />
            </div>
            <div>
              <label for="clientFilter" class="block text-sm font-medium text-gray-700 mb-1">Client</label>
              <select
                id="clientFilter"
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#415058] focus:border-[#415058]"
              >
                <option value="">All Clients</option>
                {userClients.map((client) => (
                  <option value={client.name}>{client.name}</option>
                ))}
              </select>
            </div>
            <div>
              <label for="taskFilter" class="block text-sm font-medium text-gray-700 mb-1">Task</label>
              <select
                id="taskFilter"
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#415058] focus:border-[#415058]"
              >
                <option value="">All Tasks</option>
                {userTasks.map((task) => (
                  <option value={task.name}>{task.clientName} - {task.projectName} - {task.name}</option>
                ))}
              </select>
            </div>
            <div>
              <label for="dateRange" class="block text-sm font-medium text-gray-700 mb-1">Date Range</label>
              <select
                id="dateRange"
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#415058] focus:border-[#415058]"
              >
                <option value="">All Time</option>
                <option value="today">Today</option>
                <option value="week">This Week</option>
                <option value="month">This Month</option>
                <option value="quarter">This Quarter</option>
                <option value="custom">Custom Range</option>
              </select>
            </div>
          </div>
          <div id="customDateRange" class="hidden mt-4">
            <label class="block text-sm font-medium text-gray-700 mb-1">Custom Date Range</label>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div class="flex flex-col">
                <label for="startDate" class="block text-xs text-gray-500 mb-1">Start Date</label>
                <input
                  type="date"
                  id="startDate"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#415058] focus:border-[#415058] text-sm"
                />
              </div>
              <div>
                <label for="endDate" class="block text-xs text-gray-500 mb-1">End Date</label>
                <input
                  type="date"
                  id="endDate"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#415058] focus:border-[#415058] text-sm"
                />
              </div>
            </div>
          </div>
        </div>

        <!-- Time Entries Table -->
        <div class="bg-white rounded-lg shadow border border-gray-200 overflow-hidden">
          <!-- Results Counter -->
          <div class="px-6 py-3 bg-gray-50 border-b border-gray-200">
            <div class="flex justify-between items-center">
              <span id="resultsCounter" class="text-sm text-gray-600">
                Showing {userTimeEntries.length} time entries
              </span>
              <span class="text-xs text-gray-500">
                Total entries: {userTimeEntries.length}
              </span>
            </div>
          </div>
          <div class="overflow-x-auto">
            <table class="min-w-full divide-y divide-gray-200">
              <thead class="bg-gray-50">
                <tr>
                  <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Client
                  </th>
                  <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Project
                  </th>
                  <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Task
                  </th>
                  <th id="dateSortBtn" class="cursor-pointer px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider hover:text-gray-700 transition-colors">
                    <div class="flex items-center">
                      <span>Date</span>
                      <svg id="dateSortIcon" class="w-3 h-3 text-gray-400 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"></path>
                      </svg>
                    </div>
                  </th>
                  <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Start
                  </th>
                  <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Stop
                  </th>
                  <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Duration
                  </th>
                  <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Notes
                  </th>
                  <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody class="bg-white divide-y divide-gray-200">
                {userTimeEntries.map((entry) => {
                  const taskDate = entry.startTime ? new Date(entry.startTime) : new Date(entry.createdAt);
                  const duration = entry.durationManual ? entry.durationManual / 3600 : 0;
                  
                  // Check if this is a manual duration entry (no meaningful start/end times)
                  // Manual duration entries have startTime set to task date but endTime is null
                  const isManualDurationEntry = entry.durationManual && !entry.endTime;
                  const startTime = (!isManualDurationEntry && entry.startTime) ? new Date(entry.startTime) : null;
                  const endTime = (!isManualDurationEntry && entry.endTime) ? new Date(entry.endTime) : null;
                  
                  return (
                    <tr class="hover:bg-gray-50" data-entry-id={entry.id}>
                      <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                        {entry.clientName}
                      </td>
                      <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {entry.projectName}
                      </td>
                      <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {entry.taskName}
                      </td>
                      <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {taskDate.toLocaleDateString()}
                      </td>
                      <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        <input
                          type="text"
                          class="time-input w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent hover:border-blue-400 cursor-pointer"
                          value={startTime ? startTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true }) : '--:-- --'}
                          data-entry-id={entry.id}
                          data-time-type="start"
                          placeholder="9:30 AM"
                          title="Click to edit start time"
                        />
                      </td>
                      <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        <input
                          type="text"
                          class="time-input w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent hover:border-blue-400 cursor-pointer"
                          value={endTime ? endTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true }) : '--:-- --'}
                          data-entry-id={entry.id}
                          data-time-type="end"
                          placeholder="9:30 AM"
                          title="Click to edit end time"
                        />
                      </td>
                      <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {duration ? Math.round(duration * 10) / 10 : 0} hours
                      </td>
                      <td class="px-6 py-4 text-sm text-gray-500 max-w-xs truncate" title={entry.notes || ''}>
                        {entry.notes || '-'}
                      </td>
                      <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <button
                          class="edit-time-entry-btn p-2 text-gray-400 hover:text-[#415058] hover:bg-gray-50 rounded-md transition-colors"
                          data-entry-id={entry.id}
                          data-entry={JSON.stringify(entry)}
                          title="Edit time entry"
                        >
                          <img src="/icons/pencil.svg" alt="Edit" class="w-4 h-4" />
                        </button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>

        {userTimeEntries.length === 0 && (
          <div class="text-center py-12">
            <div class="text-6xl mb-4">‚è±Ô∏è</div>
            <h3 class="text-lg font-medium text-gray-900 mb-2">No time entries yet</h3>
            <p class="text-gray-600 mb-4">Start tracking time to see entries here</p>
            <a
              href="/dashboard"
              class="bg-[#415058] hover:bg-[#1F292E] text-white font-medium py-2 px-4 rounded-lg transition-colors"
            >
              Go to Dashboard
            </a>
          </div>
        )}
      </div>
    </div>
  </div>

  <!-- Edit Time Entry Modal -->
  <div id="editTimeEntryModal" class="fixed inset-0 bg-black/50 hidden z-50">
    <div class="flex items-center justify-center min-h-screen p-4">
      <div class="bg-white rounded-lg shadow-xl max-w-md w-full max-h-[90vh] border border-gray-200 flex flex-col">
        <div class="px-6 py-4 border-b border-gray-200 flex-shrink-0">
          <h3 class="text-lg font-medium text-gray-900">Edit Time Entry</h3>
        </div>
        <div class="flex-1 overflow-y-auto">
          <form id="editTimeEntryForm" class="px-6 py-4">
            <input type="hidden" id="editTimeEntryId" />
            
            <!-- Time Entry Method Selection -->
            <div class="mb-6">
              <label class="block text-sm font-medium text-gray-700 mb-3">Edit Method</label>
              <div class="space-y-3">
                <label class="flex items-center">
                  <input type="radio" name="editMethod" value="times" class="mr-2" checked>
                  <span class="text-sm">Adjust start/end times</span>
                </label>
                <label class="flex items-center">
                  <input type="radio" name="editMethod" value="duration" class="mr-2">
                  <span class="text-sm">Manual duration entry</span>
                </label>
              </div>
            </div>

            <!-- Start/End Times Section -->
            <div id="timesSection" class="space-y-4">
              <div>
                <label for="editStartTime" class="block text-sm font-medium text-gray-700 mb-1">
                  Start Time
                </label>
                <input
                  type="text"
                  id="editStartTime"
                  placeholder="9:30 AM"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
              </div>
              <div>
                <label for="editEndTime" class="block text-sm font-medium text-gray-700 mb-1">
                  End Time
                </label>
                <input
                  type="text"
                  id="editEndTime"
                  placeholder="5:30 PM"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
              </div>
            </div>

            <!-- Duration Section -->
            <div id="durationSection" class="hidden">
              <div>
                <label for="editDuration" class="block text-sm font-medium text-gray-700 mb-1">
                  Duration
                </label>
                <input
                  type="text"
                  id="editDuration"
                  placeholder="e.g., 2h, 3.5hr, 4:15, 90m"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
                <p class="text-xs text-gray-500 mt-1">
                  Supported formats: 2h, 2hr, 3.5hr, 4:15, 90m, 5400s, etc.
                </p>
              </div>
            </div>

            <div class="mb-6">
              <label for="editNotes" class="block text-sm font-medium text-gray-700 mb-1">
                Notes
              </label>
              <textarea
                id="editNotes"
                rows="3"
                placeholder="Optional notes about this time entry..."
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
              ></textarea>
            </div>

            <div class="flex justify-between">
              <button
                type="button"
                id="deleteTimeEntryBtn"
                class="px-4 py-2 text-gray-600 bg-gray-50 hover:bg-gray-100 rounded-md transition-colors border border-gray-200"
              >
                Delete Entry
              </button>
              <div class="flex space-x-3">
                <button
                  type="button"
                  id="cancelEditTimeEntryBtn"
                  class="px-4 py-2 text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  id="saveEditTimeEntryBtn"
                  class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md transition-colors flex items-center space-x-2"
                >
                  <span id="saveEditButtonText">Save Changes</span>
                  <svg id="saveEditButtonSpinner" class="w-4 h-4 animate-spin hidden" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                </button>
              </div>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Time input handling
    document.addEventListener('DOMContentLoaded', function() {
      const timeInputs = document.querySelectorAll('.time-input');
      
      timeInputs.forEach(input => {
        // Store the original value when the input is focused
        input.addEventListener('focus', function() {
          this.setAttribute('data-original-value', this.value);
        });
        
        input.addEventListener('blur', async function() {
          const entryId = this.getAttribute('data-entry-id');
          const timeType = this.getAttribute('data-time-type');
          const timeValue = this.value.trim();
          
          // Skip if empty or if it's the placeholder value
          if (!timeValue || timeValue === '--:-- --') return;
          
          // Skip if the value hasn't changed
          const originalValue = this.getAttribute('data-original-value');
          if (timeValue === originalValue) return;
          
          // Validate time format (12-hour with AM/PM)
          const timeRegex = /^(1[0-2]|0?[1-9]):[0-5][0-9]\s*(am|pm|AM|PM)$/;
          if (!timeRegex.test(timeValue)) {
            alert('Please enter a valid time in 12-hour format (e.g., 9:30 AM, 2:45 PM)');
            this.focus();
            return;
          }
          
          try {
            // Get the current entry data to determine if this is a manual duration entry
            const row = this.closest('tr');
            const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement;
            const entryData = editBtn?.getAttribute('data-entry');
            let currentEntry = null;
            
            if (entryData) {
              try {
                currentEntry = JSON.parse(entryData);
              } catch (e) {
                console.error('Error parsing entry data:', e);
              }
            }
            
            // Get the task date from the current entry
            const taskDate = currentEntry?.startTime ? new Date(currentEntry.startTime) : new Date(currentEntry?.createdAt);
            
            // Parse the time input and create a proper datetime (12-hour format)
            const timeMatch = timeValue.match(/^(1[0-2]|0?[1-9]):([0-5][0-9])\s*(am|pm|AM|PM)$/);
            if (!timeMatch) {
              alert('Invalid time format. Please use 12-hour format (e.g., 9:30 AM, 2:45 PM)');
              this.focus();
              return;
            }
            
            let hours = parseInt(timeMatch[1]);
            const minutes = parseInt(timeMatch[2]);
            const period = timeMatch[3].toLowerCase();
            
            // Convert to 24-hour format
            if (period === 'pm' && hours !== 12) {
              hours += 12;
            } else if (period === 'am' && hours === 12) {
              hours = 0;
            }
            
            const newDateTime = new Date(taskDate);
            newDateTime.setHours(hours, minutes, 0, 0);
            
            const updateData: { startTime?: string; endTime?: string; durationManual?: number | null } = {};
            if (timeType === 'start') {
              updateData.startTime = newDateTime.toISOString();
            } else if (timeType === 'end') {
              updateData.endTime = newDateTime.toISOString();
            }
            
            // If this was a manual duration entry and we're adding times, clear the manual duration
            if (currentEntry?.durationManual && !currentEntry?.endTime) {
              updateData.durationManual = null;
            }
            
            // Validate that end time is after start time if both times are being set
            if (timeType === 'end' && currentEntry?.startTime) {
              const existingStartTime = new Date(currentEntry.startTime);
              if (newDateTime <= existingStartTime) {
                alert('End time must be after start time');
                this.focus();
                return;
              }
            } else if (timeType === 'start' && currentEntry?.endTime) {
              const existingEndTime = new Date(currentEntry.endTime);
              if (newDateTime >= existingEndTime) {
                alert('Start time must be before end time');
                this.focus();
                return;
              }
            }
            
            // Show loading state
            this.style.borderColor = '#3B82F6';
            this.style.backgroundColor = '#F0F9FF';
            
            const response = await fetch(`/api/time-entries/${entryId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(updateData)
            });
            
            if (response.ok) {
              const result = await response.json();
              const row = this.closest('tr');
              
              // Update the duration cell
              const durationCell = row.querySelector('td:nth-child(7)'); // Duration column
              if (durationCell && result.data) {
                const duration = result.data.durationManual ? result.data.durationManual / 3600 : 0;
                durationCell.textContent = `${duration ? Math.round(duration * 10) / 10 : 0} hours`;
              }
              
              // Update the time input values to reflect the new data
              if (result.data) {
                const startTimeInput = row?.querySelector('input[data-time-type="start"]') as HTMLInputElement;
                const endTimeInput = row?.querySelector('input[data-time-type="end"]') as HTMLInputElement;
                
                if (startTimeInput && result.data.startTime) {
                  const startDate = new Date(result.data.startTime);
                  startTimeInput.value = startDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
                } else if (startTimeInput && !result.data.startTime) {
                  startTimeInput.value = '--:-- --';
                }
                
                if (endTimeInput && result.data.endTime) {
                  const endDate = new Date(result.data.endTime);
                  endTimeInput.value = endDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
                } else if (endTimeInput && !result.data.endTime) {
                  endTimeInput.value = '--:-- --';
                }
              }
              
              // Show success feedback
              this.style.borderColor = '#10B981';
              this.style.backgroundColor = '';
              setTimeout(() => {
                this.style.borderColor = '';
              }, 2000);
            } else {
              const error = await response.json();
              
              if (response.status === 401) {
                // Authentication error - redirect to login
                alert('Your session has expired. Please log in again.');
                window.location.href = '/login';
                return;
              }
              
              alert(`Error: ${error.error}`);
              // Reset to original value on error
              this.focus();
            }
          } catch (error) {
            console.error('Error updating time:', error);
            // Reset styling on error
            this.style.borderColor = '';
            this.style.backgroundColor = '';
            alert('Error updating time. Please check your input and try again.');
            this.focus();
          }
        });
        
        // Handle Enter key
        input.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            this.blur();
          }
        });
      });
    });

    // Export CSV functionality
    document.getElementById('exportCsvBtn')?.addEventListener('click', () => {
      const rows = document.querySelectorAll('tbody tr:not([style*="display: none"])');
      let csv = 'Client,Project,Task,Date,Start,Stop,Duration,Notes\n';
      
      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        const rowData = Array.from(cells).map(cell => {
          // Handle input elements
          const input = cell.querySelector('input');
          if (input) {
            return `"${input.value.replace(/"/g, '""')}"`;
          }
          const text = cell.textContent?.trim() || '';
          return `"${text.replace(/"/g, '""')}"`;
        });
        csv += rowData.join(',') + '\n';
      });
      
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'my-time-entries.csv';
      a.click();
      window.URL.revokeObjectURL(url);
    });

    // Logout functionality
    document.getElementById('logoutButton')?.addEventListener('click', async () => {
      try {
        const response = await fetch('/api/auth/logout', {
          method: 'POST',
        });
        
        if (response.ok) {
          window.location.href = '/';
        }
      } catch (error) {
        console.error('Logout error:', error);
      }
    });

    // Search functionality
    const searchInput = document.getElementById('search');
    const clientFilter = document.getElementById('clientFilter');
    const taskFilter = document.getElementById('taskFilter');
    const dateRange = document.getElementById('dateRange');

    if (searchInput) {
      searchInput.addEventListener('input', (e) => {
        const target = e.target;
        const searchTerm = target.value.toLowerCase();
        const rows = document.querySelectorAll('tbody tr');
        
        rows.forEach(row => {
          const text = row.textContent?.toLowerCase() || '';
          row.style.display = text.includes(searchTerm) ? '' : 'none';
        });
        
        updateResultsCounter();
      });
    }

    // Client filter functionality
    if (clientFilter) {
      clientFilter.addEventListener('change', (e) => {
        const target = e.target;
        const selectedClient = target.value;
        const rows = document.querySelectorAll('tbody tr');
        
        rows.forEach(row => {
          const clientCell = row.querySelector('td:nth-child(1)');
          const clientName = clientCell?.textContent?.trim() || '';
          if (!selectedClient || clientName === selectedClient) {
            row.style.display = '';
          } else {
            row.style.display = 'none';
          }
        });
        
        updateResultsCounter();
      });
    }

    // Task filter functionality
    if (taskFilter) {
      taskFilter.addEventListener('change', (e) => {
        const target = e.target;
        const selectedTask = target.value;
        const rows = document.querySelectorAll('tbody tr');
        
        rows.forEach(row => {
          const taskCell = row.querySelector('td:nth-child(3)');
          const task = taskCell?.textContent?.trim() || '';
          if (!selectedTask || task === selectedTask) {
            row.style.display = '';
          } else {
            row.style.display = 'none';
          }
        });
        
        updateResultsCounter();
      });
    }

    // Date range filter functionality
    if (dateRange) {
      dateRange.addEventListener('change', (e) => {
        const target = e.target;
        const selectedRange = target.value;
        const customDateRange = document.getElementById('customDateRange');
        
        if (selectedRange === 'custom') {
          customDateRange.classList.remove('hidden');
        } else {
          customDateRange.classList.add('hidden');
        }
        
        applyDateRangeFilter();
      });
    }

    // Custom date range inputs
    const startDate = document.getElementById('startDate');
    const endDate = document.getElementById('endDate');
    const dateSortBtn = document.getElementById('dateSortBtn');
    const dateSortIcon = document.getElementById('dateSortIcon');
    
    // Date sorting functionality
    let dateSortDirection = 'desc';
    
    if (dateSortBtn) {
      dateSortBtn.addEventListener('click', () => {
        dateSortDirection = dateSortDirection === 'desc' ? 'asc' : 'desc';
        
        if (dateSortIcon) {
          if (dateSortDirection === 'desc') {
            dateSortIcon.style.transform = 'rotate(0deg)';
          } else {
            dateSortIcon.style.transform = 'rotate(180deg)';
          }
        }
        
        sortTableByDate();
      });
    }
    
    function sortTableByDate() {
      const tbody = document.querySelector('tbody');
      const rows = Array.from(tbody.querySelectorAll('tr'));
      
      rows.sort((a, b) => {
        const dateTextA = a.querySelector('td:nth-child(4)').textContent.trim();
        const dateTextB = b.querySelector('td:nth-child(4)').textContent.trim();
        
        const dateA = new Date(dateTextA);
        const dateB = new Date(dateTextB);
        
        if (isNaN(dateA.getTime()) || isNaN(dateB.getTime())) {
          return 0;
        }
        
        if (dateSortDirection === 'desc') {
          return dateB - dateA;
        } else {
          return dateA - dateB;
        }
      });
      
      rows.forEach(row => tbody.appendChild(row));
      updateResultsCounter();
    }

    if (startDate) {
      startDate.addEventListener('change', applyDateRangeFilter);
    }

    if (endDate) {
      endDate.addEventListener('change', applyDateRangeFilter);
    }

    function updateResultsCounter() {
      const visibleRows = document.querySelectorAll('tbody tr:not([style*="display: none"])');
      const resultsCounter = document.getElementById('resultsCounter');
      
      if (resultsCounter) {
        resultsCounter.textContent = `Showing ${visibleRows.length} time entries`;
      }
    }

    function applyDateRangeFilter() {
      const selectedRange = dateRange?.value;
      const rows = document.querySelectorAll('tbody tr');
      const now = new Date();
      
      rows.forEach(row => {
        const dateCell = row.querySelector('td:nth-child(4)');
        const dateText = dateCell?.textContent?.trim() || '';
        const entryDate = new Date(dateText);
        
        let show = true;
        
        if (selectedRange === 'today') {
          show = entryDate.toDateString() === now.toDateString();
        } else if (selectedRange === 'week') {
          const dayOfWeek = now.getDay();
          const daysToSubtract = dayOfWeek === 0 ? 0 : dayOfWeek;
          const weekStart = new Date(now);
          weekStart.setDate(now.getDate() - daysToSubtract);
          weekStart.setHours(0, 0, 0, 0);
          const weekEnd = new Date(weekStart);
          weekEnd.setDate(weekStart.getDate() + 6);
          weekEnd.setHours(23, 59, 59, 999);
          show = entryDate >= weekStart && entryDate <= weekEnd;
        } else if (selectedRange === 'month') {
          const monthAgo = new Date(now.getFullYear(), now.getMonth(), 1);
          show = entryDate >= monthAgo;
        } else if (selectedRange === 'quarter') {
          const quarterAgo = new Date(now.getFullYear(), Math.floor(now.getMonth() / 3) * 3, 1);
          show = entryDate >= quarterAgo;
        } else if (selectedRange === 'custom') {
          const customStartDate = document.getElementById('startDate')?.value;
          const customEndDate = document.getElementById('endDate')?.value;
          
          if (customStartDate && customEndDate) {
            const start = new Date(customStartDate);
            const end = new Date(customEndDate);
            end.setHours(23, 59, 59, 999);
            show = entryDate >= start && entryDate <= end;
          } else if (customStartDate) {
            const start = new Date(customStartDate);
            show = entryDate >= start;
          } else if (customEndDate) {
            const end = new Date(customEndDate);
            end.setHours(23, 59, 59, 999);
            show = entryDate <= end;
          } else {
            show = true;
          }
        }
        
        row.style.display = show ? '' : 'none';
      });
      
      updateResultsCounter();
    }

    // Edit Time Entry Modal Functionality
    const editTimeEntryModal = document.getElementById('editTimeEntryModal');
    const editTimeEntryForm = document.getElementById('editTimeEntryForm');
    const cancelEditTimeEntryBtn = document.getElementById('cancelEditTimeEntryBtn');
    const deleteTimeEntryBtn = document.getElementById('deleteTimeEntryBtn');
    let currentEditingEntry: any = null; // Store the current entry being edited

    // Add event listeners for edit buttons (delegated event handling)
    document.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      const editBtn = target.closest('.edit-time-entry-btn') as HTMLElement;
      
      if (editBtn) {
        const entryId = editBtn.getAttribute('data-entry-id');
        const entryData = editBtn.getAttribute('data-entry');
        
        if (entryId && entryData) {
          try {
            const entry = JSON.parse(entryData);
            openEditTimeEntryModal(entry);
          } catch (error) {
            console.error('Error parsing entry data:', error);
          }
        }
      }
    });

    function openEditTimeEntryModal(entry: any) {
      if (!editTimeEntryModal) return;

      // Store the current entry being edited
      currentEditingEntry = entry;

      // Populate form fields
      const entryIdInput = document.getElementById('editTimeEntryId') as HTMLInputElement;
      const startTimeInput = document.getElementById('editStartTime') as HTMLInputElement;
      const endTimeInput = document.getElementById('editEndTime') as HTMLInputElement;
      const durationInput = document.getElementById('editDuration') as HTMLInputElement;
      const notesInput = document.getElementById('editNotes') as HTMLTextAreaElement;

      if (entryIdInput) entryIdInput.value = entry.id;
      if (notesInput) notesInput.value = entry.notes || '';

      // Format time inputs (12-hour format) - only if times exist
      if (startTimeInput) {
        if (entry.startTime) {
          const startDate = new Date(entry.startTime);
          startTimeInput.value = startDate.toLocaleTimeString('en-US', { 
            hour: 'numeric', 
            minute: '2-digit', 
            hour12: true 
          });
        } else {
          startTimeInput.value = '';
        }
      }
      
      if (endTimeInput) {
        if (entry.endTime) {
          const endDate = new Date(entry.endTime);
          endTimeInput.value = endDate.toLocaleTimeString('en-US', { 
            hour: 'numeric', 
            minute: '2-digit', 
            hour12: true 
          });
        } else {
          endTimeInput.value = '';
        }
      }

      // Set duration based on entry duration
      if (durationInput && entry.durationManual) {
        const hours = Math.floor(entry.durationManual / 3600);
        const minutes = Math.floor((entry.durationManual % 3600) / 60);
        durationInput.value = `${hours}h ${minutes}m`;
      }

      // Determine which method to show based on entry type
      const timesSection = document.getElementById('timesSection');
      const durationSection = document.getElementById('durationSection');
      
      // If this is a manual duration entry (no start/end times), show duration method
      if (!entry.startTime && !entry.endTime && entry.durationManual) {
        const durationRadio = document.querySelector('input[name="editMethod"][value="duration"]') as HTMLInputElement;
        if (durationRadio) {
          durationRadio.checked = true;
        }
        timesSection?.classList.add('hidden');
        durationSection?.classList.remove('hidden');
      } else {
        // Default to "times" method (start/end times)
        const timesRadio = document.querySelector('input[name="editMethod"][value="times"]') as HTMLInputElement;
        if (timesRadio) {
          timesRadio.checked = true;
        }
        timesSection?.classList.remove('hidden');
        durationSection?.classList.add('hidden');
      }

      // Show modal
      editTimeEntryModal.classList.remove('hidden');
    }

    function closeEditTimeEntryModal() {
      if (editTimeEntryModal) {
        editTimeEntryModal.classList.add('hidden');
        currentEditingEntry = null; // Clear the stored entry
        if (editTimeEntryForm && editTimeEntryForm instanceof HTMLFormElement) {
          editTimeEntryForm.reset();
        }
        
        // Reset radio button to default selection
        const timesRadio = document.querySelector('input[name="editMethod"][value="times"]') as HTMLInputElement;
        if (timesRadio) {
          timesRadio.checked = true;
        }
        
        // Ensure correct sections are shown
        const timesSection = document.getElementById('timesSection');
        const durationSection = document.getElementById('durationSection');
        timesSection?.classList.remove('hidden');
        durationSection?.classList.add('hidden');
      }
    }

    // Close edit modal when Cancel button is clicked
    if (cancelEditTimeEntryBtn) {
      cancelEditTimeEntryBtn.addEventListener('click', closeEditTimeEntryModal);
    }

    // Close edit modal when clicking outside
    document.addEventListener('click', (e) => {
      if (editTimeEntryModal && e.target === editTimeEntryModal) {
        closeEditTimeEntryModal();
      }
    });

    // Close edit modal with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && editTimeEntryModal && !editTimeEntryModal.classList.contains('hidden')) {
        closeEditTimeEntryModal();
      }
    });

    // Handle edit method radio button changes
    document.addEventListener('change', (e) => {
      const target = e.target as HTMLInputElement;
      if (target.name === 'editMethod') {
        const timesSection = document.getElementById('timesSection');
        const durationSection = document.getElementById('durationSection');
        
        if (target.value === 'times') {
          timesSection?.classList.remove('hidden');
          durationSection?.classList.add('hidden');
        } else {
          timesSection?.classList.add('hidden');
          durationSection?.classList.remove('hidden');
        }
      }
    });

    // Handle edit form submission
    if (editTimeEntryForm) {
      editTimeEntryForm.addEventListener('submit', async (e: Event) => {
        e.preventDefault();
        
        const target = e.target as HTMLFormElement;
        const submitButton = target.querySelector('button[type="submit"]') as HTMLButtonElement;
        const saveButtonText = document.getElementById('saveEditButtonText') as HTMLSpanElement;
        const saveButtonSpinner = document.getElementById('saveEditButtonSpinner') as HTMLElement;
        const originalText = saveButtonText.textContent;
        
        // Show loading state
        submitButton.disabled = true;
        saveButtonText.textContent = 'Saving...';
        saveButtonSpinner.classList.remove('hidden');
        
        const entryId = document.getElementById('editTimeEntryId') as HTMLInputElement;
        const editMethod = document.querySelector('input[name="editMethod"]:checked') as HTMLInputElement;
        const startTimeInput = document.getElementById('editStartTime') as HTMLInputElement;
        const endTimeInput = document.getElementById('editEndTime') as HTMLInputElement;
        const durationInput = document.getElementById('editDuration') as HTMLInputElement;
        const notesInput = document.getElementById('editNotes') as HTMLTextAreaElement;
        
        let updateData: any = {
          notes: notesInput?.value || null
        };

        if (editMethod?.value === 'times') {
          if (!startTimeInput?.value || !endTimeInput?.value) {
            alert('Please fill in both start and end times');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          
          // Get the task date from the original entry (use startTime if it exists, otherwise use createdAt)
          const taskDate = currentEditingEntry?.startTime ? new Date(currentEditingEntry.startTime) : new Date(currentEditingEntry?.createdAt);
          
          // Create start time by combining task date with user input (12-hour format)
          const startTimeMatch = startTimeInput.value.match(/^(1[0-2]|0?[1-9]):([0-5][0-9])\s*(am|pm|AM|PM)$/);
          if (!startTimeMatch) {
            alert('Invalid start time format. Please use 12-hour format (e.g., 9:30 AM, 2:45 PM)');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          
          let startHours = parseInt(startTimeMatch[1]);
          const startMinutes = parseInt(startTimeMatch[2]);
          const startPeriod = startTimeMatch[3].toLowerCase();
          
          // Convert to 24-hour format
          if (startPeriod === 'pm' && startHours !== 12) {
            startHours += 12;
          } else if (startPeriod === 'am' && startHours === 12) {
            startHours = 0;
          }
          
          const startDateTime = new Date(taskDate);
          startDateTime.setHours(startHours, startMinutes, 0, 0);
          updateData.startTime = startDateTime.toISOString();
          
          // Create end time by combining task date with user input (12-hour format)
          const endTimeMatch = endTimeInput.value.match(/^(1[0-2]|0?[1-9]):([0-5][0-9])\s*(am|pm|AM|PM)$/);
          if (!endTimeMatch) {
            alert('Invalid end time format. Please use 12-hour format (e.g., 9:30 AM, 2:45 PM)');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          
          let endHours = parseInt(endTimeMatch[1]);
          const endMinutes = parseInt(endTimeMatch[2]);
          const endPeriod = endTimeMatch[3].toLowerCase();
          
          // Convert to 24-hour format
          if (endPeriod === 'pm' && endHours !== 12) {
            endHours += 12;
          } else if (endPeriod === 'am' && endHours === 12) {
            endHours = 0;
          }
          
          const endDateTime = new Date(taskDate);
          endDateTime.setHours(endHours, endMinutes, 0, 0);
          updateData.endTime = endDateTime.toISOString();
          
          // Validate that end time is after start time
          if (endDateTime <= startDateTime) {
            alert('End time must be after start time');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          
          // Clear manual duration since we're now using start/end times
          updateData.durationManual = null;
        } else {
          if (!durationInput?.value) {
            alert('Please enter a duration');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          updateData.duration = durationInput.value;
          // Clear start and end times for manual duration entries
          updateData.startTime = null;
          updateData.endTime = null;
        }

        try {
          const response = await fetch(`/api/time-entries/${entryId?.value}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updateData),
          });
          
          if (response.ok) {
            // Show success message
            saveButtonText.textContent = 'Saved!';
            submitButton.classList.add('bg-gray-800');
            saveButtonSpinner.classList.add('hidden');
            
            // Close modal and reload page after a brief delay
            setTimeout(() => {
              closeEditTimeEntryModal();
              window.location.reload(); // Reload page to show updated data
            }, 1000);
          } else {
            const errorData = await response.json();
            alert(`Error updating time entry: ${errorData.error || 'Unknown error'}`);
          }
        } catch (error) {
          console.error('Error:', error);
          alert('Error updating time entry');
        } finally {
          // Reset button state
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          submitButton.classList.remove('bg-gray-800');
          saveButtonSpinner.classList.add('hidden');
        }
      });
    }

    // Handle delete time entry
    if (deleteTimeEntryBtn) {
      deleteTimeEntryBtn.addEventListener('click', async () => {
        const entryId = document.getElementById('editTimeEntryId') as HTMLInputElement;
        
        if (!entryId?.value) {
          alert('No time entry selected for deletion');
          return;
        }

        if (!confirm('Are you sure you want to delete this time entry? This action cannot be undone.')) {
          return;
        }

        try {
          const response = await fetch(`/api/time-entries/${entryId.value}`, {
            method: 'DELETE',
          });
          
          if (response.ok) {
            // Close modal and reload page
            closeEditTimeEntryModal();
            window.location.reload(); // Reload page to reflect deletion
          } else {
            const errorData = await response.json();
            alert(`Error deleting time entry: ${errorData.error || 'Unknown error'}`);
          }
        } catch (error) {
          console.error('Error:', error);
          alert('Error deleting time entry');
        }
      });
    }
  </script>
</Layout>
