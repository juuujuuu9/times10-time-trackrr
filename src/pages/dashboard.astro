---
import DashboardLayout from '../layouts/DashboardLayout.astro';
import { requireAuth } from '../utils/session';
import Timer from '../components/Timer';
// Require authentication
const user = await requireAuth('/')(Astro) as any;
---

<DashboardLayout title="Dashboard - Times10 Time Tracker">
  <!-- Loading State (shown immediately) -->
  <div id="loadingState" class="min-h-screen flex items-center justify-center" style="background-color: #f0eef5;">
    <div class="text-center">
      <div class="w-12 h-12 border-4 border-gray-600 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
      <p class="text-gray-600 text-lg">Loading dashboard...</p>
    </div>
  </div>

  <!-- Dashboard Content (hidden initially) -->
  <div id="dashboardContent" class="hidden">

      <div class="max-w-7xl mx-auto p-2 sm:p-4 lg:p-8">
        <div id="dashboardGrid" class="grid grid-cols-1 lg:grid-cols-3 lg:gap-8 sm:gap-4 gap-2 transition-all duration-500 ease-in-out">
          <!-- Main Content -->
          <div id="mainContent" class="lg:col-span-2 lg:space-y-8 sm:space-y-4 space-y-2 transition-all duration-500 ease-in-out">
            <!-- Timer Section -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-2 sm:p-4 transition-all duration-500 ease-in-out">
              <Timer client:load />
            </div>

            <!-- Recent Time Entries -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden transition-all duration-500 ease-in-out">
              <div class="px-6 py-4 border-b border-gray-200 flex justify-between items-center">
                <h2 class="text-xl font-semibold text-gray-900">Recent Entries</h2>
                <div class="flex space-x-4">
                  <button
                    id="refreshEntriesBtn"
                    class="text-sm text-gray-600 hover:text-gray-800 font-medium transition-colors cursor-pointer flex items-center space-x-1"
                    title="Refresh data"
                  >
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    <span>Refresh</span>
                  </button>

                  <button
                    id="viewAllEntriesBtn"
                    class="text-sm text-gray-600 hover:text-gray-800 font-medium transition-colors cursor-pointer"
                  >
                    All Entries
                  </button>
                </div>
              </div>
              <div class="overflow-x-auto">
                <div id="recentEntries" class="min-w-full">
                  <div class="text-center py-8">
                    <div class="w-12 h-12 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
                      <span class="text-gray-400 text-xl">‚è±Ô∏è</span>
                    </div>
                    <p class="text-gray-500">Loading your recent time entries...</p>
                  </div>
                </div>
              </div>
            </div>


          </div>

          <!-- Sidebar -->
          <div id="sidebar" class="g:space-y-8 sm:space-y-4 space-y-2 transition-all duration-500 ease-in-out">
            <!-- Quick Stats -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-3 sm:p-6 transition-all duration-500 ease-in-out">
              <h3 class="text-lg font-semibold text-gray-900 mb-4">Today</h3>
              <div class="space-y-4">
                <div class="flex justify-between items-center">
                  <span class="text-sm text-gray-600">Hours Tracked</span>
                  <span id="todayHours" class="text-lg font-semibold text-gray-900">-</span>
                </div>
              </div>
            </div>

            <!-- Weekly Stats -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-3 sm:p-6 transition-all duration-500 ease-in-out">
              <h3 id="weeklyTitle" class="text-lg font-semibold text-gray-900 mb-4">This Week</h3>
              <div class="space-y-4">
                <div class="flex justify-between items-center">
                  <span class="text-sm text-gray-600">Hours Tracked</span>
                  <span id="weeklyHours" class="text-lg font-semibold text-gray-900">-</span>
                </div>
              </div>
            </div>

            <!-- Quick Actions -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-3 sm:p-6 transition-all duration-500 ease-in-out">
              <h3 class="text-lg font-semibold text-gray-900 mb-4">Quick Actions</h3>
              <div class="space-y-3 mt-4">
                <button
                  id="addTimeEntryBtn"
                  class="w-full text-white px-4 py-2 rounded-lg transition-colors text-sm font-medium flex items-center justify-center space-x-2"
                  style={{
                    backgroundColor: '#1F292E'
                  }}
                  onmouseover="this.style.backgroundColor='#000000'"
                  onmouseout="this.style.backgroundColor='#1F292E'"
                >
                  <svg fill="currentColor" viewBox="0 0 24 24" id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" class="w-4 h-4">
                    <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                    <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g>
                    <g id="SVGRepo_iconCarrier"> 
                      <path d="M23,18H20V15a1,1,0,0,0-2,0v3H15a1,1,0,0,0,0,2h3v3a1,1,0,0,0,2,0V20h3a1,1,0,0,0,0-2Z M11,7v4.586L8.293,14.293a1,1,0,1,0,1.414,1.414l3-3A1,1,0,0,0,13,12V7a1,1,0,0,0-2,0Z M14.728,21.624a9.985,9.985,0,1,1,6.9-6.895,1,1,0,1,0,1.924.542,11.989,11.989,0,1,0-8.276,8.277,1,1,0,1,0-.544-1.924Z"></path>
                    </g>
                  </svg>
                  <span>Quick Entry</span>
                </button>
                <button
                  id="viewReportsBtn"
                  class="w-full bg-gray-100 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-200 transition-colors text-sm font-medium"
                >
                  View Reports
                </button>

              </div>
            </div>


          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Add Manual Time Entry Modal -->
  <div id="timeEntryModal" class="fixed inset-0 bg-black/50 hidden z-50">
    <div class="flex items-center justify-center min-h-screen p-4">
      <div class="bg-white rounded-lg shadow-xl max-w-md w-full max-h-[90vh] border border-gray-200 flex flex-col">
        <div class="px-6 py-4 border-b border-gray-200 flex-shrink-0">
          <h3 class="text-lg font-medium text-gray-900">Add Manual Time Entry</h3>
        </div>
        <div class="flex-1 overflow-y-auto">
          <form id="timeEntryForm" class="px-6 py-4">
            <div class="mb-4">
              <label for="timeEntryTask" class="block text-sm font-medium text-gray-700 mb-1">
                Task <span class="text-gray-500 font-normal">(required)</span>
              </label>
              <div class="relative">
                <input
                  type="text"
                  id="timeEntryTask"
                  placeholder="üîç Search tasks..."
                  required
                  autocomplete="off"
                  class="w-full px-3 py-2 pr-10 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                  oninput="handleTaskSearch(this.value)"
                  onfocus="console.log('Input focused, calling showTaskDropdown'); showTaskDropdown()"
                />
                <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-gray-500">
                  <svg id="taskDropdownArrow" class="fill-current h-5 w-5 transition-transform duration-200 cursor-pointer pointer-events-auto" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" onclick="console.log('Arrow clicked, calling toggleTaskDropdown'); toggleTaskDropdown()">
                    <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/>
                  </svg>
                </div>
                <input type="hidden" id="timeEntryTaskId" />
                <div id="taskDropdown" class="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-y-auto hidden">
                  <!-- Task results will be populated here -->
                </div>
              </div>
            </div>

            <!-- Time Entry Method Selection -->
            <div class="mb-6">
              <label class="block text-sm font-medium text-gray-700 mb-3">Entry Method</label>
              <div class="space-y-3">
                <label class="flex items-center">
                  <input type="radio" name="entryMethod" value="times" class="mr-2" checked>
                  <span class="text-sm">Set start/end times</span>
                </label>
                <label class="flex items-center">
                  <input type="radio" name="entryMethod" value="duration" class="mr-2">
                  <span class="text-sm">Manual duration entry</span>
                </label>
              </div>
            </div>

            <!-- Start/End Times Section -->
            <div id="manualTimesSection" class="space-y-4">
              <div>
                <label for="manualStartTime" class="block text-sm font-medium text-gray-700 mb-1">
                  Start Time
                </label>
                <input
                  type="text"
                  id="manualStartTime"
                  placeholder="9:30 AM"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
              </div>
              <div>
                <label for="manualEndTime" class="block text-sm font-medium text-gray-700 mb-1">
                  End Time
                </label>
                <input
                  type="text"
                  id="manualEndTime"
                  placeholder="5:30 PM"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
              </div>
              <div>
                <label for="manualTimesDate" class="block text-sm font-medium text-gray-700 mb-1">
                  Task Date <span class="text-gray-500 font-normal">(required)</span>
                </label>
                <input
                  type="date"
                  id="manualTimesDate"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
                <p class="text-xs text-gray-500 mt-1">
                  When did this task actually occur? (defaults to today)
                </p>
              </div>
            </div>

            <!-- Duration Section -->
            <div id="manualDurationSection" class="hidden space-y-4">
              <div>
                <label for="timeEntryDuration" class="block text-sm font-medium text-gray-700 mb-1">
                  Duration <span class="text-gray-500 font-normal">(required)</span>
                </label>
                <input
                  type="text"
                  id="timeEntryDuration"
                  placeholder="e.g., 2h, 3.5hr, 4:15, 90m"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
                <p class="text-xs text-gray-500 mt-1">
                  Supported formats: 2h, 2hr, 3.5hr, 4:15, 90m, 5400s, etc.
                </p>
              </div>
              <div>
                <label for="timeEntryDate" class="block text-sm font-medium text-gray-700 mb-1">
                  Task Date <span class="text-gray-500 font-normal">(required)</span>
                </label>
                <input
                  type="date"
                  id="timeEntryDate"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
                <p class="text-xs text-gray-500 mt-1">
                  When did this task actually occur? (defaults to today)
                </p>
              </div>
            </div>

            <div class="mb-6">
              <label for="timeEntryNotes" class="block text-sm font-medium text-gray-700 mb-1">
                Notes
              </label>
              <textarea
                id="timeEntryNotes"
                rows="3"
                placeholder="Optional notes about this time entry..."
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
              ></textarea>
            </div>
            <div class="flex justify-end space-x-3">
              <button
                type="button"
                id="cancelTimeEntryBtn"
                class="px-4 py-2 text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors"
              >
                Cancel
              </button>
              <button
                type="submit"
                id="saveTimeEntryBtn"
                class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md transition-colors flex items-center space-x-2"
              >
                <span id="saveButtonText">Save Entry</span>
                <svg id="saveButtonSpinner" class="w-4 h-4 animate-spin hidden" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>

              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>

  <!-- Edit Time Entry Modal -->
  <div id="editTimeEntryModal" class="fixed inset-0 bg-black/50 hidden z-50">
    <div class="flex items-center justify-center min-h-screen p-4">
      <div class="bg-white rounded-lg shadow-xl max-w-md w-full max-h-[90vh] border border-gray-200 flex flex-col">
        <div class="px-6 py-4 border-b border-gray-200 flex-shrink-0">
          <h3 class="text-lg font-medium text-gray-900">Edit Time Entry</h3>
        </div>
        <div class="flex-1 overflow-y-auto">
          <form id="editTimeEntryForm" class="px-6 py-4">
            <input type="hidden" id="editTimeEntryId" />
            
            <!-- Task Selection -->
            <div class="mb-4">
              <label for="editTimeEntryTask" class="block text-sm font-medium text-gray-700 mb-1">
                Task <span class="text-gray-500 font-normal">(required)</span>
              </label>
              <div class="relative">
                <input
                  type="text"
                  id="editTimeEntryTask"
                  placeholder="üîç Search tasks..."
                  required
                  autocomplete="off"
                  class="w-full px-3 py-2 pr-10 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                  oninput="handleEditTaskSearch(this.value)"
                  onfocus="showEditTaskDropdown()"
                />
                <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-gray-500">
                  <svg id="editTaskDropdownArrow" class="fill-current h-5 w-5 transition-transform duration-200 cursor-pointer pointer-events-auto" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" onclick="toggleEditTaskDropdown()">
                    <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/>
                  </svg>
                </div>
                <input type="hidden" id="editTimeEntryTaskId" />
                <div id="editTaskDropdown" class="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-y-auto hidden">
                  <!-- Task results will be populated here -->
                </div>
              </div>
            </div>
            
            <!-- Time Entry Method Selection -->
            <div class="mb-6">
              <label class="block text-sm font-medium text-gray-700 mb-3">Edit Method</label>
              <div class="space-y-3">
                <label class="flex items-center">
                  <input type="radio" name="editMethod" value="times" class="mr-2" checked>
                  <span class="text-sm">Adjust start/end times</span>
                </label>
                <label class="flex items-center">
                  <input type="radio" name="editMethod" value="duration" class="mr-2">
                  <span class="text-sm">Manual duration entry</span>
                </label>
              </div>
            </div>

            <!-- Start/End Times Section -->
            <div id="timesSection" class="space-y-4">
              <div>
                <label for="editStartTime" class="block text-sm font-medium text-gray-700 mb-1">
                  Start Time
                </label>
                <input
                  type="text"
                  id="editStartTime"
                  placeholder="9:30 AM"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
              </div>
              <div>
                <label for="editEndTime" class="block text-sm font-medium text-gray-700 mb-1">
                  End Time
                </label>
                <input
                  type="text"
                  id="editEndTime"
                  placeholder="5:30 PM"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
              </div>
              <div>
                <label for="editTimesDate" class="block text-sm font-medium text-gray-700 mb-1">
                  Task Date <span class="text-gray-500 font-normal">(required)</span>
                </label>
                <input
                  type="date"
                  id="editTimesDate"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
                <p class="text-xs text-gray-500 mt-1">
                  When did this task actually occur?
                </p>
              </div>
            </div>

            <!-- Duration Section -->
            <div id="durationSection" class="hidden space-y-4">
              <div>
                <label for="editDuration" class="block text-sm font-medium text-gray-700 mb-1">
                  Duration
                </label>
                <input
                  type="text"
                  id="editDuration"
                  placeholder="e.g., 2h, 3.5hr, 4:15, 90m"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
                <p class="text-xs text-gray-500 mt-1">
                  Supported formats: 2h, 2hr, 3.5hr, 4:15, 90m, 5400s, etc.
                </p>
              </div>
              <div>
                <label for="editDurationDate" class="block text-sm font-medium text-gray-700 mb-1">
                  Task Date <span class="text-gray-500 font-normal">(required)</span>
                </label>
                <input
                  type="date"
                  id="editDurationDate"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
                <p class="text-xs text-gray-500 mt-1">
                  When did this task actually occur?
                </p>
              </div>
            </div>

            <div class="mb-6">
              <label for="editNotes" class="block text-sm font-medium text-gray-700 mb-1">
                Notes
              </label>
              <textarea
                id="editNotes"
                rows="3"
                placeholder="Optional notes about this time entry..."
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
              ></textarea>
            </div>

            <div class="flex justify-between">
              <button
                type="button"
                id="deleteTimeEntryBtn"
                class="px-4 py-2 text-white hover:text-[#ef4444] bg-[#ef4444] hover:bg-gray-100 rounded-md transition-colors border border-[#ef4444]"
              >
                Delete
              </button>
              <div class="flex space-x-3">
                <button
                  type="button"
                  id="cancelEditTimeEntryBtn"
                  class="px-4 py-2 text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  id="saveEditTimeEntryBtn"
                  class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md transition-colors flex items-center space-x-2"
                >
                  <span id="saveEditButtonText">Save</span>
                  <svg id="saveEditButtonSpinner" class="w-4 h-4 animate-spin hidden" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                </button>
              </div>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>
</DashboardLayout>

<script>
  // Import timezone utilities
  import { createTaskDateTime, formatTimeForDisplay } from '../utils/timezoneUtils';
  
  // Import Flatpickr
  import flatpickr from 'flatpickr';
  
  
  // Show dashboard content after a brief delay to prevent flash
  document.addEventListener('DOMContentLoaded', () => {
    // Mobile optimization: reduce delay for faster loading
    const isMobile = window.innerWidth <= 768;
    const delay = isMobile ? 50 : 100;
    
    setTimeout(() => {
      const loadingState = document.getElementById('loadingState');
      const dashboardContent = document.getElementById('dashboardContent');
      
      if (loadingState && dashboardContent) {
        loadingState.classList.add('hidden');
        dashboardContent.classList.remove('hidden');
      }
    }, delay);
  });

  // Get current user ID from session
  async function getCurrentUserId() {
    try {
      const response = await fetch('/api/auth/me');
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.user) {
          return data.user.id;
        } else {
          console.error('Invalid response format:', data);
          return null;
        }
      } else if (response.status === 401) {
        // If unauthorized, redirect to login
        window.location.href = '/';
        return null;
      } else {
        const errorData = await response.json().catch(() => ({}));
        console.error('Auth error:', errorData.error || 'Unknown error');
      }
    } catch (error) {
      console.error('Error getting current user:', error);
    }
    return null;
  }

  // Load dashboard data
  async function loadDashboardData() {
    console.log('üîß DASHBOARD: Loading dashboard data...');
    try {
      const userId = await getCurrentUserId();
      if (!userId) {
        console.error('No user ID available');
        // Show error state for the sections
        updateRecentEntries([]);
        return;
      }

      // Load user's recent time entries (limit to 10 most recent)
      const entriesResponse = await fetch('/api/time-entries-unified?userId=' + encodeURIComponent(userId) + '&limit=10');
      if (entriesResponse.ok) {
        const entriesData = await entriesResponse.json();
        const recentEntries = entriesData.data || [];
        console.log('üîß DASHBOARD: Loaded recent entries:', recentEntries.length);
        console.log('üîß DASHBOARD: Manual duration entries in data:', recentEntries.filter((entry: any) => entry.durationManual && !entry.startTime && !entry.endTime));
        
        // Load ongoing timers - use user-specific endpoint for team members
        const ongoingResponse = await fetch('/api/timers/user-ongoing');
        if (ongoingResponse.ok) {
          const ongoingData = await ongoingResponse.json();
          const ongoingTimers = ongoingData.data || [];
          console.log('Loaded ongoing timers:', ongoingTimers.length);
          
          // Combine recent entries with ongoing timers
          updateRecentEntries(recentEntries, ongoingTimers);
        } else {
          console.log('No ongoing timers found');
          updateRecentEntries(recentEntries, []);
        }
      } else {
        console.error('Failed to load time entries:', entriesResponse.status);
        updateRecentEntries([], []);
      }

      // Load today's stats using the same API as Timer component
      const today = new Date();
      const startOfToday = new Date(today);
      startOfToday.setHours(0, 0, 0, 0);
      const endOfToday = new Date(today);
      endOfToday.setHours(23, 59, 59, 999);
      
      const todayStatsResponse = await fetch(`/api/reports/daily-duration-totals?userId=${encodeURIComponent(userId)}&startDate=${encodeURIComponent(startOfToday.toISOString())}&endDate=${encodeURIComponent(endOfToday.toISOString())}`);
      if (todayStatsResponse.ok) {
        const todayStatsData = await todayStatsResponse.json();
        updateTodayStats(todayStatsData, true);
      }

      // Load weekly stats using the same API as Timer component
      const now = new Date();
      const dayOfWeek = now.getDay();
      const daysToSubtract = dayOfWeek === 0 ? 0 : dayOfWeek;
      const weekStart = new Date(now);
      weekStart.setDate(now.getDate() - daysToSubtract);
      weekStart.setHours(0, 0, 0, 0);
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6);
      weekEnd.setHours(23, 59, 59, 999);
      
      const statsResponse = await fetch(`/api/reports/daily-duration-totals?userId=${encodeURIComponent(userId)}&startDate=${encodeURIComponent(weekStart.toISOString())}&endDate=${encodeURIComponent(weekEnd.toISOString())}`);
      if (statsResponse.ok) {
        const statsData = await statsResponse.json();
        updateWeeklyStats(statsData, true);
      }

      // Start real-time updates for ongoing timers
      startRealTimeUpdates(userId);

    } catch (error) {
      console.error('Error loading dashboard data:', error);
      // Retry loading after a delay if there was an error
      setTimeout(() => {
        console.log('Retrying dashboard data load...');
        loadDashboardData();
      }, 2000);
    }
  }

  function updateRecentEntries(entries: any[], ongoingTimers: any[] = []) {
    console.log('updateRecentEntries called with', entries.length, 'entries and', ongoingTimers.length, 'timers');
    const container = document.getElementById('recentEntries');
    if (!container) return;



    // Disable manual entry if there's an ongoing timer
    const addTimeEntryBtn = document.getElementById('addTimeEntryBtn') as HTMLButtonElement;
    if (addTimeEntryBtn) {
      if (ongoingTimers.length > 0) {
        addTimeEntryBtn.disabled = true;
        addTimeEntryBtn.classList.add('opacity-50', 'cursor-not-allowed');
        addTimeEntryBtn.title = 'Please stop the current timer before adding manual entries';
      } else {
        addTimeEntryBtn.disabled = false;
        addTimeEntryBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        addTimeEntryBtn.title = 'Add manual time entry';
      }
    }

    // Disable all manual entry form fields when timer is running
    const isTimerRunning = ongoingTimers.length > 0;
    const manualEntryFields = [
      'timeEntryDuration',
      'timeEntryDate', 
      'manualStartTime',
      'manualEndTime',
      'manualTimesDate',
      'timeEntryNotes',
      'timeEntryTaskId'
    ];

    manualEntryFields.forEach(fieldId => {
      const field = document.getElementById(fieldId) as HTMLInputElement | HTMLTextAreaElement;
      if (field) {
        if (isTimerRunning) {
          field.disabled = true;
          field.classList.add('opacity-50', 'cursor-not-allowed', 'bg-gray-100');
          field.placeholder = 'Timer is running - please stop timer first';
        } else {
          field.disabled = false;
          field.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-100');
          // Reset placeholder to original values
          if (fieldId === 'timeEntryDuration') field.placeholder = 'e.g., 2h, 3.5hr, 4:15, 90m';
          else if (fieldId === 'manualStartTime') field.placeholder = '9:30 AM';
          else if (fieldId === 'manualEndTime') field.placeholder = '5:30 PM';
          else if (fieldId === 'timeEntryNotes') field.placeholder = 'Optional notes about this time entry...';
          else if (fieldId === 'timeEntryTaskId') field.placeholder = '';
        }
      }
    });

    // Also disable radio buttons for entry method
    const entryMethodRadios = document.querySelectorAll('input[name="entryMethod"]') as NodeListOf<HTMLInputElement>;
    entryMethodRadios.forEach(radio => {
      if (isTimerRunning) {
        radio.disabled = true;
        radio.classList.add('opacity-50', 'cursor-not-allowed');
      } else {
        radio.disabled = false;
        radio.classList.remove('opacity-50', 'cursor-not-allowed');
      }
    });

    if (entries.length === 0 && ongoingTimers.length === 0) {
      container.innerHTML = `
        <div class="text-center py-8">
          <div class="w-12 h-12 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
            <span class="text-gray-400 text-xl">‚è±Ô∏è</span>
          </div>
          <p class="text-gray-500">No time entries yet</p>
          <p class="text-gray-400 text-sm mt-1">Start tracking your time to see entries here</p>
        </div>
      `;
      return;
    }

    // Show more entries in table format, but prioritize ongoing timers
    const displayEntries = entries.slice(0, 10);
    
    // Filter out any entries that are also in ongoing timers to avoid duplicates
    const ongoingTimerIds = new Set(ongoingTimers.map(timer => timer.id));
    const filteredEntries = displayEntries.filter(entry => !ongoingTimerIds.has(entry.id));
    
    container.innerHTML = `
      <style>
        .table-column-separator {
          position: relative;
        }
        .table-column-separator:not(:last-child)::after {
          content: '';
          position: absolute;
          right: 0;
          top: 20%;
          bottom: 20%;
          width: 1px;
          background-color: #e5e7eb;
          opacity: 0.6;
        }
        .table-column-separator-header:not(:last-child)::after {
          content: '';
          position: absolute;
          right: 0;
          top: 15%;
          bottom: 15%;
          width: 1px;
          background-color: #d1d5db;
          opacity: 0.8;
        }
      </style>
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
          <tr>
            <th class="table-column-separator-header px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Client
            </th>
            <th class="table-column-separator-header px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Project
            </th>
            <th class="table-column-separator-header px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Date
            </th>
            <th class="table-column-separator-header px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Start
            </th>
            <th class="table-column-separator-header px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Stop
            </th>
            <th class="table-column-separator-header px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Duration
            </th>
            <th class="table-column-separator-header px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Notes
            </th>
            <th class="table-column-separator-header px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
              Actions
            </th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-gray-200">
          ${ongoingTimers.map((timer: any) => {
            const taskDate = new Date(timer.startTime);
            const elapsedHours = (timer.elapsedSeconds / 3600).toFixed(1);
            const startTime = new Date(timer.startTime);
            const startTimeDisplay = formatTimeForDisplay(startTime);
            
            return `
              <tr class="hover:bg-gray-50 bg-green-50 border-l-4 border-green-400" data-timer-id="${timer.id}">
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">
                  ${timer.clientName || 'Unknown Client'}
                </td>
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">
                  ${timer.projectName || 'Unknown Project'}
                </td>
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-sm text-gray-500">
                  ${taskDate.toLocaleDateString()}
                </td>
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  ${startTimeDisplay}
                </td>
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  <button
                    class="stop-timer-btn px-2 py-1 text-xs font-medium text-white bg-red-500 hover:bg-red-600 rounded transition-colors"
                    data-timer-id="${timer.id}"
                    data-user-id="${timer.userId}"
                    title="Stop timer"
                  >
                    Stop
                  </button>
                </td>
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-sm text-gray-900" data-role="timer-duration" data-timer-id="${timer.id}">
                  <span class="timer-duration" data-timer-id="${timer.id}">${(() => {
                    const seconds = timer.elapsedSeconds;
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    return `${hours}h ${minutes}m`;
                  })()}</span>
                </td>
                <td class="table-column-separator px-4 py-3 text-sm text-gray-500 max-w-xs truncate" title="${timer.notes || ''}">
                  ${timer.notes || '-'}
                </td>
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-right text-sm font-medium">
                  <div class="flex items-center justify-end">
                    <div class="w-2 h-2 bg-green-500 rounded-full mr-2 animate-pulse"></div>
                    <span class="text-xs text-green-600 font-medium">Running</span>
                  </div>
                </td>
              </tr>
            `;
          }).join('')}
          ${filteredEntries.map((entry: any) => {
            // For manual duration entries, use createdAt for task date since startTime is null
            // Use timezone-safe date handling for display
            const taskDate = entry.startTime ? 
              (() => {
                const date = new Date(entry.startTime);
                // Use local components so the date matches the times shown
                const year = date.getFullYear();
                const month = date.getMonth() + 1;
                const day = date.getDate();
                return new Date(year, month - 1, day, 0, 0, 0, 0);
              })() : 
              (() => {
                const date = new Date(entry.createdAt);
                // Use local components so the date matches the times shown
                const year = date.getFullYear();
                const month = date.getMonth() + 1;
                const day = date.getDate();
                return new Date(year, month - 1, day, 0, 0, 0, 0);
              })();
            const durationHours = entry.duration ? (entry.duration / 3600).toFixed(1) : '0';
            
            // Check if this is a manual duration entry (has durationManual but no startTime/endTime)
            const isManualDurationEntry = entry.durationManual && !entry.startTime && !entry.endTime;
            const startTime = (!isManualDurationEntry && entry.startTime) ? new Date(entry.startTime) : null;
            const endTime = (!isManualDurationEntry && entry.endTime) ? new Date(entry.endTime) : null;
            
            // Format times for display using timezone-safe function
            const startTimeDisplay = startTime ? formatTimeForDisplay(startTime) : '--:-- --';
            const endTimeDisplay = endTime ? formatTimeForDisplay(endTime) : '--:-- --';
            
            return `
              <tr class="hover:bg-gray-50" data-entry-id="${entry.id}">

                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  ${entry.clientName || 'Unknown Client'}
                </td>
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  ${entry.projectName || 'Unknown Project'}
                </td>
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-sm text-gray-500">
                  <input
                    type="text"
                    class="date-input w-24 px-2 py-1 text-xs border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                    value="${taskDate.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: 'numeric' })}"
                    data-entry-id="${entry.id}"
                    data-current-date="${taskDate.toISOString().split('T')[0]}"
                    placeholder="mm/dd/yyyy"
                    title="Click to open date picker"
                  />
                </td>
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  <input
                    type="text"
                    class="time-input w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent hover:border-blue-400 cursor-pointer ${isManualDurationEntry ? 'bg-gray-100 cursor-not-allowed' : ''}"
                    value="${startTimeDisplay}"
                    data-entry-id="${entry.id}"
                    data-time-type="start"
                    placeholder="9:30 AM"
                    title="${isManualDurationEntry ? 'Manual duration entry - use edit button to modify' : 'Click to edit start time'}"
                    ${isManualDurationEntry ? 'readonly' : ''}
                  />
                </td>
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  <input
                    type="text"
                    class="time-input w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-transparent hover:border-blue-400 cursor-pointer ${isManualDurationEntry ? 'bg-gray-100 cursor-not-allowed' : ''}"
                    value="${endTimeDisplay}"
                    data-entry-id="${entry.id}"
                    data-time-type="end"
                    placeholder="9:30 AM"
                    title="${isManualDurationEntry ? 'Manual duration entry - use edit button to modify' : 'Click to edit end time'}"
                    ${isManualDurationEntry ? 'readonly' : ''}
                  />
                </td>
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-sm text-gray-900" data-role="duration">
                  <input
                    type="text"
                    class="duration-input w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent hover:border-blue-400 cursor-pointer"
                    value="${(() => {
                      const seconds = entry.duration || 0;
                      const hours = Math.floor(seconds / 3600);
                      const minutes = Math.floor((seconds % 3600) / 60);
                      return `${hours}h ${minutes}m`;
                    })()}"
                    data-entry-id="${entry.id}"
                    data-time-type="duration"
                    placeholder="2h 30m"
                    title="Click to edit duration"
                  />
                </td>
                <td class="table-column-separator px-4 py-3 text-sm text-gray-500 max-w-xs">
                  <input
                    type="text"
                    class="notes-input w-20 px-2 py-1 text-xs border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200 ease-in-out"
                    data-entry-id="${entry.id}"
                    placeholder="Add Note"
                    value="${entry.notes || ''}"
                    title="Click to add or edit notes"
                    style="width: 5rem;"
                  />
                </td>
                <td class="table-column-separator px-4 py-3 whitespace-nowrap text-right text-sm font-medium">
                  <button
                    class="edit-time-entry-btn p-2 text-gray-400 hover:text-[#415058] hover:bg-gray-50 rounded-md transition-colors"
                    data-entry-id="${entry.id}"
                    data-entry='${JSON.stringify(entry)}'
                    title="Edit time entry"
                  >
                    <img src="/icons/pencil.svg" alt="Edit" class="w-4 h-4" />
                  </button>
                </td>
              </tr>
            `;
          }).join('')}
        </tbody>
      </table>
    `;

    // Start updating ongoing timer durations
    startTimerDurationUpdates(ongoingTimers);
  }

  // Timer duration update intervals
  let timerUpdateIntervals: { [key: string]: NodeJS.Timeout } = {};

  function startTimerDurationUpdates(ongoingTimers: any[]) {
    // Clear existing intervals
    Object.values(timerUpdateIntervals).forEach(interval => clearInterval(interval));
    timerUpdateIntervals = {};

    // Start new intervals for each timer
    ongoingTimers.forEach(timer => {
      const startTime = new Date(timer.startTime);
      
      const interval = setInterval(() => {
        const now = new Date();
        const elapsedSeconds = Math.floor((now.getTime() - startTime.getTime()) / 1000);
        const elapsedHours = (elapsedSeconds / 3600).toFixed(1);
        
        const durationElement = document.querySelector(`[data-role="timer-duration"][data-timer-id="${timer.id}"]`);
        if (durationElement) {
          durationElement.textContent = formatDuration(elapsedSeconds);
        }
      }, 1000);
      
      timerUpdateIntervals[timer.id] = interval;
    });
  }

  function stopTimerDurationUpdates() {
    Object.values(timerUpdateIntervals).forEach(interval => clearInterval(interval));
    timerUpdateIntervals = {};
  }

  // Store current timer state for real-time updates
  let currentTimerState: {
    isRunning: boolean;
    projectId: number | null;
    currentSessionSeconds: number;
    today: number;
    weekOffset: number;
  } | null = null;

  function updateTodayStats(stats: any, includeCurrentTimer: boolean = false) {
    const todayHours = document.getElementById('todayHours');

    if (todayHours && stats.weekTotals) {
      // Get today's total from the weekTotals array
      const today = new Date();
      const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
      let todayTotal = stats.weekTotals[dayOfWeek]?.totalSeconds || 0;
      
      // Add current timer time if it's running and we're viewing current week
      if (includeCurrentTimer && currentTimerState && currentTimerState.isRunning && currentTimerState.weekOffset === 0) {
        todayTotal += currentTimerState.currentSessionSeconds;
      }
      
      // Convert seconds to hours for display
      const hoursFromSeconds = todayTotal / 3600;
      todayHours.textContent = formatHours(hoursFromSeconds);
    }
  }

  function updateWeeklyStats(stats: any, includeCurrentTimer: boolean = false) {
    const weeklyHours = document.getElementById('weeklyHours');
    const weeklyTitle = document.getElementById('weeklyTitle');

    if (weeklyHours && stats.weekTotals) {
      // Sum up all days in the week
      let totalSeconds = stats.weekTotals.reduce((sum: number, day: any) => sum + (day.totalSeconds || 0), 0);
      
      // Add current timer time if it's running and we're viewing current week
      if (includeCurrentTimer && currentTimerState && currentTimerState.isRunning && currentTimerState.weekOffset === 0) {
        totalSeconds += currentTimerState.currentSessionSeconds;
      }
      
      // Convert seconds to hours for display
      const hoursFromSeconds = totalSeconds / 3600;
      weeklyHours.textContent = formatHours(hoursFromSeconds);
    }

    if (weeklyTitle && stats.startDate && stats.endDate) {
      // Format date range for display (e.g., "9/14-9/20")
      const formatDateForDisplay = (date: Date) => {
        const month = date.getMonth() + 1;
        const day = date.getDate();
        return `${month}/${day}`;
      };
      
      const startDate = new Date(stats.startDate);
      const endDate = new Date(stats.endDate);
      const dateRangeDisplay = `${formatDateForDisplay(startDate)}-${formatDateForDisplay(endDate)}`;
      weeklyTitle.textContent = `This Week (${dateRangeDisplay})`;
    }
  }



  function formatDuration(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    return `${hours}h ${minutes}m`;
  }

  function formatHours(hours: number): string {
    const totalMinutes = Math.round(hours * 60);
    const h = Math.floor(totalMinutes / 60);
    const m = totalMinutes % 60;
    return `${h.toString().padStart(2, '0')} hr., ${m.toString().padStart(2, '0')} min`;
  }

  // Real-time updates for ongoing timers
  let realTimeUpdateInterval: ReturnType<typeof setInterval> | null = null;

  function startRealTimeUpdates(userId: string) {
    // Clear any existing interval
    if (realTimeUpdateInterval) {
      clearInterval(realTimeUpdateInterval);
    }

    // Update stats every 30 seconds to reflect ongoing timer progress
    realTimeUpdateInterval = setInterval(async () => {
      try {
        // Update today's stats using the same API as Timer component
        const today = new Date();
        const startOfToday = new Date(today);
        startOfToday.setHours(0, 0, 0, 0);
        const endOfToday = new Date(today);
        endOfToday.setHours(23, 59, 59, 999);
        
        const todayStatsResponse = await fetch(`/api/reports/daily-duration-totals?userId=${encodeURIComponent(userId)}&startDate=${encodeURIComponent(startOfToday.toISOString())}&endDate=${encodeURIComponent(endOfToday.toISOString())}`);
        if (todayStatsResponse.ok) {
          const todayStatsData = await todayStatsResponse.json();
          updateTodayStats(todayStatsData, true);
        }

        // Update weekly stats using the same API as Timer component
        const now = new Date();
        const dayOfWeek = now.getDay();
        const daysToSubtract = dayOfWeek === 0 ? 0 : dayOfWeek;
        const weekStart = new Date(now);
        weekStart.setDate(now.getDate() - daysToSubtract);
        weekStart.setHours(0, 0, 0, 0);
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekStart.getDate() + 6);
        weekEnd.setHours(23, 59, 59, 999);
        
        const statsResponse = await fetch(`/api/reports/daily-duration-totals?userId=${encodeURIComponent(userId)}&startDate=${encodeURIComponent(weekStart.toISOString())}&endDate=${encodeURIComponent(weekEnd.toISOString())}`);
        if (statsResponse.ok) {
          const statsData = await statsResponse.json();
          updateWeeklyStats(statsData, true);
        }
      } catch (error) {
        console.error('Error updating real-time stats:', error);
      }
    }, 30000); // Update every 30 seconds
  }

  function stopRealTimeUpdates() {
    if (realTimeUpdateInterval) {
      clearInterval(realTimeUpdateInterval);
      realTimeUpdateInterval = null;
    }
  }

  // Stop real-time updates when page is hidden or user navigates away
  document.addEventListener('visibilitychange', async () => {
    if (document.hidden) {
      stopRealTimeUpdates();
    } else {
      // Restart updates when page becomes visible again
      const userId = await getCurrentUserId();
      if (userId) {
        startRealTimeUpdates(userId);
      }
    }
  });

  // Logout functionality
  async function performLogout() {
    try {
      // Get current user ID and clear only their timer state
      const userId = await getCurrentUserId();
      if (userId) {
        const timerStateKey = `timerState_${userId}`;
        localStorage.removeItem(timerStateKey);
      }

      const response = await fetch('/api/auth/logout', {
        method: 'POST',
      });
      
      if (response.ok) {
        window.location.href = '/';
      }
    } catch (error) {
      console.error('Logout error:', error);
    }
  }

  // Desktop logout (if it still exists)
  document.getElementById('logoutButton')?.addEventListener('click', performLogout);

  // Load data when page loads
  document.addEventListener('DOMContentLoaded', loadDashboardData);


  // Add event listeners for stop timer buttons
  document.addEventListener('click', async (e) => {
    const target = e.target as HTMLElement;
    const stopBtn = target.closest('.stop-timer-btn') as HTMLElement;
    
    if (stopBtn) {
      const timerId = stopBtn.getAttribute('data-timer-id');
      const userId = stopBtn.getAttribute('data-user-id');
      
      if (timerId && userId) {
        if (confirm('Are you sure you want to stop this timer?')) {
          try {
            const response = await fetch('/api/timers/ongoing', {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ 
                timerId: parseInt(timerId),
                clientTime: new Date().getTime() // Send client's current time as timestamp to preserve timezone
              }),
            });

            if (response.ok) {
              // Reload dashboard data to update the display
              loadDashboardData();
              // Dispatch custom event to notify timer components
              window.dispatchEvent(new CustomEvent('timerStopped'));
            }
          } catch (error) {
            console.error('Error stopping timer:', error);
          }
        }
      }
    }
  });

  // Cleanup intervals when page unloads
  window.addEventListener('beforeunload', stopTimerDurationUpdates);





  // Listen for timer started events to refresh the dashboard
  window.addEventListener('timerStarted', () => {
    // Reload dashboard data when a timer is started
    loadDashboardData();
  });

  // Listen for timer stopped events to refresh the dashboard
  window.addEventListener('timerStopped', () => {
    // Reload dashboard data when a timer is stopped
    loadDashboardData();
  });

  // Listen for timer data refresh events
  window.addEventListener('timerDataRefreshed', (event: Event) => {
    const customEvent = event as CustomEvent;
    console.log('üîÑ [DASHBOARD DEBUG] Timer data refreshed event received:', customEvent.detail);
    // Reload dashboard data when timer data is refreshed
    loadDashboardData();
  });

  // Listen for real-time timer updates
  window.addEventListener('timerRealTimeUpdate', async (event: Event) => {
    const customEvent = event as CustomEvent;
    const timerData = customEvent.detail;
    
    // Update current timer state
    currentTimerState = timerData;
    
    // Update today's stats with real-time timer data
    if (currentTimerState && currentTimerState.isRunning) {
      try {
        // Get current stats and update with real-time data
        const today = new Date();
        const startOfToday = new Date(today);
        startOfToday.setHours(0, 0, 0, 0);
        const endOfToday = new Date(today);
        endOfToday.setHours(23, 59, 59, 999);
        
        const userId = await getCurrentUserId();
        const todayStatsResponse = await fetch(`/api/reports/daily-duration-totals?userId=${encodeURIComponent(userId)}&startDate=${encodeURIComponent(startOfToday.toISOString())}&endDate=${encodeURIComponent(endOfToday.toISOString())}`);
        if (todayStatsResponse.ok) {
          const stats = await todayStatsResponse.json();
          updateTodayStats(stats, true);
        }
        
        // Update weekly stats with real-time timer data
        const now = new Date();
        const dayOfWeek = now.getDay();
        const daysToSubtract = dayOfWeek === 0 ? 0 : dayOfWeek;
        const weekStart = new Date(now);
        weekStart.setDate(now.getDate() - daysToSubtract);
        weekStart.setHours(0, 0, 0, 0);
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekStart.getDate() + 6);
        weekEnd.setHours(23, 59, 59, 999);
        
        const weeklyStatsResponse = await fetch(`/api/reports/daily-duration-totals?userId=${encodeURIComponent(userId)}&startDate=${encodeURIComponent(weekStart.toISOString())}&endDate=${encodeURIComponent(weekEnd.toISOString())}`);
        if (weeklyStatsResponse.ok) {
          const stats = await weeklyStatsResponse.json();
          updateWeeklyStats(stats, true);
        }
      } catch (error) {
        console.error('Error updating real-time stats:', error);
      }
    } else {
      // Timer stopped, refresh data normally
      loadDashboardData();
    }
  });

  // Attach listeners for time entry changes (add/update/delete) once
  (function attachTimeEntryChangeListeners() {
    const root = document.documentElement;
    const attrName = 'data-listeners-attached';
    if (root.getAttribute(attrName) === 'true') return;

    const refreshOnChange = () => {
      // Keep dashboard recent entries and totals in sync
      loadDashboardData();
    };

    window.addEventListener('timeEntryAdded', refreshOnChange);
    window.addEventListener('timeEntryUpdated', refreshOnChange);
    window.addEventListener('timeEntryDeleted', refreshOnChange);

    root.setAttribute(attrName, 'true');
  })();

  // Listen for timer layout mode changes to adjust dashboard layout
  window.addEventListener('timerLayoutModeChanged', (event: Event) => {
    const customEvent = event as CustomEvent;
    const layoutMode = customEvent.detail?.mode;
    const dashboardGrid = document.getElementById('dashboardGrid');
    const mainContent = document.getElementById('mainContent');
    const sidebar = document.getElementById('sidebar');
    
    if (layoutMode === 'list') {
      // Smoothly hide sidebar and make main content full width
      if (sidebar) {
        sidebar.style.opacity = '0';
        sidebar.style.transform = 'translateX(100%)';
        // Hide after transition completes
        setTimeout(() => {
          sidebar.style.display = 'none';
        }, 500);
      }
      // Delay grid layout change slightly to allow sidebar animation to start
      setTimeout(() => {
        if (dashboardGrid) {
          dashboardGrid.className = 'grid grid-cols-1 gap-2 sm:gap-4 lg:gap-8 transition-all duration-500 ease-in-out';
        }
        if (mainContent) {
          mainContent.className = 'space-y-2 sm:space-y-4 lg:space-y-8 transition-all duration-500 ease-in-out';
        }
      }, 50);
    } else {
      // Smoothly show sidebar and restore original layout
      if (sidebar) {
        sidebar.style.display = '';
        // Force reflow to ensure display change takes effect
        sidebar.offsetHeight;
        sidebar.style.opacity = '1';
        sidebar.style.transform = 'translateX(0)';
      }
      // Delay grid layout change slightly to allow sidebar animation to start
      setTimeout(() => {
        if (dashboardGrid) {
          dashboardGrid.className = 'grid grid-cols-1 lg:grid-cols-3 lg:gap-8 sm:gap-4 gap-2 transition-all duration-500 ease-in-out';
        }
        if (mainContent) {
          mainContent.className = 'lg:col-span-2 lg:space-y-8 sm:space-y-4 space-y-2 transition-all duration-500 ease-in-out';
        }
      }, 50);
    }
  });

  // Refresh button functionality
  document.getElementById('refreshEntriesBtn')?.addEventListener('click', async () => {
    const refreshBtn = document.getElementById('refreshEntriesBtn') as HTMLButtonElement;
    if (refreshBtn) {
      // Add visual feedback
      refreshBtn.disabled = true;
      refreshBtn.innerHTML = `
        <svg class="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
        <span>Refreshing...</span>
      `;
    }
    
    try {
      await loadDashboardData();
    } finally {
      // Restore button state
      if (refreshBtn) {
        refreshBtn.disabled = false;
        refreshBtn.innerHTML = `
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
          </svg>
          <span>Refresh</span>
        `;
      }
    }
  });



  // All Entries button functionality
  document.getElementById('viewAllEntriesBtn')?.addEventListener('click', () => {
    window.location.href = '/time-entries';
  });

  // View Reports button functionality
  document.getElementById('viewReportsBtn')?.addEventListener('click', () => {
    window.location.href = '/admin';
  });

  // Time Entry Modal Functionality
  const addTimeEntryBtn = document.getElementById('addTimeEntryBtn');
  const timeEntryModal = document.getElementById('timeEntryModal');
  const timeEntryForm = document.getElementById('timeEntryForm');
  const cancelTimeEntryBtn = document.getElementById('cancelTimeEntryBtn');
  const timeEntryTask = document.getElementById('timeEntryTask');
  const timeEntryTaskId = document.getElementById('timeEntryTaskId');
  const taskDropdown = document.getElementById('taskDropdown');

  // Show modal when Add Manual Time Entry button is clicked
  if (addTimeEntryBtn) {
    addTimeEntryBtn.addEventListener('click', async () => {
      // Check if there are any ongoing timers before opening modal
      try {
        const response = await fetch('/api/timers/ongoing');
        if (response.ok) {
          const result = await response.json();
          if (result.success && result.data) {
            alert('Please stop the current timer before adding manual entries.');
            return;
          }
        }
      } catch (error) {
        console.error('Error checking timer state:', error);
      }

      if (timeEntryModal) {
        timeEntryModal.classList.remove('hidden');
        // Set default date to today for both date inputs
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        const todayString = `${year}-${month}-${day}`;
        
        const durationDateInput = document.getElementById('timeEntryDate') as HTMLInputElement;
        const timesDateInput = document.getElementById('manualTimesDate') as HTMLInputElement;
        
        if (durationDateInput) {
          durationDateInput.value = todayString;
        }
        if (timesDateInput) {
          timesDateInput.value = todayString;
        }
      }
    });
  }

  // Handle radio button switching for entry method
  document.addEventListener('change', (e) => {
    const target = e.target as HTMLInputElement;
    if (target.name === 'entryMethod') {
      const timesSection = document.getElementById('manualTimesSection');
      const durationSection = document.getElementById('manualDurationSection');
      
      if (target.value === 'times') {
        timesSection?.classList.remove('hidden');
        durationSection?.classList.add('hidden');
      } else if (target.value === 'duration') {
        timesSection?.classList.add('hidden');
        durationSection?.classList.remove('hidden');
      }
    }
  });

  // Close modal when Cancel button is clicked
  if (cancelTimeEntryBtn) {
    cancelTimeEntryBtn.addEventListener('click', closeTimeEntryModal);
  }

  // Close modal when clicking outside
  document.addEventListener('click', (e) => {
    if (timeEntryModal && e.target === timeEntryModal) {
      closeTimeEntryModal();
    }
  });

  // Close modal with Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && timeEntryModal && !timeEntryModal.classList.contains('hidden')) {
      closeTimeEntryModal();
    }
  });

  function closeTimeEntryModal() {
    if (timeEntryModal) {
      timeEntryModal.classList.add('hidden');
      if (timeEntryForm && timeEntryForm instanceof HTMLFormElement) {
        timeEntryForm.reset();
      }
      if (timeEntryTaskId && timeEntryTaskId instanceof HTMLInputElement) {
        timeEntryTaskId.value = '';
      }
      if (taskDropdown) {
        taskDropdown.classList.add('hidden');
      }
      
      // Reset radio button to default selection (times)
      const timesRadio = document.querySelector('input[name="entryMethod"][value="times"]') as HTMLInputElement;
      if (timesRadio) {
        timesRadio.checked = true;
      }
      
      // Ensure correct sections are shown
      const timesSection = document.getElementById('manualTimesSection');
      const durationSection = document.getElementById('manualDurationSection');
      timesSection?.classList.remove('hidden');
      durationSection?.classList.add('hidden');
    }
  }

  // Enhanced task search functionality
  let taskSearchTimeout: NodeJS.Timeout;
  let taskDropdownOpen = false;

  // Flexible time parser for natural human shorthand formats
  function parseFlexibleTime(timeString: string): { hours: number; minutes: number } | null {
    if (!timeString) return null;
    
    const trimmed = timeString.trim().toLowerCase();
    
    // Remove any extra spaces and normalize
    const normalized = trimmed.replace(/\s+/g, '');
    
    // Pattern 1: "3p", "3pm", "3PM" -> 3:00 PM
    let match = normalized.match(/^(\d{1,2})(p|pm)$/);
    if (match) {
      let hours = parseInt(match[1]);
      if (hours >= 1 && hours <= 12) {
        if (hours !== 12) hours += 12; // Convert to 24-hour format
        return { hours, minutes: 0 };
      }
    }
    
    // Pattern 2: "3a", "3am", "3AM" -> 3:00 AM
    match = normalized.match(/^(\d{1,2})(a|am)$/);
    if (match) {
      let hours = parseInt(match[1]);
      if (hours >= 1 && hours <= 12) {
        if (hours === 12) hours = 0; // 12 AM = 0:00
        return { hours, minutes: 0 };
      }
    }
    
    // Pattern 3: "300p", "300pm", "300PM" -> 3:00 PM
    match = normalized.match(/^(\d{1,2})(\d{2})(p|pm)$/);
    if (match) {
      let hours = parseInt(match[1]);
      const minutes = parseInt(match[2]);
      if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
        if (hours !== 12) hours += 12;
        return { hours, minutes };
      }
    }
    
    // Pattern 4: "300a", "300am", "300AM" -> 3:00 AM
    match = normalized.match(/^(\d{1,2})(\d{2})(a|am)$/);
    if (match) {
      let hours = parseInt(match[1]);
      const minutes = parseInt(match[2]);
      if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
        if (hours === 12) hours = 0;
        return { hours, minutes };
      }
    }
    
    // Pattern 5: "3000p", "3000pm", "3000PM" -> 3:00 PM (4 digits)
    match = normalized.match(/^(\d{1,2})(\d{2})(p|pm)$/);
    if (match) {
      let hours = parseInt(match[1]);
      const minutes = parseInt(match[2]);
      if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
        if (hours !== 12) hours += 12;
        return { hours, minutes };
      }
    }
    
    // Pattern 6: "3000a", "3000am", "3000AM" -> 3:00 AM (4 digits)
    match = normalized.match(/^(\d{1,2})(\d{2})(a|am)$/);
    if (match) {
      let hours = parseInt(match[1]);
      const minutes = parseInt(match[2]);
      if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
        if (hours === 12) hours = 0;
        return { hours, minutes };
      }
    }
    
    // Pattern 7: "3:30p", "3:30pm", "3:30PM" -> 3:30 PM
    match = normalized.match(/^(\d{1,2}):(\d{2})(p|pm)$/);
    if (match) {
      let hours = parseInt(match[1]);
      const minutes = parseInt(match[2]);
      if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
        if (hours !== 12) hours += 12;
        return { hours, minutes };
      }
    }
    
    // Pattern 8: "3:30a", "3:30am", "3:30AM" -> 3:30 AM
    match = normalized.match(/^(\d{1,2}):(\d{2})(a|am)$/);
    if (match) {
      let hours = parseInt(match[1]);
      const minutes = parseInt(match[2]);
      if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
        if (hours === 12) hours = 0;
        return { hours, minutes };
      }
    }
    
    // Pattern 9: "3:30 p", "3:30 pm", "3:30 PM" (with space)
    match = normalized.match(/^(\d{1,2}):(\d{2})\s*(p|pm)$/);
    if (match) {
      let hours = parseInt(match[1]);
      const minutes = parseInt(match[2]);
      if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
        if (hours !== 12) hours += 12;
        return { hours, minutes };
      }
    }
    
    // Pattern 10: "3:30 a", "3:30 am", "3:30 AM" (with space)
    match = normalized.match(/^(\d{1,2}):(\d{2})\s*(a|am)$/);
    if (match) {
      let hours = parseInt(match[1]);
      const minutes = parseInt(match[2]);
      if (hours >= 1 && hours <= 12 && minutes >= 0 && minutes <= 59) {
        if (hours === 12) hours = 0;
        return { hours, minutes };
      }
    }
    
    // Pattern 11: "12:00pm", "12:00am" (noon/midnight)
    match = normalized.match(/^12:(\d{2})(p|pm)$/);
    if (match) {
      const minutes = parseInt(match[1]);
      if (minutes >= 0 && minutes <= 59) {
        return { hours: 12, minutes }; // 12 PM = 12:00
      }
    }
    
    match = normalized.match(/^12:(\d{2})(a|am)$/);
    if (match) {
      const minutes = parseInt(match[1]);
      if (minutes >= 0 && minutes <= 59) {
        return { hours: 0, minutes }; // 12 AM = 0:00
      }
    }
    
    return null; // No pattern matched
  }

  // Flexible duration parser for natural human formats
  function parseFlexibleDuration(durationString: string): number | null {
    if (!durationString) return null;
    
    const trimmed = durationString.trim().toLowerCase();
    
    // Remove any extra spaces and normalize
    const normalized = trimmed.replace(/\s+/g, ' ');
    
    // Pattern 1: "2h 30m", "2h 30min", "2 hours 30 minutes"
    let match = normalized.match(/^(\d+(?:\.\d+)?)\s*(h|hr|hours?)\s+(\d+)\s*(m|min|minutes?)$/);
    if (match) {
      const hours = parseFloat(match[1]);
      const minutes = parseInt(match[3]);
      if (hours >= 0 && minutes >= 0 && minutes <= 59) {
        return Math.floor(hours * 3600 + minutes * 60);
      }
    }
    
    // Pattern 2: "2h", "2hr", "2 hours"
    match = normalized.match(/^(\d+(?:\.\d+)?)\s*(h|hr|hours?)$/);
    if (match) {
      const hours = parseFloat(match[1]);
      if (hours >= 0) {
        return Math.floor(hours * 3600);
      }
    }
    
    // Pattern 3: "150m", "150min", "150 minutes"
    match = normalized.match(/^(\d+(?:\.\d+)?)\s*(m|min|minutes?)$/);
    if (match) {
      const minutes = parseFloat(match[1]);
      if (minutes >= 0) {
        return Math.floor(minutes * 60);
      }
    }
    
    // Pattern 4: "2:30" (hours:minutes)
    match = normalized.match(/^(\d+):(\d{2})$/);
    if (match) {
      const hours = parseInt(match[1]);
      const minutes = parseInt(match[2]);
      if (hours >= 0 && minutes >= 0 && minutes <= 59) {
        return hours * 3600 + minutes * 60;
      }
    }
    
    // Pattern 5: "5400s", "5400sec", "5400 seconds"
    match = normalized.match(/^(\d+)\s*(s|sec|seconds?)$/);
    if (match) {
      const seconds = parseInt(match[1]);
      if (seconds >= 0) {
        return seconds;
      }
    }
    
    return null; // No pattern matched
  }

  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    const target = e.target as Element;
    if (!target.closest('#timeEntryTask') && !target.closest('#taskDropdown') && !target.closest('#taskDropdownArrow')) {
      hideTaskDropdown();
    }
    if (!target.closest('#editTimeEntryTask') && !target.closest('#editTaskDropdown') && !target.closest('#editTaskDropdownArrow')) {
      hideEditTaskDropdown();
    }
  });
  
  // Task search functions
  function handleTaskSearch(searchTerm: string) {
    clearTimeout(taskSearchTimeout);
    
    if (searchTerm.length < 1) {
      searchAllTasks();
      return;
    }
    
    taskSearchTimeout = setTimeout(() => {
      searchTasks(searchTerm);
    }, 300);
  }
  
  function toggleTaskDropdown() {
    const searchInput = document.getElementById('timeEntryTask');
    console.log('toggleTaskDropdown called, searchInput:', searchInput, 'taskDropdownOpen:', taskDropdownOpen);
    if (!searchInput) return;
    
    if (taskDropdownOpen) {
      hideTaskDropdown();
    } else {
      searchAllTasks();
      showTaskDropdown();
    }
  }
  
  async function searchTasks(searchTerm: string) {
    try {
      const userId = await getCurrentUserId();
      if (!userId) {
        console.error('No user ID available for project search');
        return;
      }

      // Fetch projects for the user
      const projectsResponse = await fetch(`/api/projects?userId=${encodeURIComponent(userId)}&limit=500`, { 
        signal: AbortSignal.timeout(10000) // 10 second timeout
      });

      let allProjects: any[] = [];

      if (projectsResponse.ok) {
        const projectData = await projectsResponse.json();
        allProjects = [...(projectData.data || [])];
      } else {
        console.error('Projects response failed:', projectsResponse.status);
      }
      
      // Filter projects based on search term (including client and project names)
      const filteredProjects = allProjects.filter((project: any) => 
        project.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        project.clientName.toLowerCase().includes(searchTerm.toLowerCase())
      );

      displayTaskDropdown(filteredProjects);
    } catch (error) {
      console.error('Error searching projects:', error);
    }
  }
  
  async function searchAllTasks() {
    try {
      const userId = await getCurrentUserId();
      if (!userId) {
        console.error('No user ID available for project search');
        return;
      }

      console.log('searchAllProjects called for user:', userId);

      // Fetch projects for the user
      const projectsResponse = await fetch(`/api/projects?userId=${encodeURIComponent(userId)}&limit=500`, { 
        signal: AbortSignal.timeout(10000) // 10 second timeout
      });

      let allProjects: any[] = [];

      if (projectsResponse.ok) {
        const projectData = await projectsResponse.json();
        console.log('Projects response:', projectData);
        allProjects = [...(projectData.data || [])];
      } else {
        console.error('Projects response failed:', projectsResponse.status);
      }

      console.log('All projects:', allProjects);
      displayTaskDropdown(allProjects);
    } catch (error) {
      console.error('Error loading all projects:', error);
    }
  }
  
  function showTaskDropdown() {
    const dropdown = document.getElementById('taskDropdown');
    const arrow = document.getElementById('taskDropdownArrow');
    console.log('showTaskDropdown called, dropdown element:', dropdown);
    if (dropdown) {
      dropdown.classList.remove('hidden');
      taskDropdownOpen = true;
      console.log('Task dropdown shown, taskDropdownOpen:', taskDropdownOpen);
      searchAllTasks(); // Load tasks when showing dropdown
    }
    if (arrow) {
      arrow.style.transform = 'rotate(180deg)';
    }
  }
  
  function hideTaskDropdown() {
    const dropdown = document.getElementById('taskDropdown');
    const arrow = document.getElementById('taskDropdownArrow');
    if (dropdown) {
      dropdown.classList.add('hidden');
      taskDropdownOpen = false;
    }
    if (arrow) {
      arrow.style.transform = 'rotate(0deg)';
    }
  }
  
  // Edit Task Search Functions
  let editTaskSearchTimeout: NodeJS.Timeout;
  let editTaskDropdownOpen = false;

  function handleEditTaskSearch(searchTerm: string) {
    clearTimeout(editTaskSearchTimeout);
    
    if (searchTerm.length < 1) {
      searchAllEditTasks();
      return;
    }
    
    editTaskSearchTimeout = setTimeout(() => {
      searchEditTasks(searchTerm);
    }, 300);
  }

  async function searchEditTasks(searchTerm: string) {
    try {
      const userId = await getCurrentUserId();
      if (!userId) {
        console.error('No user ID available for project search');
        return;
      }

      // Fetch projects for the user
      const projectsResponse = await fetch(`/api/projects?userId=${encodeURIComponent(userId)}&limit=500`);

      let allProjects: any[] = [];

      if (projectsResponse.ok) {
        const projectData = await projectsResponse.json();
        allProjects = [...(projectData.data || [])];
      }

      // Filter projects based on search term
      const filteredProjects = allProjects.filter(project =>
        project.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        project.clientName.toLowerCase().includes(searchTerm.toLowerCase())
      );

      displayEditTaskDropdown(filteredProjects);
    } catch (error) {
      console.error('Error searching projects:', error);
    }
  }

  async function searchAllEditTasks() {
    try {
      const userId = await getCurrentUserId();
      if (!userId) {
        console.error('No user ID available for project search');
        return;
      }

      console.log('Searching all edit projects for user:', userId);

      // Fetch projects for the user
      const projectsResponse = await fetch(`/api/projects?userId=${encodeURIComponent(userId)}&limit=500`, { 
        signal: AbortSignal.timeout(10000) // 10 second timeout
      });

      let allProjects: any[] = [];

      if (projectsResponse.ok) {
        const projectData = await projectsResponse.json();
        console.log('Projects response:', projectData);
        allProjects = [...(projectData.data || [])];
      } else {
        console.error('Projects response failed:', projectsResponse.status);
      }

      console.log('All projects:', allProjects);
      displayEditTaskDropdown(allProjects);
    } catch (error) {
      console.error('Error fetching all projects:', error);
    }
  }

  function showEditTaskDropdown() {
    const editTaskDropdown = document.getElementById('editTaskDropdown');
    const editTaskDropdownArrow = document.getElementById('editTaskDropdownArrow');
    if (editTaskDropdown) {
      editTaskDropdown.classList.remove('hidden');
      editTaskDropdownOpen = true;
      searchAllEditTasks();
    }
    if (editTaskDropdownArrow) {
      editTaskDropdownArrow.style.transform = 'rotate(180deg)';
    }
  }

  function hideEditTaskDropdown() {
    const editTaskDropdown = document.getElementById('editTaskDropdown');
    const editTaskDropdownArrow = document.getElementById('editTaskDropdownArrow');
    if (editTaskDropdown) {
      editTaskDropdown.classList.add('hidden');
      editTaskDropdownOpen = false;
    }
    if (editTaskDropdownArrow) {
      editTaskDropdownArrow.style.transform = 'rotate(0deg)';
    }
  }

  function toggleEditTaskDropdown() {
    if (editTaskDropdownOpen) {
      hideEditTaskDropdown();
    } else {
      showEditTaskDropdown();
    }
  }

  function displayEditTaskDropdown(projects: any[]) {
    const editTaskDropdown = document.getElementById('editTaskDropdown');
    if (!editTaskDropdown) return;

    console.log('Displaying edit project dropdown with projects:', projects);

    if (projects.length === 0) {
      editTaskDropdown.innerHTML = '<div class="px-3 py-2 text-gray-500 text-sm">No projects found</div>';
      editTaskDropdown.classList.remove('hidden');
      return;
    }

    // Group projects by client for better organization
    const projectsByClient: { [key: string]: any[] } = {};
    projects.forEach(project => {
      const clientName = project.clientName || 'Unknown Client';
      if (!projectsByClient[clientName]) {
        projectsByClient[clientName] = [];
      }
      projectsByClient[clientName].push(project);
    });

    let dropdownHTML = '';
    
    Object.keys(projectsByClient).forEach(clientName => {
      const clientProjects = projectsByClient[clientName];
      
      // Add client header
      dropdownHTML += `
        <div class="px-3 py-2 bg-gray-50 text-xs font-semibold text-gray-600 uppercase tracking-wide border-b border-gray-200">
          ${clientName}
        </div>
      `;
      
      // Add projects for this client
      clientProjects.forEach(project => {
        dropdownHTML += `
          <div 
            class="px-3 py-2 hover:bg-gray-100 cursor-pointer text-sm pl-6 border-b border-gray-100 last:border-b-0"
            onclick="selectEditTask(${project.id}, '${project.name.replace(/'/g, "\\'")}', '${project.clientName.replace(/'/g, "\\'")}')"
          >
            <div class="font-medium text-gray-900">${project.name}</div>
            <div class="text-xs text-gray-500">${project.clientName}</div>
          </div>
        `;
      });
    });

    editTaskDropdown.innerHTML = dropdownHTML;
    editTaskDropdown.classList.remove('hidden');
  }

  function selectEditTask(projectId: number, projectName: string, clientName: string) {
    const editTaskInput = document.getElementById('editTimeEntryTask') as HTMLInputElement;
    const editTaskIdInput = document.getElementById('editTimeEntryTaskId') as HTMLInputElement;
    
    if (editTaskInput && editTaskIdInput) {
      editTaskInput.value = `${projectName} (${clientName})`;
      editTaskIdInput.value = projectId.toString();
      hideEditTaskDropdown();
    }
  }

  // Make functions available globally for HTML event handlers
  (window as any).handleTaskSearch = handleTaskSearch;
  (window as any).toggleTaskDropdown = toggleTaskDropdown;
  (window as any).searchTasks = searchTasks;
  (window as any).searchAllTasks = searchAllTasks;
  (window as any).showTaskDropdown = showTaskDropdown;
  (window as any).hideTaskDropdown = hideTaskDropdown;
  
  // Edit task functions
  (window as any).handleEditTaskSearch = handleEditTaskSearch;
  (window as any).toggleEditTaskDropdown = toggleEditTaskDropdown;
  (window as any).searchEditTasks = searchEditTasks;
  (window as any).searchAllEditTasks = searchAllEditTasks;
  (window as any).showEditTaskDropdown = showEditTaskDropdown;
  (window as any).hideEditTaskDropdown = hideEditTaskDropdown;
  (window as any).selectEditTask = selectEditTask;
  
  function displayTaskDropdown(projects: any[]) {
    const taskDropdown = document.getElementById('taskDropdown');
    if (!taskDropdown) return;

    console.log('Displaying project dropdown with projects:', projects);

    if (projects.length === 0) {
      taskDropdown.innerHTML = '<div class="px-3 py-2 text-gray-500 text-sm">No projects found</div>';
      taskDropdown.classList.remove('hidden');
      return;
    }

    // Group projects by client for better organization
    const projectsByClient: { [key: string]: any[] } = {};
    projects.forEach(project => {
      const clientName = project.clientName || 'Unknown Client';
      if (!projectsByClient[clientName]) {
        projectsByClient[clientName] = [];
      }
      projectsByClient[clientName].push(project);
    });

    let dropdownHTML = '';
    
    Object.keys(projectsByClient).forEach(clientName => {
      const clientProjects = projectsByClient[clientName];
      
      // Add client header
      dropdownHTML += `
        <div class="px-3 py-2 bg-gray-50 text-xs font-semibold text-gray-600 uppercase tracking-wide border-b border-gray-200">
          ${clientName}
        </div>
      `;
      
      // Add projects for this client
      clientProjects.forEach(project => {
        dropdownHTML += `
          <div 
            class="px-3 py-2 hover:bg-gray-100 cursor-pointer text-sm pl-6 border-b border-gray-100 last:border-b-0"
            data-project-id="${project.id}"
            data-project-name="${project.name}"
            data-client-name="${project.clientName}"
          >
            <div class="font-medium text-gray-900">${project.name}</div>
            <div class="text-xs text-gray-600">${project.clientName}</div>
          </div>
        `;
      });
    });

    taskDropdown.innerHTML = dropdownHTML;
    taskDropdown.classList.remove('hidden');

    // Add click handlers to project items
    taskDropdown.querySelectorAll('[data-project-id]').forEach((item: Element) => {
      item.addEventListener('click', () => {
        const projectId = item.getAttribute('data-project-id');
        const projectName = item.getAttribute('data-project-name');
        const clientName = item.getAttribute('data-client-name');

        const timeEntryTask = document.getElementById('timeEntryTask') as HTMLInputElement;
        const timeEntryTaskId = document.getElementById('timeEntryTaskId') as HTMLInputElement;
        
        if (timeEntryTask) {
          timeEntryTask.value = `${clientName} - ${projectName}`;
        }
        if (timeEntryTaskId) {
          timeEntryTaskId.value = projectId || '';
        }
        
        hideTaskDropdown();
      });
    });
  }
  


  // Debounce function
  function debounce(func: Function, wait: number) {
    let timeout: NodeJS.Timeout;
    return function executedFunction(...args: any[]) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // Handle form submission
  if (timeEntryForm) {
    timeEntryForm.addEventListener('submit', async (e: Event) => {
      e.preventDefault();
      
      const target = e.target as HTMLFormElement;
      const submitButton = target.querySelector('button[type="submit"]') as HTMLButtonElement;
      const saveButtonText = document.getElementById('saveButtonText') as HTMLSpanElement;
      const saveButtonSpinner = document.getElementById('saveButtonSpinner') as HTMLElement;
      const originalText = saveButtonText.textContent;
      
      // Show loading state
      submitButton.disabled = true;
      saveButtonText.textContent = 'Saving...';
      saveButtonSpinner.classList.remove('hidden');
      
      const projectId = timeEntryTaskId instanceof HTMLInputElement ? timeEntryTaskId.value : '';
      const notesInput = document.getElementById('timeEntryNotes') as HTMLTextAreaElement;
      const notes = notesInput?.value;
      
      // Get selected entry method
      const selectedMethod = document.querySelector('input[name="entryMethod"]:checked') as HTMLInputElement;
      const entryMethod = selectedMethod?.value;
      
      if (!projectId || !entryMethod) {
        alert('Please fill in all required fields');
        submitButton.disabled = false;
        saveButtonText.textContent = originalText;
        saveButtonSpinner.classList.add('hidden');
        return;
      }

      try {
        const userId = await getCurrentUserId();
        if (!userId) {
          throw new Error('No user ID available');
        }

        let requestBody: any = {
          userId: parseInt(userId),
          projectId: parseInt(projectId),
          taskId: parseInt(projectId), // Map UI project selection to taskId expected by service
          notes: notes || null
        };

        if (entryMethod === 'duration') {
          // Manual duration entry
          const durationInput = document.getElementById('timeEntryDuration') as HTMLInputElement;
          const taskDateInput = document.getElementById('timeEntryDate') as HTMLInputElement;
          
          const duration = durationInput?.value;
          const taskDate = taskDateInput?.value;
          
          if (!duration || !taskDate) {
            alert('Please fill in duration and task date');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          
          requestBody.duration = duration;
          requestBody.taskDate = taskDate;
          
        } else if (entryMethod === 'times') {
          // Start/end times entry
          const startTimeInput = document.getElementById('manualStartTime') as HTMLInputElement;
          const endTimeInput = document.getElementById('manualEndTime') as HTMLInputElement;
          const taskDateInput = document.getElementById('manualTimesDate') as HTMLInputElement;
          
          const startTime = startTimeInput?.value;
          const endTime = endTimeInput?.value;
          const taskDate = taskDateInput?.value;
          
          if (!startTime || !endTime || !taskDate) {
            alert('Please fill in start time, end time, and task date');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          
          // Parse times and create start/end datetime objects
          const startParsedTime = parseFlexibleTime(startTime);
          const endParsedTime = parseFlexibleTime(endTime);
          
          if (!startParsedTime || !endParsedTime) {
            alert('Please enter valid time formats (e.g., 9:30 AM, 5:30 PM)');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          
          // Parse date components to avoid timezone shifts
          const [year, month, day] = taskDate.split('-').map(Number);
          const startDateTime = new Date(year, month - 1, day, startParsedTime.hours, startParsedTime.minutes, 0, 0);
          const endDateTime = new Date(year, month - 1, day, endParsedTime.hours, endParsedTime.minutes, 0, 0);
          
          // Validate that end time is after start time
          if (endDateTime <= startDateTime) {
            alert('End time must be after start time');
            submitButton.disabled = false;
            saveButtonText.textContent = originalText;
            saveButtonSpinner.classList.add('hidden');
            return;
          }
          
          // Use ISO strings like the inline editing approach
          requestBody.startTime = startDateTime.toISOString();
          requestBody.endTime = endDateTime.toISOString();
        }

        const response = await fetch('/api/time-entries-unified', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody),
        });
        
        if (response.ok) {
          // Show success message
          saveButtonText.textContent = 'Saved!';
          submitButton.classList.add('bg-gray-800');
          saveButtonSpinner.classList.add('hidden');
          
          // Dispatch custom event immediately to notify timer components
          window.dispatchEvent(new CustomEvent('timeEntryAdded', {
            detail: {
              timestamp: new Date().toISOString(),
              source: 'dashboard-modal'
            }
          }));
          
          // Close modal and reload data after a brief delay
          setTimeout(() => {
            closeTimeEntryModal();
            loadDashboardData(); // Reload dashboard data to show new entry
          }, 1000);
        } else {
          const errorData = await response.json();
          alert(`Error saving time entry: ${errorData.error || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error:', error);
        alert('Error saving time entry');
      } finally {
        // Reset button state
        submitButton.disabled = false;
        saveButtonText.textContent = originalText;
        submitButton.classList.remove('bg-gray-800');
        saveButtonSpinner.classList.add('hidden');
      }
    });
  }

  // Edit Time Entry Modal Functionality
  const editTimeEntryModal = document.getElementById('editTimeEntryModal');
  const editTimeEntryForm = document.getElementById('editTimeEntryForm');
  const cancelEditTimeEntryBtn = document.getElementById('cancelEditTimeEntryBtn');
  const deleteTimeEntryBtn = document.getElementById('deleteTimeEntryBtn');
  let currentEditingEntry: any = null;

  // Add event listeners for edit buttons (delegated event handling)
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    const editBtn = target.closest('.edit-time-entry-btn') as HTMLElement;
    
    if (editBtn) {
      const entryId = editBtn.getAttribute('data-entry-id');
      const entryData = editBtn.getAttribute('data-entry');
      
      if (entryId && entryData) {
        try {
          const entry = JSON.parse(entryData);
          openEditTimeEntryModal(entry);
        } catch (error) {
          console.error('Error parsing entry data:', error);
        }
      }
    }
  });

  function openEditTimeEntryModal(entry: any) {
    if (!editTimeEntryModal) return;

    // Store the current entry being edited
    currentEditingEntry = entry;

    // Populate form fields
    const entryIdInput = document.getElementById('editTimeEntryId') as HTMLInputElement;
    const editTaskInput = document.getElementById('editTimeEntryTask') as HTMLInputElement;
    const editTaskIdInput = document.getElementById('editTimeEntryTaskId') as HTMLInputElement;
    const startTimeInput = document.getElementById('editStartTime') as HTMLInputElement;
    const endTimeInput = document.getElementById('editEndTime') as HTMLInputElement;
    const durationInput = document.getElementById('editDuration') as HTMLInputElement;
    const notesInput = document.getElementById('editNotes') as HTMLTextAreaElement;
    const editTimesDateInput = document.getElementById('editTimesDate') as HTMLInputElement;
    const editDurationDateInput = document.getElementById('editDurationDate') as HTMLInputElement;

    if (entryIdInput) entryIdInput.value = entry.id;
    if (notesInput) notesInput.value = entry.notes || '';

    // Populate task information
    if (editTaskInput && editTaskIdInput) {
      editTaskInput.value = `${entry.taskName} (${entry.projectName} - ${entry.clientName})`;
      editTaskIdInput.value = entry.taskId ? entry.taskId.toString() : '';
    }

    // Check if this is a manual duration entry (has durationManual but no startTime/endTime)
    const isManualDurationEntry = entry.durationManual && !entry.startTime && !entry.endTime;
    
    // Debug logging for manual duration entries
    console.log('üîç Edit modal debug:', {
      entryId: entry.id,
      durationManual: entry.durationManual,
      startTime: entry.startTime,
      endTime: entry.endTime,
      createdAt: entry.createdAt,
      isManualDurationEntry
    });
    
    // Format time inputs (12-hour format) - only if times exist and it's not a manual duration entry
    if (startTimeInput) {
      if (entry.startTime && !isManualDurationEntry) {
        const startDate = new Date(entry.startTime);
        startTimeInput.value = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', hour12: true }).format(startDate);
      } else {
        startTimeInput.value = '';
      }
    }
    
    if (endTimeInput) {
      if (entry.endTime && !isManualDurationEntry) {
        const endDate = new Date(entry.endTime);
        endTimeInput.value = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', hour12: true }).format(endDate);
      } else {
        endTimeInput.value = '';
      }
    }

    // Set duration based on entry duration
    if (durationInput && entry.durationManual) {
      const hours = Math.floor(entry.durationManual / 3600);
      const minutes = Math.floor((entry.durationManual % 3600) / 60);
      durationInput.value = `${hours}h ${minutes}m`;
    }

    // Set date fields based on entry type
    if (entry.startTime) {
      const startDate = new Date(entry.startTime);
      const dateString = startDate.toISOString().split('T')[0];
      if (editTimesDateInput) {
        editTimesDateInput.value = dateString;
      }
    }

    if (entry.durationManual && !entry.startTime && !entry.endTime) {
      // For manual duration entries, use createdAt for date association
      const taskDate = entry.createdAt ? new Date(entry.createdAt) : new Date();
      const year = taskDate.getFullYear();
      const month = taskDate.getMonth() + 1;
      const day = taskDate.getDate();
      const dateString = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
      console.log('üîç Setting date picker for manual entry:', {
        taskDate,
        dateString,
        editDurationDateInput: !!editDurationDateInput
      });
      if (editDurationDateInput) {
        editDurationDateInput.value = dateString;
        console.log('‚úÖ Date picker value set to:', editDurationDateInput.value);
      } else {
        console.error('‚ùå editDurationDateInput not found!');
      }
    }

    // Determine which method to show based on entry type
    const timesSection = document.getElementById('timesSection');
    const durationSection = document.getElementById('durationSection');
    
    // If this is a manual duration entry, show duration method
    if (isManualDurationEntry) {
      console.log('üîç Showing duration section for manual entry');
      const durationRadio = document.querySelector('input[name="editMethod"][value="duration"]') as HTMLInputElement;
      if (durationRadio) {
        durationRadio.checked = true;
        console.log('‚úÖ Duration radio checked');
      } else {
        console.error('‚ùå Duration radio not found');
      }
      timesSection?.classList.add('hidden');
      durationSection?.classList.remove('hidden');
      console.log('‚úÖ Duration section shown, times section hidden');
    } else {
      console.log('üîç Showing times section for timer entry');
      // Default to "times" method (start/end times)
      const timesRadio = document.querySelector('input[name="editMethod"][value="times"]') as HTMLInputElement;
      if (timesRadio) {
        timesRadio.checked = true;
        console.log('‚úÖ Times radio checked');
      } else {
        console.error('‚ùå Times radio not found');
      }
      timesSection?.classList.remove('hidden');
      durationSection?.classList.add('hidden');
      console.log('‚úÖ Times section shown, duration section hidden');
    }

    // Show modal
    editTimeEntryModal.classList.remove('hidden');
  }

  function closeEditTimeEntryModal() {
    if (editTimeEntryModal) {
      editTimeEntryModal.classList.add('hidden');
      currentEditingEntry = null; // Clear the stored entry
      if (editTimeEntryForm && editTimeEntryForm instanceof HTMLFormElement) {
        editTimeEntryForm.reset();
      }
      
      // Clear task fields
      const editTaskInput = document.getElementById('editTimeEntryTask') as HTMLInputElement;
      const editTaskIdInput = document.getElementById('editTimeEntryTaskId') as HTMLInputElement;
      if (editTaskInput) editTaskInput.value = '';
      if (editTaskIdInput) editTaskIdInput.value = '';
      
      // Hide task dropdown
      const editTaskDropdown = document.getElementById('editTaskDropdown');
      if (editTaskDropdown) {
        editTaskDropdown.classList.add('hidden');
      }
      
      // Reset radio button to default selection
      const timesRadio = document.querySelector('input[name="editMethod"][value="times"]') as HTMLInputElement;
      if (timesRadio) {
        timesRadio.checked = true;
      }
      
      // Ensure correct sections are shown
      const timesSection = document.getElementById('timesSection');
      const durationSection = document.getElementById('durationSection');
      timesSection?.classList.remove('hidden');
      durationSection?.classList.add('hidden');
    }
  }

  // Close edit modal when Cancel button is clicked
  if (cancelEditTimeEntryBtn) {
    cancelEditTimeEntryBtn.addEventListener('click', closeEditTimeEntryModal);
  }

  // Close edit modal when clicking outside
  document.addEventListener('click', (e) => {
    if (editTimeEntryModal && e.target === editTimeEntryModal) {
      closeEditTimeEntryModal();
    }
  });

  // Close edit modal with Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && editTimeEntryModal && !editTimeEntryModal.classList.contains('hidden')) {
      closeEditTimeEntryModal();
    }
  });

  // Handle edit method radio button changes
  document.addEventListener('change', (e) => {
    const target = e.target as HTMLInputElement;
    if (target.name === 'editMethod') {
      const timesSection = document.getElementById('timesSection');
      const durationSection = document.getElementById('durationSection');
      
      if (target.value === 'times') {
        timesSection?.classList.remove('hidden');
        durationSection?.classList.add('hidden');
      } else {
        timesSection?.classList.add('hidden');
        durationSection?.classList.remove('hidden');
      }
    }
  });

  // Handle edit form submission
  if (editTimeEntryForm) {
    editTimeEntryForm.addEventListener('submit', async (e: Event) => {
      e.preventDefault();
      
      const target = e.target as HTMLFormElement;
      const submitButton = target.querySelector('button[type="submit"]') as HTMLButtonElement;
      const saveButtonText = document.getElementById('saveEditButtonText') as HTMLSpanElement;
      const saveButtonSpinner = document.getElementById('saveEditButtonSpinner') as HTMLElement;
      const originalText = saveButtonText.textContent;
      
      // Show loading state
      submitButton.disabled = true;
      saveButtonText.textContent = 'Saving...';
      saveButtonSpinner.classList.remove('hidden');
      
      const entryId = document.getElementById('editTimeEntryId') as HTMLInputElement;
      const editTaskIdInput = document.getElementById('editTimeEntryTaskId') as HTMLInputElement;
      const editMethod = document.querySelector('input[name="editMethod"]:checked') as HTMLInputElement;
      const startTimeInput = document.getElementById('editStartTime') as HTMLInputElement;
      const endTimeInput = document.getElementById('editEndTime') as HTMLInputElement;
      const durationInput = document.getElementById('editDuration') as HTMLInputElement;
      const notesInput = document.getElementById('editNotes') as HTMLTextAreaElement;
      const editTimesDateInput = document.getElementById('editTimesDate') as HTMLInputElement;
      const editDurationDateInput = document.getElementById('editDurationDate') as HTMLInputElement;
      
      let updateData: any = {
        notes: notesInput?.value || null
      };

      // Add task ID if changed
      if (editTaskIdInput?.value) {
        updateData.taskId = parseInt(editTaskIdInput.value);
      }

      if (editMethod?.value === 'times') {
        if (!startTimeInput?.value || !endTimeInput?.value || !editTimesDateInput?.value) {
          alert('Please fill in start time, end time, and task date');
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          saveButtonSpinner.classList.add('hidden');
          return;
        }
        
        // Parse start time using flexible parser
        const startParsedTime = parseFlexibleTime(startTimeInput.value);
        if (!startParsedTime) {
          alert('Invalid start time format. Please use formats like 3p, 3:30pm, 12am, 300pm, etc.');
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          saveButtonSpinner.classList.add('hidden');
          return;
        }
        
        // Parse end time using flexible parser
        const endParsedTime = parseFlexibleTime(endTimeInput.value);
        if (!endParsedTime) {
          alert('Invalid end time format. Please use formats like 3p, 3:30pm, 12am, 300pm, etc.');
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          saveButtonSpinner.classList.add('hidden');
          return;
        }
        
        // Create datetime objects using the selected date
        const [taskYearStr, taskMonthStr, taskDayStr] = editTimesDateInput.value.split('-');
        const taskYear = parseInt(taskYearStr, 10);
        const taskMonth = parseInt(taskMonthStr, 10) - 1; // zero-based
        const taskDay = parseInt(taskDayStr, 10);
        const startDateTime = new Date(taskYear, taskMonth, taskDay, startParsedTime.hours, startParsedTime.minutes, 0, 0);
        const endDateTime = new Date(taskYear, taskMonth, taskDay, endParsedTime.hours, endParsedTime.minutes, 0, 0);
        
        // Validate that end time is after start time
        if (endDateTime <= startDateTime) {
          alert('End time must be after start time');
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          saveButtonSpinner.classList.add('hidden');
          return;
        }
        
        updateData.startTime = startDateTime.toISOString();
        updateData.endTime = endDateTime.toISOString();
        updateData.taskDate = editTimesDateInput.value;
        // Clear manual duration since we're now using start/end times
        updateData.durationManual = null;
      } else {
        if (!durationInput?.value || !editDurationDateInput?.value) {
          alert('Please enter duration and task date');
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          saveButtonSpinner.classList.add('hidden');
          return;
        }
        
        // Parse the duration input and convert to server format
        const parsedDuration = parseFlexibleDuration(durationInput.value);
        if (!parsedDuration) {
          alert('Please enter a valid duration format (e.g., 2h 30m, 2.5h, 150m, 2:30)');
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          saveButtonSpinner.classList.add('hidden');
          return;
        }
        
        // Convert the parsed duration to a format the server understands
        let serverDurationFormat: string;
        const hours = Math.floor(parsedDuration / 3600);
        const minutes = Math.floor((parsedDuration % 3600) / 60);
        
        if (hours > 0 && minutes > 0) {
          // For combined hours and minutes, use decimal hours format
          const totalHours = hours + (minutes / 60);
          serverDurationFormat = `${totalHours}h`;
        } else if (hours > 0) {
          // Just hours
          serverDurationFormat = `${hours}h`;
        } else {
          // Just minutes
          serverDurationFormat = `${minutes}m`;
        }
        
        updateData.duration = serverDurationFormat;
        // For manual duration entries, update createdAt instead of taskDate
        if (editDurationDateInput.value) {
          const [year, month, day] = editDurationDateInput.value.split('-').map(Number);
          const newCreatedAt = new Date(year, month - 1, day, 12, 0, 0, 0);
          updateData.createdAt = newCreatedAt.toISOString();
        }
        // Clear start and end times for manual duration entries
        updateData.startTime = null;
        updateData.endTime = null;
      }

      try {
        const response = await fetch(`/api/time-entries-unified/${entryId?.value}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(updateData),
        });
        
        if (response.ok) {
          // Show success message
          saveButtonText.textContent = 'Saved!';
          submitButton.classList.add('bg-gray-800');
          saveButtonSpinner.classList.add('hidden');
          
          // Dispatch custom event immediately to notify timer components
          window.dispatchEvent(new CustomEvent('timeEntryUpdated', {
            detail: {
              timestamp: new Date().toISOString(),
              source: 'dashboard-modal',
              entryId: entryId.value
            }
          }));
          
          // Close modal and reload data after a brief delay
          setTimeout(() => {
            closeEditTimeEntryModal();
            loadDashboardData(); // Reload dashboard data to show updated entry
          }, 1000);
        } else {
          const errorData = await response.json();
          alert(`Error updating time entry: ${errorData.error || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error:', error);
        alert('Error updating time entry');
      } finally {
        // Reset button state
        submitButton.disabled = false;
        saveButtonText.textContent = originalText;
        submitButton.classList.remove('bg-gray-800');
        saveButtonSpinner.classList.add('hidden');
      }
    });
  }

  // Handle delete time entry
  if (deleteTimeEntryBtn) {
    deleteTimeEntryBtn.addEventListener('click', async () => {
      const entryId = document.getElementById('editTimeEntryId') as HTMLInputElement;
      
      if (!entryId?.value) {
        alert('No time entry selected for deletion');
        return;
      }

      if (!confirm('Are you sure you want to delete this time entry? This action cannot be undone.')) {
        return;
      }

      try {
        const response = await fetch(`/api/time-entries-unified/${entryId.value}`, {
          method: 'DELETE',
        });
        
        if (response.ok) {
          // Dispatch custom event immediately to notify timer components
          window.dispatchEvent(new CustomEvent('timeEntryDeleted', {
            detail: {
              timestamp: new Date().toISOString(),
              source: 'dashboard-modal',
              entryId: entryId.value
            }
          }));
          
          // Close modal and reload data
          closeEditTimeEntryModal();
          loadDashboardData(); // Reload dashboard data to reflect deletion
        } else {
          const errorData = await response.json();
          alert(`Error deleting time entry: ${errorData.error || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error:', error);
        alert('Error deleting time entry');
      }
    });
  }

  // Time input handling for recent entries
  document.addEventListener('DOMContentLoaded', function() {
    // Function to handle time input changes
    function handleTimeInputChange() {
      const timeInputs = document.querySelectorAll('.time-input');
      
      timeInputs.forEach((input: Element) => {
        const timeInput = input as HTMLInputElement;
        
        // Store the original value when the input is focused
        timeInput.addEventListener('focus', function() {
          this.setAttribute('data-original-value', this.value);
        });
        
        // Handle Enter key press
        timeInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            this.blur(); // Trigger the blur event to save
          }
        });
        
        timeInput.addEventListener('blur', async function() {
          const entryId = this.getAttribute('data-entry-id');
          const timeType = this.getAttribute('data-time-type');
          const timeValue = this.value.trim();
          
          // Skip if empty or if it's the placeholder value
          if (!timeValue || timeValue === '--:-- --') return;
          
          // Skip if the value hasn't changed
          const originalValue = this.getAttribute('data-original-value');
          if (timeValue === originalValue) return;
          
          // Check if this is a manual duration entry (readonly input)
          if (this.hasAttribute('readonly')) {
            return; // Don't allow editing manual duration entries
          }
          
          // Parse time using flexible parser
          const parsedTime = parseFlexibleTime(timeValue);
          if (!parsedTime) {
            // Show error state
            this.style.borderColor = '#EF4444';
            this.style.backgroundColor = '#FEF2F2';
            alert('Please enter a valid time format (e.g., 3p, 3:30pm, 12am, 300pm, etc.)');
            setTimeout(() => {
              this.style.borderColor = '';
              this.style.backgroundColor = '';
            }, 2000);
            this.focus();
            return;
          }
          
          try {
            // Get the current entry data to determine if this is a manual duration entry
            const row = this.closest('tr');
            const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement;
            const entryData = editBtn?.getAttribute('data-entry');
            let currentEntry = null;
            
            if (entryData) {
              try {
                currentEntry = JSON.parse(entryData);
              } catch (e) {
                console.error('Error parsing entry data:', e);
              }
            }
            
            // Get the task date from the current entry
            const taskDate = currentEntry?.startTime ? new Date(currentEntry.startTime) : new Date(currentEntry?.createdAt);
            
            // Create new Date objects with the parsed time on the same date
            const hours = parsedTime.hours;
            const minutes = parsedTime.minutes;
            
            // Create a new date with the same date but new time
            const newDateTime = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate(), hours, minutes, 0, 0);
            
            const updateData: { startTime?: string; endTime?: string; durationManual?: number | null } = {};
            if (timeType === 'start') {
              updateData.startTime = newDateTime.toISOString();
              // Prefer the current end input value if present
              const endInput = row?.querySelector('input[data-time-type="end"]') as HTMLInputElement | null;
              const endVal = endInput?.value?.trim();
              if (endVal && endVal !== '--:-- --') {
                const parsedEnd = parseFlexibleTime(endVal);
                if (parsedEnd) {
                  const endDt = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate(), parsedEnd.hours, parsedEnd.minutes, 0, 0);
                  updateData.endTime = endDt.toISOString();
                } else if (currentEntry?.endTime) {
                  updateData.endTime = new Date(currentEntry.endTime).toISOString();
                }
              } else if (currentEntry?.endTime) {
                updateData.endTime = new Date(currentEntry.endTime).toISOString();
              }
            } else if (timeType === 'end') {
              updateData.endTime = newDateTime.toISOString();
              // Prefer the current start input value if present
              const startInput = row?.querySelector('input[data-time-type="start"]') as HTMLInputElement | null;
              const startVal = startInput?.value?.trim();
              if (startVal && startVal !== '--:-- --') {
                const parsedStart = parseFlexibleTime(startVal);
                if (parsedStart) {
                  const startDt = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate(), parsedStart.hours, parsedStart.minutes, 0, 0);
                  updateData.startTime = startDt.toISOString();
                } else if (currentEntry?.startTime) {
                  updateData.startTime = new Date(currentEntry.startTime).toISOString();
                }
              } else if (currentEntry?.startTime) {
                updateData.startTime = new Date(currentEntry.startTime).toISOString();
              }
            }
            
            // If this was a manual duration entry and we're adding times, clear the manual duration
            if (currentEntry?.durationManual && !currentEntry?.endTime) {
              updateData.durationManual = null;
            }
            
            // Validate that end time is after start time if both times are being set
            if (timeType === 'end' && currentEntry?.startTime) {
              const existingStartTime = new Date(currentEntry.startTime);
              if (newDateTime <= existingStartTime) {
                // Show error state
                this.style.borderColor = '#EF4444';
                this.style.backgroundColor = '#FEF2F2';
                alert('End time must be after start time');
                setTimeout(() => {
                  this.style.borderColor = '';
                  this.style.backgroundColor = '';
                }, 2000);
                this.focus();
                return;
              }
            } else if (timeType === 'start' && currentEntry?.endTime) {
              const existingEndTime = new Date(currentEntry.endTime);
              if (newDateTime >= existingEndTime) {
                // Show error state
                this.style.borderColor = '#EF4444';
                this.style.backgroundColor = '#FEF2F2';
                alert('Start time must be before end time');
                setTimeout(() => {
                  this.style.borderColor = '';
                  this.style.backgroundColor = '';
                }, 2000);
                this.focus();
                return;
              }
            }
            
            // Show loading state
            this.style.borderColor = '#3B82F6';
            this.style.backgroundColor = '#F0F9FF';
            
        console.log('üîß DASHBOARD: Making API call to update entry:', { entryId, updateData });
        console.log('üîß DASHBOARD: Full updateData object:', JSON.stringify(updateData, null, 2));
        
        const response = await fetch(`/api/time-entries-unified/${entryId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(updateData)
        });
        
        console.log('üîß DASHBOARD: API response status:', response.status);
        if (response.ok) {
              const result = await response.json();
              console.log('üîß DASHBOARD: API response data:', result);
              const row = this.closest('tr');
              
              // Show success state
              this.style.borderColor = '#10B981';
              this.style.backgroundColor = '#F0FDF4';
              setTimeout(() => {
                this.style.borderColor = '';
                this.style.backgroundColor = '';
              }, 1500);
              
              // Update the duration cell
              const durationCell = row?.querySelector('td[data-role="duration"] input') as HTMLInputElement;
              if (durationCell && result.data) {
                // Use the calculated duration from server response
                const duration = result.data.duration || 0;
                const hours = Math.floor(duration / 3600);
                const minutes = Math.floor((duration % 3600) / 60);
                durationCell.value = `${hours}h ${minutes}m`;
              }
              
              // Update the time input values to reflect the new data
              if (result.data) {
                const startTimeInput = row?.querySelector('input[data-time-type="start"]') as HTMLInputElement;
                const endTimeInput = row?.querySelector('input[data-time-type="end"]') as HTMLInputElement;
                
                if (startTimeInput && result.data.startTime) {
                  const startDate = new Date(result.data.startTime);
                  startTimeInput.value = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', hour12: true }).format(startDate);
                } else if (startTimeInput && !result.data.startTime) {
                  startTimeInput.value = '--:-- --';
                }
                
                if (endTimeInput && result.data.endTime) {
                  const endDate = new Date(result.data.endTime);
                  endTimeInput.value = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', hour12: true }).format(endDate);
                } else if (endTimeInput && !result.data.endTime) {
                  endTimeInput.value = '--:-- --';
                }

                // Refresh the row's data-entry payload so subsequent edits use fresh values
                const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement | null;
                if (editBtn) {
                  editBtn.setAttribute('data-entry', JSON.stringify(result.data));
                }
              }
              
              // Dispatch custom event immediately to notify timer components
              window.dispatchEvent(new CustomEvent('timeEntryUpdated', {
                detail: {
                  timestamp: new Date().toISOString(),
                  source: 'dashboard-inline-edit',
                  entryId: entryId
                }
              }));
              
              // Reload dashboard data to refresh recent entries table and stats
              console.log('Time input updated, refreshing dashboard...');
              loadDashboardData();
              
              // Show success feedback
              this.style.borderColor = '#10B981';
              this.style.backgroundColor = '';
              setTimeout(() => {
                this.style.borderColor = '';
              }, 2000);
                         } else {
               const error = await response.json();
               
               if (response.status === 401) {
                 // Authentication error - redirect to login
                 alert('Your session has expired. Please log in again.');
                 window.location.href = '/login';
                 return;
               }
               
               // Show error state
               this.style.borderColor = '#EF4444';
               this.style.backgroundColor = '#FEF2F2';
               alert(`Error: ${error.error}`);
               setTimeout(() => {
                 this.style.borderColor = '';
                 this.style.backgroundColor = '';
               }, 2000);
               // Reset to original value on error
               this.focus();
             }
                      } catch (error) {
              console.error('Error updating time:', error);
              // Reset styling on error
              this.style.borderColor = '';
              this.style.backgroundColor = '';
              alert('Error updating time. Please check your input and try again.');
              this.focus();
            }
        });
        
        // Handle Enter key
        timeInput.addEventListener('keypress', function(e: KeyboardEvent) {
          if (e.key === 'Enter') {
            this.blur();
          }
        });
        
        // Mark as having listeners attached
        timeInput.setAttribute('data-listeners-attached', 'true');
      });
    }

    // Function to handle duration input changes
    function handleDurationInputChange() {
      const durationInputs = document.querySelectorAll('.duration-input');
      
      durationInputs.forEach((input: Element) => {
        const durationInput = input as HTMLInputElement;
        
        // Skip if already has event listeners attached
        if (durationInput.hasAttribute('data-listeners-attached')) {
          return;
        }
        
        // Store the original value when the input is focused
        durationInput.addEventListener('focus', function() {
          this.setAttribute('data-original-value', this.value);
        });
        
        // Handle Enter key press
        durationInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            this.blur(); // Trigger the blur event to save
          }
        });
        
        durationInput.addEventListener('blur', async function() {
          const entryId = this.getAttribute('data-entry-id');
          const durationValue = this.value.trim();
          
          // Skip if empty
          if (!durationValue) return;
          
          // Skip if the value hasn't changed
          const originalValue = this.getAttribute('data-original-value');
          if (durationValue === originalValue) return;
          
          // Parse duration using flexible parser
          const parsedDuration = parseFlexibleDuration(durationValue);
          if (!parsedDuration) {
            // Show error state
            this.style.borderColor = '#EF4444';
            this.style.backgroundColor = '#FEF2F2';
            alert('Please enter a valid duration format (e.g., 2h 30m, 2.5h, 150m, 2:30)');
            setTimeout(() => {
              this.style.borderColor = '';
              this.style.backgroundColor = '';
            }, 2000);
            this.focus();
            return;
          }
          
          try {
            // Get the current entry data
            const row = this.closest('tr');
            const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement;
            const entryData = editBtn?.getAttribute('data-entry');
            let currentEntry = null;
            
            if (entryData) {
              try {
                currentEntry = JSON.parse(entryData);
              } catch (e) {
                console.error('Error parsing entry data:', e);
              }
            }
            
            // Get the task date from the current entry
            const taskDate = currentEntry?.startTime ? new Date(currentEntry.startTime) : new Date(currentEntry?.createdAt);
            
            // Create update data with manual duration
            // Convert the parsed duration to a format the server understands
            let serverDurationFormat: string;
            const hours = Math.floor(parsedDuration / 3600);
            const minutes = Math.floor((parsedDuration % 3600) / 60);
            
            if (hours > 0 && minutes > 0) {
              // For combined hours and minutes, use decimal hours format
              const totalHours = hours + (minutes / 60);
              serverDurationFormat = `${totalHours}h`;
            } else if (hours > 0) {
              // Just hours
              serverDurationFormat = `${hours}h`;
            } else {
              // Just minutes
              serverDurationFormat = `${minutes}m`;
            }
            
            const updateData = {
              duration: serverDurationFormat
            };
            
            // Send update to API
            const response = await fetch(`/api/time-entries-unified/${entryId}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(updateData)
            });
            
            if (response.ok) {
              const result = await response.json();
              
              // Update duration display
              const durationCell = row?.querySelector('td[data-role="duration"] input') as HTMLInputElement;
              if (durationCell && result.data) {
                const hours = Math.floor(result.data.durationManual / 3600);
                const minutes = Math.floor((result.data.durationManual % 3600) / 60);
                durationCell.value = `${hours}h ${minutes}m`;
              }
              
              // Disable start/stop inputs (make them readonly and grayed out)
              const startInput = row?.querySelector('input[data-time-type="start"]') as HTMLInputElement;
              const endInput = row?.querySelector('input[data-time-type="end"]') as HTMLInputElement;
              
              if (startInput) {
                startInput.readOnly = true;
                startInput.classList.add('bg-gray-100', 'cursor-not-allowed');
                startInput.title = 'Manual duration entry - use edit button to modify';
                startInput.value = '--:-- --';
              }
              
              if (endInput) {
                endInput.readOnly = true;
                endInput.classList.add('bg-gray-100', 'cursor-not-allowed');
                endInput.title = 'Manual duration entry - use edit button to modify';
                endInput.value = '--:-- --';
              }
              
              // Refresh the row's data-entry payload so subsequent edits use fresh values
              if (editBtn) {
                editBtn.setAttribute('data-entry', JSON.stringify(result.data));
              }
              
              // Dispatch custom event immediately to notify timer components
              window.dispatchEvent(new CustomEvent('timeEntryUpdated', {
                detail: {
                  timestamp: new Date().toISOString(),
                  source: 'dashboard-inline-duration-edit',
                  entryId: entryId
                }
              }));
              
              // Reload dashboard data to refresh recent entries table and stats
              console.log('Duration input updated, refreshing dashboard...');
              loadDashboardData();
              
              // Show success feedback
              this.style.borderColor = '#10B981';
              this.style.backgroundColor = '';
              setTimeout(() => {
                this.style.borderColor = '';
              }, 2000);
            } else {
              const error = await response.json();
              
              if (response.status === 401) {
                // Authentication error - redirect to login
                alert('Your session has expired. Please log in again.');
                window.location.href = '/login';
                return;
              }
              
              // Show error state
              this.style.borderColor = '#EF4444';
              this.style.backgroundColor = '#FEF2F2';
              alert(`Error: ${error.error}`);
              setTimeout(() => {
                this.style.borderColor = '';
                this.style.backgroundColor = '';
              }, 2000);
              this.focus();
            }
          } catch (error) {
            console.error('Error updating duration:', error);
            this.style.borderColor = '';
            this.style.backgroundColor = '';
            alert('Error updating duration. Please check your input and try again.');
            this.focus();
          }
        });
        
        // Handle Enter key
        durationInput.addEventListener('keypress', function(e: KeyboardEvent) {
          if (e.key === 'Enter') {
            this.blur();
          }
        });
        
        // Mark as having listeners attached
        durationInput.setAttribute('data-listeners-attached', 'true');
      });
    }

    // Function to handle notes input changes
    function handleNotesInputChange() {
      const notesInputs = document.querySelectorAll('.notes-input');
      
      notesInputs.forEach((input: Element) => {
        const notesInput = input as HTMLInputElement;
        
        // Skip if already has event listeners attached
        if (notesInput.hasAttribute('data-listeners-attached')) {
          return;
        }
        
        // Store the original value when the input is focused and expand width
        notesInput.addEventListener('focus', function() {
          this.setAttribute('data-original-value', this.value);
          this.style.width = '12rem';
        });
        
        // Handle Enter key press
        notesInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            this.style.width = '5rem'; // Shrink width immediately
            this.blur(); // Trigger the blur event to save
          }
        });
        
        notesInput.addEventListener('blur', async function() {
          const entryId = this.getAttribute('data-entry-id');
          const notesValue = this.value.trim();
          
          // Shrink width back to 5rem
          this.style.width = '5rem';
          
          // Skip if the value hasn't changed
          const originalValue = this.getAttribute('data-original-value');
          if (notesValue === originalValue) return;
          
          try {
            // Show loading state
            this.style.borderColor = '#3B82F6';
            this.style.backgroundColor = '#F0F9FF';
            
            const response = await fetch(`/api/time-entries-unified/${entryId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                notes: notesValue || null
              })
            });
            
            if (response.ok) {
              const result = await response.json();
              
              // Show success state
              this.style.borderColor = '#10B981';
              this.style.backgroundColor = '#F0FDF4';
              setTimeout(() => {
                this.style.borderColor = '';
                this.style.backgroundColor = '';
              }, 1500);
              
              // Update the row's data-entry payload so subsequent edits use fresh values
              const row = this.closest('tr');
              const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement | null;
              if (editBtn && result.data) {
                editBtn.setAttribute('data-entry', JSON.stringify(result.data));
              }
              
              // Reload dashboard data to refresh recent entries table and stats
              console.log('Notes input updated, refreshing dashboard...');
              loadDashboardData();
              
            } else {
              const error = await response.json();
              
              if (response.status === 401) {
                // Authentication error - redirect to login
                alert('Your session has expired. Please log in again.');
                window.location.href = '/login';
                return;
              }
              
              // Show error state
              this.style.borderColor = '#EF4444';
              this.style.backgroundColor = '#FEF2F2';
              alert(`Error: ${error.error}`);
              setTimeout(() => {
                this.style.borderColor = '';
                this.style.backgroundColor = '';
              }, 2000);
              this.focus();
            }
          } catch (error) {
            console.error('Error updating notes:', error);
            // Reset styling on error
            this.style.borderColor = '';
            this.style.backgroundColor = '';
            alert('Error updating notes. Please try again.');
            this.focus();
          }
        });
        
        // Mark as having listeners attached
        notesInput.setAttribute('data-listeners-attached', 'true');
      });
    }

    // Function to handle date input validation and changes
    function handleDateInputChange() {
      const dateInputs = document.querySelectorAll('.date-input');
      
      dateInputs.forEach((input: Element) => {
        const dateInput = input as HTMLInputElement;
        
        // Format validation function
        function validateDateFormat(value: string): boolean {
          const mmddyyyyRegex = /^(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/\d{4}$/;
          return mmddyyyyRegex.test(value);
        }
        
        // Convert mm/dd/yyyy to yyyy-mm-dd for API
        function convertToISODate(dateStr: string): string {
          const [month, day, year] = dateStr.split('/');
          return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
        }
        
        // Convert yyyy-mm-dd to mm/dd/yyyy for display
        function convertToDisplayDate(isoDate: string): string {
          const [year, month, day] = isoDate.split('-');
          return `${month}/${day}/${year}`;
        }
        
        // Handle Enter key press
        dateInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            this.blur(); // Trigger the blur event to save
          }
        });
        
        // Handle input changes
        dateInput.addEventListener('blur', async function() {
          const entryId = this.getAttribute('data-entry-id');
          const currentDate = this.getAttribute('data-current-date');
          const newValue = this.value.trim();
          
          if (!newValue) {
            // Reset to original if empty
            this.value = convertToDisplayDate(currentDate || '');
            return;
          }
          
          if (!validateDateFormat(newValue)) {
            // Show format error dialog
            alert('Please enter the date in mm/dd/yyyy format (e.g., 12/25/2023)');
            this.value = convertToDisplayDate(currentDate || '');
            this.focus();
            return;
          }
          
          const newISODate = convertToISODate(newValue);
          if (newISODate === currentDate) {
            return; // No change
          }
          
          try {
            // Parse the new date and get current times from the entry
            const [year, month, day] = newISODate.split('-').map(Number);
            const newDateObj = new Date(year, month - 1, day, 0, 0, 0, 0);
            
            // Get current entry data to preserve times
            const row = dateInput.closest('tr');
            const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement;
            const entryData = editBtn?.getAttribute('data-entry');
            let currentEntry = null;
            
            if (entryData) {
              try {
                currentEntry = JSON.parse(entryData);
              } catch (e) {
                console.error('Error parsing entry data:', e);
              }
            }
            
            const updateData: any = {
              taskDate: newISODate
            };
            
            // Check if this is a manual duration entry (has durationManual but no startTime/endTime)
            const isManualDurationEntry = currentEntry?.durationManual && !currentEntry?.startTime && !currentEntry?.endTime;
            
            if (isManualDurationEntry) {
              // For manual duration entries, update createdAt to the new date
              const newCreatedAt = new Date(year, month - 1, day, 12, 0, 0, 0); // Use noon to avoid timezone issues
              updateData.createdAt = newCreatedAt.toISOString();
            } else {
              // For timer-based entries, update startTime and endTime
              if (currentEntry?.startTime) {
                const startTime = new Date(currentEntry.startTime);
                const newStartTime = new Date(year, month - 1, day, startTime.getHours(), startTime.getMinutes(), 0, 0);
                updateData.startTime = newStartTime.toISOString();
              }
              
              if (currentEntry?.endTime) {
                const endTime = new Date(currentEntry.endTime);
                const newEndTime = new Date(year, month - 1, day, endTime.getHours(), endTime.getMinutes(), 0, 0);
                updateData.endTime = newEndTime.toISOString();
              }
            }
            
            const response = await fetch(`/api/time-entries-unified/${entryId}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(updateData)
            });
            
            if (response.ok) {
              const result = await response.json();
              
              // Update the input with new date
              this.setAttribute('data-current-date', newISODate);
              
              // Update row data for subsequent edits
              if (editBtn && result.data) {
                editBtn.setAttribute('data-entry', JSON.stringify(result.data));
              }
              
              // Reload dashboard data to refresh recent entries table and stats
              console.log('Date input updated, refreshing dashboard...');
              loadDashboardData();
              
              // Show success feedback
              this.style.backgroundColor = '#D1FAE5';
              this.style.borderColor = '#10B981';
              setTimeout(() => {
                this.style.backgroundColor = '';
                this.style.borderColor = '';
              }, 1500);
            } else {
              console.error('Failed to update date');
              // Show error feedback
              this.style.backgroundColor = '#FEE2E2';
              this.style.borderColor = '#EF4444';
              setTimeout(() => {
                this.style.backgroundColor = '';
                this.style.borderColor = '';
              }, 1500);
              // Revert to original value
              this.value = convertToDisplayDate(currentDate || '');
            }
          } catch (error) {
            console.error('Error updating date:', error);
            // Revert to original value
            this.value = convertToDisplayDate(currentDate || '');
          }
        });
      });
    }
    
    // Function to save date changes from Flatpickr
    async function saveDateChange(dateInput: HTMLInputElement, entryId: string, newISODate: string) {
      console.log('üîß DASHBOARD: saveDateChange called with:', { entryId, newISODate });
      try {
        // Get the current entry data
        const row = dateInput.closest('tr');
        const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement;
        const entryData = editBtn?.getAttribute('data-entry');
        let currentEntry = null;
        
        if (entryData) {
          try {
            currentEntry = JSON.parse(entryData);
          } catch (e) {
            console.error('Error parsing entry data:', e);
          }
        }
        
        if (!currentEntry) {
          console.error('Could not find entry data for date change');
          return;
        }
        
        // Parse the new date
        const [year, month, day] = newISODate.split('-').map(Number);
        
        const updateData: { startTime?: string; endTime?: string; createdAt?: string } = {};
        
        // Check if this is a manual duration entry (has durationManual but no startTime/endTime)
        const isManualDurationEntry = currentEntry.durationManual && !currentEntry.startTime && !currentEntry.endTime;
        
        console.log('üîß DASHBOARD: Date change debug:', {
          entryId,
          currentEntry: {
            durationManual: currentEntry.durationManual,
            startTime: currentEntry.startTime,
            endTime: currentEntry.endTime,
            createdAt: currentEntry.createdAt
          },
          isManualDurationEntry,
          newISODate,
          updateData
        });
        
        console.log('üîß DASHBOARD: Full currentEntry object:', currentEntry);
        console.log('üîß DASHBOARD: updateData before processing:', updateData);
        
        if (isManualDurationEntry) {
          // For manual duration entries, update createdAt to the new date
          const newCreatedAt = new Date(year, month - 1, day, 12, 0, 0, 0); // Use noon to avoid timezone issues
          updateData.createdAt = newCreatedAt.toISOString();
          console.log('üîß DASHBOARD: Updating manual duration entry createdAt:', updateData.createdAt);
        } else {
          // For timer-based entries, update startTime and endTime
          if (currentEntry.startTime) {
            const startTime = new Date(currentEntry.startTime);
            const newStartTime = new Date(year, month - 1, day, startTime.getHours(), startTime.getMinutes(), 0, 0);
            updateData.startTime = newStartTime.toISOString();
          }
          
          if (currentEntry.endTime) {
            const endTime = new Date(currentEntry.endTime);
            const newEndTime = new Date(year, month - 1, day, endTime.getHours(), endTime.getMinutes(), 0, 0);
            updateData.endTime = newEndTime.toISOString();
          }
        }
        
        console.log('üîß DASHBOARD: Final updateData object:', updateData);
        const response = await fetch(`/api/time-entries-unified/${entryId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(updateData),
        });
        
        if (response.ok) {
          const result = await response.json();
          console.log('‚úÖ Date update successful:', result);
          // Reload dashboard data to refresh recent entries table and stats
          console.log('Date picker updated, refreshing dashboard...');
          loadDashboardData();
          
          // Show success feedback
          dateInput.style.backgroundColor = '#d4edda';
          dateInput.style.borderColor = '#28a745';
          setTimeout(() => {
            dateInput.style.backgroundColor = '';
            dateInput.style.borderColor = '';
          }, 1500);
        } else {
          const errorData = await response.json();
          console.error('üîß DASHBOARD: Failed to update date, status:', response.status, 'error:', errorData);
          // Revert the input value
          const originalDate = dateInput.getAttribute('data-current-date');
          if (originalDate) {
            const [origYear, origMonth, origDay] = originalDate.split('-').map(Number);
            dateInput.value = `${String(origMonth).padStart(2, '0')}/${String(origDay).padStart(2, '0')}/${origYear}`;
            dateInput.setAttribute('data-current-date', originalDate);
          }
        }
      } catch (error) {
        console.error('Error updating date:', error);
        // Revert the input value
        const originalDate = dateInput.getAttribute('data-current-date');
        if (originalDate) {
          const [origYear, origMonth, origDay] = originalDate.split('-').map(Number);
          dateInput.value = `${String(origMonth).padStart(2, '0')}/${String(origDay).padStart(2, '0')}/${origYear}`;
          dateInput.setAttribute('data-current-date', originalDate);
        }
      }
    }

    // Function to initialize Flatpickr date pickers
    function initializeFlatpickr() {
      const dateInputs = document.querySelectorAll('.date-input:not([data-flatpickr-initialized])');
      
      if (dateInputs.length === 0) {
        return; // No new inputs to initialize
      }
      
      dateInputs.forEach((input: Element) => {
        const dateInput = input as HTMLInputElement;
        const entryId = dateInput.getAttribute('data-entry-id');
        const currentDate = dateInput.getAttribute('data-current-date');
        
        if (!dateInput || !entryId) {
          return; // Skip inputs without proper data
        }
        
        // Initialize Flatpickr with proper error handling
        try {
          console.log('üîß DASHBOARD: Initializing Flatpickr for entry:', entryId, 'currentDate:', currentDate);
          
          const flatpickrInstance = flatpickr(dateInput, {
            dateFormat: 'm/d/Y',
            defaultDate: currentDate ? new Date(currentDate + 'T00:00:00') : new Date(),
            allowInput: true,
            clickOpens: true,
            static: true,
            monthSelectorType: 'static',
            onChange: function(selectedDates, dateStr, instance) {
              console.log('üîß DASHBOARD: Flatpickr onChange triggered:', { selectedDates, dateStr, entryId });
              if (selectedDates.length > 0) {
                const selectedDate = selectedDates[0];
                const isoDate = selectedDate.toISOString().split('T')[0];
                console.log('üîß DASHBOARD: Calling saveDateChange with:', { isoDate, entryId });
                dateInput.setAttribute('data-current-date', isoDate);
                
                // Manually trigger the save logic instead of blur event
                // to avoid conflicts with the existing blur handler
                if (entryId) {
                  saveDateChange(dateInput, entryId!, isoDate);
                }
              }
            }
          });
          
          // Mark as initialized
          dateInput.setAttribute('data-flatpickr-initialized', 'true');
        } catch (error) {
          console.error('üîß DASHBOARD: Error initializing Flatpickr for entry:', entryId, error);
          // Still mark as initialized to prevent retry loops
          dateInput.setAttribute('data-flatpickr-initialized', 'true');
        }
      });
    }

    // Initial setup
    handleTimeInputChange();
    handleDurationInputChange();
    handleDateInputChange();
    handleNotesInputChange();
    initializeFlatpickr();

      // Re-setup after data reload using a MutationObserver with proper guards
      let isProcessing = false;
      const observer = new MutationObserver(function(mutations) {
        // Prevent infinite loops by checking if we're already processing
        if (isProcessing) return;
        
        // Only process if there are actual new nodes added
        const hasNewNodes = mutations.some(mutation => 
          mutation.type === 'childList' && mutation.addedNodes.length > 0
        );
        
        if (!hasNewNodes) return;
        
        isProcessing = true;
        
        try {
          console.log('MutationObserver: DOM changed, re-attaching event listeners');
          
          // Check if time inputs were added (only new ones without listeners)
          const timeInputs = document.querySelectorAll('.time-input:not([data-listeners-attached])');
          if (timeInputs.length > 0) {
            console.log('MutationObserver: Re-attaching time input handlers');
            handleTimeInputChange();
          }
          
          // Check if duration inputs were added (only new ones without listeners)
          const durationInputs = document.querySelectorAll('.duration-input:not([data-listeners-attached])');
          if (durationInputs.length > 0) {
            console.log('MutationObserver: Re-attaching duration input handlers');
            handleDurationInputChange();
          }
          
          // Check if date inputs were added (only new ones without Flatpickr)
          const dateInputs = document.querySelectorAll('.date-input:not([data-flatpickr-initialized])');
          if (dateInputs.length > 0) {
            console.log('MutationObserver: Re-attaching date input handlers');
            handleDateInputChange();
            initializeFlatpickr();
          }
          
          // Check if notes inputs were added (only new ones without listeners)
          const notesInputs = document.querySelectorAll('.notes-input:not([data-listeners-attached])');
          if (notesInputs.length > 0) {
            console.log('MutationObserver: Re-attaching notes input handlers');
            handleNotesInputChange();
          }
        } finally {
          // Reset processing flag after a short delay to prevent rapid re-processing
          setTimeout(() => {
            isProcessing = false;
          }, 100);
        }
      });

      // Start observing the recent entries container
      const recentEntriesContainer = document.getElementById('recentEntries');
      if (recentEntriesContainer) {
        observer.observe(recentEntriesContainer, { childList: true, subtree: true });
      }
  });
</script> 