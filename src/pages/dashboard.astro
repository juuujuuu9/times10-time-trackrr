---
import Layout from '../layouts/Layout.astro';
import { requireAuth } from '../utils/session';
import Timer from '../components/Timer';

// Require authentication
const user = await requireAuth('/')(Astro) as any;
---

<Layout title="Dashboard - Times10 Time Tracker">
  <div class="min-h-screen" style="background-color: #f0eef5;">
    <!-- Loading State (shown immediately) -->
    <div id="loadingState" class="min-h-screen flex items-center justify-center" style="background-color: #f0eef5;">
      <div class="text-center">
        <div class="w-12 h-12 border-4 border-gray-600 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
        <p class="text-gray-600 text-lg">Loading dashboard...</p>
      </div>
    </div>

    <!-- Dashboard Content (hidden initially) -->
    <div id="dashboardContent" class="hidden">
      <!-- Header -->
      <header class="bg-white shadow-sm border-b border-gray-200 flex items-center" style="height: 58px;">
        <div class="max-w-7xl mx-auto px-8 w-full">
          <div class="flex justify-between items-center">
            <div class="flex items-center">
              <a href="/" class="flex items-center hover:opacity-80 transition-opacity">
                <img src="/trackr-icon.png" alt="Times10 Logo" class="w-auto mr-3 py-0" style="height: calc(58px - 1rem);" />
              </a>
            </div>
            <div class="flex items-center space-x-4">
              <span class="text-sm text-gray-600">Welcome, {user?.name || 'User'}</span>
              <span class="px-3 py-1 text-xs font-medium bg-gray-100 text-gray-800 rounded-full">
                Team Member
              </span>
              <button
                id="logoutButton"
                class="text-sm text-gray-600 hover:text-gray-900 transition-colors"
              >
                Sign Out
              </button>
            </div>
          </div>
        </div>
      </header>

      <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
          <!-- Main Content -->
          <div class="lg:col-span-2 space-y-8">
            <!-- Timer Section -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
              <Timer client:load />
            </div>

            <!-- Recent Time Entries -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
              <div class="px-6 py-4 border-b border-gray-200 flex justify-between items-center">
                <h2 class="text-xl font-semibold text-gray-900">Recent Time Entries</h2>
                <div class="flex space-x-4">
                  <button
                    id="refreshEntriesBtn"
                    class="text-sm text-gray-600 hover:text-gray-800 font-medium transition-colors cursor-pointer flex items-center space-x-1"
                    title="Refresh data"
                  >
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    <span>Refresh</span>
                  </button>
                  <button
                    id="debugBtn"
                    class="text-sm text-gray-600 hover:text-gray-800 font-medium transition-colors cursor-pointer flex items-center space-x-1"
                    title="Debug calculations"
                  >
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span>Debug</span>
                  </button>
                  <button
                    id="viewAllEntriesBtn"
                    class="text-sm text-gray-600 hover:text-gray-800 font-medium transition-colors cursor-pointer"
                  >
                    All Entries
                  </button>
                </div>
              </div>
              <div class="overflow-x-auto">
                <div id="recentEntries" class="min-w-full">
                  <div class="text-center py-8">
                    <div class="w-12 h-12 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
                      <span class="text-gray-400 text-xl">⏱️</span>
                    </div>
                    <p class="text-gray-500">Loading your recent time entries...</p>
                  </div>
                </div>
              </div>
            </div>


          </div>

          <!-- Sidebar -->
          <div class="space-y-6">
            <!-- Quick Stats -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
              <h3 class="text-lg font-semibold text-gray-900 mb-4">This Week</h3>
              <div class="space-y-4">
                <div class="flex justify-between items-center">
                  <span class="text-sm text-gray-600">Hours Tracked</span>
                  <span id="weeklyHours" class="text-lg font-semibold text-gray-900">-</span>
                </div>
              </div>
            </div>

            <!-- Quick Actions -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
              <h3 class="text-lg font-semibold text-gray-900 mb-4">Quick Actions</h3>
              <div class="space-y-3 mt-4">
                <button
                  id="addTimeEntryBtn"
                  class="w-full text-white px-4 py-2 rounded-lg transition-colors text-sm font-medium"
                  style={{
                    backgroundColor: '#1F292E'
                  }}
                  onmouseover="this.style.backgroundColor='#000000'"
                  onmouseout="this.style.backgroundColor='#1F292E'"
                >
                  Add Manual Time Entry
                </button>
                <button
                  id="viewReportsBtn"
                  class="w-full bg-gray-100 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-200 transition-colors text-sm font-medium"
                >
                  View Reports
                </button>

              </div>
            </div>


          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Add Manual Time Entry Modal -->
  <div id="timeEntryModal" class="fixed inset-0 bg-black/50 hidden z-50">
    <div class="flex items-center justify-center min-h-screen p-4">
      <div class="bg-white rounded-lg shadow-xl max-w-md w-full max-h-[90vh] border border-gray-200 flex flex-col">
        <div class="px-6 py-4 border-b border-gray-200 flex-shrink-0">
          <h3 class="text-lg font-medium text-gray-900">Add Manual Time Entry</h3>
        </div>
        <div class="flex-1 overflow-y-auto">
          <form id="timeEntryForm" class="px-6 py-4">
            <div class="mb-4">
              <label for="timeEntryTask" class="block text-sm font-medium text-gray-700 mb-1">
                Task <span class="text-gray-500 font-normal">(required)</span>
              </label>
              <div class="relative">
                <input
                  type="text"
                  id="timeEntryTask"
                  placeholder="Search for a task..."
                  required
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
                <input type="hidden" id="timeEntryTaskId" />
                <div id="taskDropdown" class="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-y-auto hidden">
                  <!-- Task results will be populated here -->
                </div>
              </div>
            </div>
            <div class="mb-4">
              <label for="timeEntryDuration" class="block text-sm font-medium text-gray-700 mb-1">
                Duration <span class="text-gray-500 font-normal">(required)</span>
              </label>
              <input
                type="text"
                id="timeEntryDuration"
                placeholder="e.g., 2h, 3.5hr, 4:15, 90m"
                required
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
              />
              <p class="text-xs text-gray-500 mt-1">
                Supported formats: 2h, 2hr, 3.5hr, 4:15, 90m, 5400s, etc.
              </p>
            </div>
            <div class="mb-4">
              <label for="timeEntryDate" class="block text-sm font-medium text-gray-700 mb-1">
                Task Date <span class="text-gray-500 font-normal">(required)</span>
              </label>
              <input
                type="date"
                id="timeEntryDate"
                required
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
              />
              <p class="text-xs text-gray-500 mt-1">
                When did this task actually occur? (defaults to today)
              </p>
            </div>
            <div class="mb-6">
              <label for="timeEntryNotes" class="block text-sm font-medium text-gray-700 mb-1">
                Notes
              </label>
              <textarea
                id="timeEntryNotes"
                rows="3"
                placeholder="Optional notes about this time entry..."
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
              ></textarea>
            </div>
            <div class="flex justify-end space-x-3">
              <button
                type="button"
                id="cancelTimeEntryBtn"
                class="px-4 py-2 text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors"
              >
                Cancel
              </button>
              <button
                type="submit"
                id="saveTimeEntryBtn"
                class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md transition-colors flex items-center space-x-2"
              >
                <span id="saveButtonText">Save Entry</span>
                <svg id="saveButtonSpinner" class="w-4 h-4 animate-spin hidden" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <!-- Alternative spinner for debugging -->
                <div id="saveButtonSpinnerAlt" class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin hidden"></div>
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>

  <!-- Edit Time Entry Modal -->
  <div id="editTimeEntryModal" class="fixed inset-0 bg-black/50 hidden z-50">
    <div class="flex items-center justify-center min-h-screen p-4">
      <div class="bg-white rounded-lg shadow-xl max-w-md w-full max-h-[90vh] border border-gray-200 flex flex-col">
        <div class="px-6 py-4 border-b border-gray-200 flex-shrink-0">
          <h3 class="text-lg font-medium text-gray-900">Edit Time Entry</h3>
        </div>
        <div class="flex-1 overflow-y-auto">
          <form id="editTimeEntryForm" class="px-6 py-4">
            <input type="hidden" id="editTimeEntryId" />
            
            <!-- Time Entry Method Selection -->
            <div class="mb-6">
              <label class="block text-sm font-medium text-gray-700 mb-3">Edit Method</label>
              <div class="space-y-3">
                <label class="flex items-center">
                  <input type="radio" name="editMethod" value="times" class="mr-2" checked>
                  <span class="text-sm">Adjust start/end times</span>
                </label>
                <label class="flex items-center">
                  <input type="radio" name="editMethod" value="duration" class="mr-2">
                  <span class="text-sm">Manual duration entry</span>
                </label>
              </div>
            </div>

            <!-- Start/End Times Section -->
            <div id="timesSection" class="space-y-4">
              <div>
                <label for="editStartTime" class="block text-sm font-medium text-gray-700 mb-1">
                  Start Time
                </label>
                <input
                  type="text"
                  id="editStartTime"
                  placeholder="9:30 AM"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
              </div>
              <div>
                <label for="editEndTime" class="block text-sm font-medium text-gray-700 mb-1">
                  End Time
                </label>
                <input
                  type="text"
                  id="editEndTime"
                  placeholder="5:30 PM"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
              </div>
            </div>

            <!-- Duration Section -->
            <div id="durationSection" class="hidden">
              <div>
                <label for="editDuration" class="block text-sm font-medium text-gray-700 mb-1">
                  Duration
                </label>
                <input
                  type="text"
                  id="editDuration"
                  placeholder="e.g., 2h, 3.5hr, 4:15, 90m"
                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
                />
                <p class="text-xs text-gray-500 mt-1">
                  Supported formats: 2h, 2hr, 3.5hr, 4:15, 90m, 5400s, etc.
                </p>
              </div>
            </div>

            <div class="mb-6">
              <label for="editNotes" class="block text-sm font-medium text-gray-700 mb-1">
                Notes
              </label>
              <textarea
                id="editNotes"
                rows="3"
                placeholder="Optional notes about this time entry..."
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-gray-500"
              ></textarea>
            </div>

            <div class="flex justify-between">
              <button
                type="button"
                id="deleteTimeEntryBtn"
                class="px-4 py-2 text-gray-600 bg-gray-50 hover:bg-gray-100 rounded-md transition-colors border border-gray-200"
              >
                Delete Entry
              </button>
              <div class="flex space-x-3">
                <button
                  type="button"
                  id="cancelEditTimeEntryBtn"
                  class="px-4 py-2 text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  id="saveEditTimeEntryBtn"
                  class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md transition-colors flex items-center space-x-2"
                >
                  <span id="saveEditButtonText">Save Changes</span>
                  <svg id="saveEditButtonSpinner" class="w-4 h-4 animate-spin hidden" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                </button>
              </div>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>
</Layout>

<script>
  // Show dashboard content after a brief delay to prevent flash
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      const loadingState = document.getElementById('loadingState');
      const dashboardContent = document.getElementById('dashboardContent');
      
      if (loadingState && dashboardContent) {
        loadingState.classList.add('hidden');
        dashboardContent.classList.remove('hidden');
      }
    }, 100); // Brief delay to ensure smooth transition
  });

  // Get current user ID from session
  async function getCurrentUserId() {
    try {
      const response = await fetch('/api/auth/me');
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.user) {
          return data.user.id;
        } else {
          console.error('Invalid response format:', data);
          return null;
        }
      } else if (response.status === 401) {
        // If unauthorized, redirect to login
        window.location.href = '/';
        return null;
      } else {
        const errorData = await response.json().catch(() => ({}));
        console.error('Auth error:', errorData.error || 'Unknown error');
      }
    } catch (error) {
      console.error('Error getting current user:', error);
    }
    return null;
  }

  // Load dashboard data
  async function loadDashboardData() {
    try {
      const userId = await getCurrentUserId();
      if (!userId) {
        console.error('No user ID available');
        // Show error state for the sections
        updateRecentEntries([], []);
        return;
      }

      // Load user's recent time entries (limit to 10 most recent)
      const entriesResponse = await fetch('/api/time-entries?userId=' + encodeURIComponent(userId) + '&limit=10');
      if (entriesResponse.ok) {
        const entriesData = await entriesResponse.json();
        const recentEntries = entriesData.data || [];
        
        // Load ongoing timers
        const ongoingResponse = await fetch('/api/timers/all-ongoing');
        if (ongoingResponse.ok) {
          const ongoingData = await ongoingResponse.json();
          const ongoingTimers = ongoingData.data || [];
          
          // Combine recent entries with ongoing timers
          updateRecentEntries(recentEntries, ongoingTimers);
        } else {
          updateRecentEntries(recentEntries, []);
        }
      } else {
        console.error('Failed to load time entries:', entriesResponse.status);
        updateRecentEntries([], []);
      }

      // Load weekly stats
      const statsResponse = await fetch('/api/reports/weekly-stats?userId=' + encodeURIComponent(userId));
      if (statsResponse.ok) {
        const statsData = await statsResponse.json();
        updateWeeklyStats(statsData);
      }



    } catch (error) {
      console.error('Error loading dashboard data:', error);
      // Retry loading after a delay if there was an error
      setTimeout(() => {
        console.log('Retrying dashboard data load...');
        loadDashboardData();
      }, 2000);
    }
  }

  function updateRecentEntries(entries: any[], ongoingTimers: any[] = []) {
    const container = document.getElementById('recentEntries');
    if (!container) return;

    // Debug: Calculate manual total from entries
    let manualTotalHours = 0;
    entries.forEach(entry => {
      if (entry.duration) {
        manualTotalHours += entry.duration / 3600;
      }
    });
    ongoingTimers.forEach(timer => {
      if (timer.elapsedSeconds) {
        manualTotalHours += timer.elapsedSeconds / 3600;
      }
    });
    console.log('Manual calculation from displayed entries:', {
      entriesCount: entries.length,
      ongoingTimersCount: ongoingTimers.length,
      manualTotalHours: manualTotalHours.toFixed(2),
      entries: entries.map(e => ({ id: e.id, duration: e.duration, durationHours: e.duration ? (e.duration / 3600).toFixed(2) : '0' }))
    });

    if (entries.length === 0 && ongoingTimers.length === 0) {
      container.innerHTML = `
        <div class="text-center py-8">
          <div class="w-12 h-12 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
            <span class="text-gray-400 text-xl">⏱️</span>
          </div>
          <p class="text-gray-500">No time entries yet</p>
          <p class="text-gray-400 text-sm mt-1">Start tracking your time to see entries here</p>
        </div>
      `;
      return;
    }

    // Show more entries in table format, but prioritize ongoing timers
    const displayEntries = entries.slice(0, 10);
    
    // Filter out any entries that are also in ongoing timers to avoid duplicates
    const ongoingTimerIds = new Set(ongoingTimers.map(timer => timer.id));
    const filteredEntries = displayEntries.filter(entry => !ongoingTimerIds.has(entry.id));
    
    container.innerHTML = `
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
          <tr>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Client
            </th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Project
            </th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Task
            </th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              User
            </th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Date
            </th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Start
            </th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Stop
            </th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Duration
            </th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Notes
            </th>
            <th class="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
              Actions
            </th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-gray-200">
          ${ongoingTimers.map((timer: any) => {
            const taskDate = new Date(timer.startTime);
            const elapsedHours = (timer.elapsedSeconds / 3600).toFixed(1);
            const startTime = new Date(timer.startTime);
            const startTimeDisplay = startTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
            
            return `
              <tr class="hover:bg-gray-50 bg-green-50 border-l-4 border-green-400" data-timer-id="${timer.id}">
                <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">
                  ${timer.clientName || 'Unknown Client'}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  ${timer.projectName || 'Unknown Project'}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  ${timer.taskName || 'Unknown Task'}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-500">
                  ${timer.userName || '-'}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-500">
                  ${taskDate.toLocaleDateString()}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  ${startTimeDisplay}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  <button
                    class="stop-timer-btn px-2 py-1 text-xs font-medium text-white bg-red-500 hover:bg-red-600 rounded transition-colors"
                    data-timer-id="${timer.id}"
                    data-user-id="${timer.userId}"
                    title="Stop timer"
                  >
                    Stop
                  </button>
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  <span class="timer-duration" data-timer-id="${timer.id}">${elapsedHours} hours</span>
                </td>
                <td class="px-4 py-3 text-sm text-gray-500 max-w-xs truncate" title="${timer.notes || ''}">
                  ${timer.notes || '-'}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-right text-sm font-medium">
                  <div class="flex items-center justify-end">
                    <div class="w-2 h-2 bg-green-500 rounded-full mr-2 animate-pulse"></div>
                    <span class="text-xs text-green-600 font-medium">Running</span>
                  </div>
                </td>
              </tr>
            `;
          }).join('')}
          ${filteredEntries.map((entry: any) => {
            // For manual duration entries, use createdAt for task date since startTime is null
            const taskDate = entry.startTime ? new Date(entry.startTime) : new Date(entry.createdAt);
            const durationHours = entry.duration ? (entry.duration / 3600).toFixed(1) : '0';
            
            // Check if this is a manual duration entry (no meaningful start/end times)
            // Manual duration entries have durationManual but no startTime or endTime
            const isManualDurationEntry = entry.durationManual && !entry.startTime && !entry.endTime;
            const startTime = (!isManualDurationEntry && entry.startTime) ? new Date(entry.startTime) : null;
            const endTime = (!isManualDurationEntry && entry.endTime) ? new Date(entry.endTime) : null;
            
            // Format times for display
            const startTimeDisplay = startTime ? startTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true }) : '--:-- --';
            const endTimeDisplay = endTime ? endTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true }) : '--:-- --';
            
            return `
              <tr class="hover:bg-gray-50" data-entry-id="${entry.id}">
                <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">
                  ${entry.clientName || 'Unknown Client'}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  ${entry.projectName || 'Unknown Project'}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  ${entry.taskName || 'Unknown Task'}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-500">
                  ${entry.userName || '-'}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-500">
                  ${taskDate.toLocaleDateString()}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  <input
                    type="text"
                    class="time-input w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent hover:border-blue-400 cursor-pointer ${isManualDurationEntry ? 'bg-gray-100 cursor-not-allowed' : ''}"
                    value="${startTimeDisplay}"
                    data-entry-id="${entry.id}"
                    data-time-type="start"
                    placeholder="9:30 AM"
                    title="${isManualDurationEntry ? 'Manual duration entry - use edit button to modify' : 'Click to edit start time'}"
                    ${isManualDurationEntry ? 'readonly' : ''}
                  />
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  <input
                    type="text"
                    class="time-input w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-transparent hover:border-blue-400 cursor-pointer ${isManualDurationEntry ? 'bg-gray-100 cursor-not-allowed' : ''}"
                    value="${endTimeDisplay}"
                    data-entry-id="${entry.id}"
                    data-time-type="end"
                    placeholder="9:30 AM"
                    title="${isManualDurationEntry ? 'Manual duration entry - use edit button to modify' : 'Click to edit end time'}"
                    ${isManualDurationEntry ? 'readonly' : ''}
                  />
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                  ${durationHours} hours
                </td>
                <td class="px-4 py-3 text-sm text-gray-500 max-w-xs truncate" title="${entry.notes || ''}">
                  ${entry.notes || '-'}
                </td>
                <td class="px-4 py-3 whitespace-nowrap text-right text-sm font-medium">
                  <button
                    class="edit-time-entry-btn p-2 text-gray-400 hover:text-[#415058] hover:bg-gray-50 rounded-md transition-colors"
                    data-entry-id="${entry.id}"
                    data-entry='${JSON.stringify(entry)}'
                    title="Edit time entry"
                  >
                    <img src="/icons/pencil.svg" alt="Edit" class="w-4 h-4" />
                  </button>
                </td>
              </tr>
            `;
          }).join('')}
        </tbody>
      </table>
    `;

    // Start updating ongoing timer durations
    startTimerDurationUpdates(ongoingTimers);
  }

  function updateWeeklyStats(stats: any) {
    const weeklyHours = document.getElementById('weeklyHours');

    if (weeklyHours) {
      // Convert seconds to hours for display
      const hoursFromSeconds = (stats.totalHours || 0) / 3600;
      weeklyHours.textContent = formatHours(hoursFromSeconds);
      
      // Debug information - log the raw data
      console.log('Weekly Stats Debug:', {
        totalSeconds: stats.totalHours,
        totalHours: hoursFromSeconds,
        formattedDisplay: formatHours(hoursFromSeconds),
        rawStats: stats
      });
    }
  }



  function formatDuration(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    return `${hours}h ${minutes}m`;
  }

  function formatHours(hours: number): string {
    const totalMinutes = Math.round(hours * 60);
    const h = Math.floor(totalMinutes / 60);
    const m = totalMinutes % 60;
    return `${h.toString().padStart(2, '0')} hr., ${m.toString().padStart(2, '0')} min`;
  }

  // Timer duration update intervals
  let timerUpdateIntervals: { [key: string]: NodeJS.Timeout } = {};

  function startTimerDurationUpdates(ongoingTimers: any[]) {
    // Clear existing intervals
    Object.values(timerUpdateIntervals).forEach(interval => clearInterval(interval));
    timerUpdateIntervals = {};

    // Start new intervals for each timer
    ongoingTimers.forEach(timer => {
      const startTime = new Date(timer.startTime);
      
      const interval = setInterval(() => {
        const now = new Date();
        const elapsedSeconds = Math.floor((now.getTime() - startTime.getTime()) / 1000);
        const elapsedHours = (elapsedSeconds / 3600).toFixed(1);
        
        const durationElement = document.querySelector(`[data-timer-id="${timer.id}"] .timer-duration`);
        if (durationElement) {
          durationElement.textContent = `${elapsedHours} hours`;
        }
      }, 1000);
      
      timerUpdateIntervals[timer.id] = interval;
    });
  }

  function stopTimerDurationUpdates() {
    Object.values(timerUpdateIntervals).forEach(interval => clearInterval(interval));
    timerUpdateIntervals = {};
  }

  // Logout functionality
  document.getElementById('logoutButton')?.addEventListener('click', async () => {
    try {
      // Get current user ID and clear only their timer state
      const userId = await getCurrentUserId();
      if (userId) {
        const timerStateKey = `timerState_${userId}`;
        localStorage.removeItem(timerStateKey);
      }

      const response = await fetch('/api/auth/logout', {
        method: 'POST',
      });
      
      if (response.ok) {
        window.location.href = '/';
      }
    } catch (error) {
      console.error('Logout error:', error);
    }
  });

  // Load data when page loads
  document.addEventListener('DOMContentLoaded', loadDashboardData);

  // Add event listeners for stop timer buttons
  document.addEventListener('click', async (e) => {
    const target = e.target as HTMLElement;
    const stopBtn = target.closest('.stop-timer-btn') as HTMLElement;
    
    if (stopBtn) {
      const timerId = stopBtn.getAttribute('data-timer-id');
      const userId = stopBtn.getAttribute('data-user-id');
      
      if (timerId && userId) {
        if (confirm('Are you sure you want to stop this timer?')) {
          try {
            const response = await fetch('/api/timers/ongoing', {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ timerId: parseInt(timerId) }),
            });

            if (response.ok) {
              // Reload dashboard data to update the display
              loadDashboardData();
            } else {
              const errorData = await response.json();
              alert(`Error stopping timer: ${errorData.error || 'Unknown error'}`);
            }
          } catch (error) {
            console.error('Error stopping timer:', error);
            alert('Error stopping timer');
          }
        }
      }
    }
  });

  // Cleanup intervals when page unloads
  window.addEventListener('beforeunload', stopTimerDurationUpdates);

  // Listen for timer started events to refresh the dashboard
  window.addEventListener('timerStarted', () => {
    // Reload dashboard data when a timer is started
    loadDashboardData();
  });

  // Refresh button functionality
  document.getElementById('refreshEntriesBtn')?.addEventListener('click', () => {
    loadDashboardData();
  });

  // Debug button functionality
  document.getElementById('debugBtn')?.addEventListener('click', async () => {
    try {
      const userId = await getCurrentUserId();
      if (!userId) {
        alert('No user ID available');
        return;
      }

      const response = await fetch('/api/debug-calculations?userId=' + encodeURIComponent(userId));
      if (response.ok) {
        const data = await response.json();
        console.log('Debug Calculations:', data);
        
        // Show a summary in an alert
        const summary = `
Debug Summary:
- All Entries: ${data.totals.allEntries.totalHours} hours (${data.totals.allEntries.count} entries)
- Weekly Entries: ${data.totals.weeklyEntries.totalHours} hours (${data.totals.weeklyEntries.count} entries)
- Ongoing Timers: ${data.totals.ongoingTimers.totalHours} hours (${data.totals.ongoingTimers.count} timers)
- Non-Archived Weekly: ${data.totals.nonArchivedWeeklyEntries.totalHours} hours
- Non-Archived Ongoing: ${data.totals.nonArchivedOngoingTimers.totalHours} hours
        `;
        alert(summary);
      } else {
        alert('Failed to get debug data');
      }
    } catch (error) {
      console.error('Debug error:', error);
      alert('Error getting debug data');
    }
  });

  // All Entries button functionality
  document.getElementById('viewAllEntriesBtn')?.addEventListener('click', () => {
    window.location.href = '/time-entries';
  });

  // View Reports button functionality
  document.getElementById('viewReportsBtn')?.addEventListener('click', () => {
    window.location.href = '/admin';
  });

  // Time Entry Modal Functionality
  const addTimeEntryBtn = document.getElementById('addTimeEntryBtn');
  const timeEntryModal = document.getElementById('timeEntryModal');
  const timeEntryForm = document.getElementById('timeEntryForm');
  const cancelTimeEntryBtn = document.getElementById('cancelTimeEntryBtn');
  const timeEntryTask = document.getElementById('timeEntryTask');
  const timeEntryTaskId = document.getElementById('timeEntryTaskId');
  const taskDropdown = document.getElementById('taskDropdown');

  // Show modal when Add Manual Time Entry button is clicked
  if (addTimeEntryBtn) {
    addTimeEntryBtn.addEventListener('click', () => {
      if (timeEntryModal) {
        timeEntryModal.classList.remove('hidden');
        // Set default date to today
        const dateInput = document.getElementById('timeEntryDate') as HTMLInputElement;
        if (dateInput) {
          const today = new Date().toISOString().split('T')[0];
          dateInput.value = today;
        }
      }
    });
  }

  // Close modal when Cancel button is clicked
  if (cancelTimeEntryBtn) {
    cancelTimeEntryBtn.addEventListener('click', closeTimeEntryModal);
  }

  // Close modal when clicking outside
  document.addEventListener('click', (e) => {
    if (timeEntryModal && e.target === timeEntryModal) {
      closeTimeEntryModal();
    }
  });

  // Close modal with Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && timeEntryModal && !timeEntryModal.classList.contains('hidden')) {
      closeTimeEntryModal();
    }
  });

  function closeTimeEntryModal() {
    if (timeEntryModal) {
      timeEntryModal.classList.add('hidden');
      if (timeEntryForm && timeEntryForm instanceof HTMLFormElement) {
        timeEntryForm.reset();
      }
      if (timeEntryTaskId && timeEntryTaskId instanceof HTMLInputElement) {
        timeEntryTaskId.value = '';
      }
      if (taskDropdown) {
        taskDropdown.classList.add('hidden');
      }
    }
  }

  // Task search functionality
  if (timeEntryTask) {
    timeEntryTask.addEventListener('input', debounce(async (e: Event) => {
      const target = e.target as HTMLInputElement;
      const searchTerm = target.value.trim();
      
      if (searchTerm.length < 2) {
        if (taskDropdown) {
          taskDropdown.classList.add('hidden');
        }
        return;
      }

      try {
        const userId = await getCurrentUserId();
        if (!userId) {
          console.error('No user ID available for task search');
          return;
        }

        const response = await fetch(`/api/tasks?assignedTo=${encodeURIComponent(userId)}&limit=10`);
        if (response.ok) {
          const data = await response.json();
          const tasks = data.data || [];
          
          // Filter tasks based on search term
          const filteredTasks = tasks.filter((task: any) => 
            task.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            task.projectName.toLowerCase().includes(searchTerm.toLowerCase())
          );

          displayTaskDropdown(filteredTasks);
        }
      } catch (error) {
        console.error('Error searching tasks:', error);
      }
    }, 300));
  }

  function displayTaskDropdown(tasks: any[]) {
    if (!taskDropdown) return;

    if (tasks.length === 0) {
      taskDropdown.innerHTML = '<div class="px-3 py-2 text-gray-500 text-sm">No tasks found</div>';
      taskDropdown.classList.remove('hidden');
      return;
    }

    taskDropdown.innerHTML = tasks.map((task: any) => `
      <div 
        class="px-3 py-2 hover:bg-gray-100 cursor-pointer border-b border-gray-100 last:border-b-0"
        data-task-id="${task.id}"
        data-task-name="${task.name}"
        data-project-name="${task.projectName}"
      >
        <div class="font-medium text-gray-900">${task.name}</div>
        <div class="text-sm text-gray-600">${task.projectName}</div>
      </div>
    `).join('');

    taskDropdown.classList.remove('hidden');

    // Add click handlers to task items
    taskDropdown.querySelectorAll('[data-task-id]').forEach((item: Element) => {
      item.addEventListener('click', () => {
        const taskId = item.getAttribute('data-task-id');
        const taskName = item.getAttribute('data-task-name');
        const projectName = item.getAttribute('data-project-name');

        if (timeEntryTask && timeEntryTask instanceof HTMLInputElement) {
          timeEntryTask.value = `${taskName} (${projectName})`;
        }
        if (timeEntryTaskId && timeEntryTaskId instanceof HTMLInputElement) {
          timeEntryTaskId.value = taskId || '';
        }
        if (taskDropdown) {
          taskDropdown.classList.add('hidden');
        }
      });
    });
  }

  // Debounce function
  function debounce(func: Function, wait: number) {
    let timeout: NodeJS.Timeout;
    return function executedFunction(...args: any[]) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // Handle form submission
  if (timeEntryForm) {
    timeEntryForm.addEventListener('submit', async (e: Event) => {
      e.preventDefault();
      
      const target = e.target as HTMLFormElement;
      const submitButton = target.querySelector('button[type="submit"]') as HTMLButtonElement;
      const saveButtonText = document.getElementById('saveButtonText') as HTMLSpanElement;
      const saveButtonSpinner = document.getElementById('saveButtonSpinner') as HTMLElement;
      const saveButtonSpinnerAlt = document.getElementById('saveButtonSpinnerAlt') as HTMLElement;
      const originalText = saveButtonText.textContent;
      
      // Show loading state
      submitButton.disabled = true;
      saveButtonText.textContent = 'Saving...';
      saveButtonSpinner.classList.remove('hidden');
      saveButtonSpinnerAlt.classList.remove('hidden');
      
      const taskId = timeEntryTaskId instanceof HTMLInputElement ? timeEntryTaskId.value : '';
      const durationInput = document.getElementById('timeEntryDuration') as HTMLInputElement;
      const taskDateInput = document.getElementById('timeEntryDate') as HTMLInputElement;
      const notesInput = document.getElementById('timeEntryNotes') as HTMLTextAreaElement;
      
      const duration = durationInput?.value;
      const taskDate = taskDateInput?.value;
      const notes = notesInput?.value;
      
      if (!taskId || !duration || !taskDate) {
        alert('Please fill in all required fields');
        submitButton.disabled = false;
        saveButtonText.textContent = originalText;
        saveButtonSpinner.classList.add('hidden');
        saveButtonSpinnerAlt.classList.add('hidden');
        return;
      }

      try {
        const userId = await getCurrentUserId();
        if (!userId) {
          throw new Error('No user ID available');
        }

        const response = await fetch('/api/admin/time-entries', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userId: parseInt(userId),
            taskId: parseInt(taskId),
            duration: duration,
            taskDate: taskDate,
            notes: notes || null
          }),
        });
        
        if (response.ok) {
          // Show success message
          saveButtonText.textContent = 'Saved!';
          submitButton.classList.add('bg-gray-800');
          saveButtonSpinner.classList.add('hidden');
          saveButtonSpinnerAlt.classList.add('hidden');
          
          // Close modal and reload data after a brief delay
          setTimeout(() => {
            closeTimeEntryModal();
            loadDashboardData(); // Reload dashboard data to show new entry
          }, 1000);
        } else {
          const errorData = await response.json();
          alert(`Error saving time entry: ${errorData.error || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error:', error);
        alert('Error saving time entry');
      } finally {
        // Reset button state
        submitButton.disabled = false;
        saveButtonText.textContent = originalText;
        submitButton.classList.remove('bg-gray-800');
        saveButtonSpinner.classList.add('hidden');
        saveButtonSpinnerAlt.classList.add('hidden');
      }
    });
  }

  // Edit Time Entry Modal Functionality
  const editTimeEntryModal = document.getElementById('editTimeEntryModal');
  const editTimeEntryForm = document.getElementById('editTimeEntryForm');
  const cancelEditTimeEntryBtn = document.getElementById('cancelEditTimeEntryBtn');
  const deleteTimeEntryBtn = document.getElementById('deleteTimeEntryBtn');
  let currentEditingEntry: any = null;

  // Add event listeners for edit buttons (delegated event handling)
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    const editBtn = target.closest('.edit-time-entry-btn') as HTMLElement;
    
    if (editBtn) {
      const entryId = editBtn.getAttribute('data-entry-id');
      const entryData = editBtn.getAttribute('data-entry');
      
      if (entryId && entryData) {
        try {
          const entry = JSON.parse(entryData);
          openEditTimeEntryModal(entry);
        } catch (error) {
          console.error('Error parsing entry data:', error);
        }
      }
    }
  });

  function openEditTimeEntryModal(entry: any) {
    if (!editTimeEntryModal) return;

    // Store the current entry being edited
    currentEditingEntry = entry;

    // Populate form fields
    const entryIdInput = document.getElementById('editTimeEntryId') as HTMLInputElement;
    const startTimeInput = document.getElementById('editStartTime') as HTMLInputElement;
    const endTimeInput = document.getElementById('editEndTime') as HTMLInputElement;
    const durationInput = document.getElementById('editDuration') as HTMLInputElement;
    const notesInput = document.getElementById('editNotes') as HTMLTextAreaElement;

    if (entryIdInput) entryIdInput.value = entry.id;
    if (notesInput) notesInput.value = entry.notes || '';

    // Format time inputs (12-hour format) - only if times exist
    if (startTimeInput) {
      if (entry.startTime) {
        const startDate = new Date(entry.startTime);
        startTimeInput.value = startDate.toLocaleTimeString('en-US', { 
          hour: 'numeric', 
          minute: '2-digit', 
          hour12: true 
        });
      } else {
        startTimeInput.value = '';
      }
    }
    
    if (endTimeInput) {
      if (entry.endTime) {
        const endDate = new Date(entry.endTime);
        endTimeInput.value = endDate.toLocaleTimeString('en-US', { 
          hour: 'numeric', 
          minute: '2-digit', 
          hour12: true 
        });
      } else {
        endTimeInput.value = '';
      }
    }

    // Set duration based on entry duration
    if (durationInput && entry.durationManual) {
      const hours = Math.floor(entry.durationManual / 3600);
      const minutes = Math.floor((entry.durationManual % 3600) / 60);
      durationInput.value = `${hours}h ${minutes}m`;
    }

    // Determine which method to show based on entry type
    const timesSection = document.getElementById('timesSection');
    const durationSection = document.getElementById('durationSection');
    
    // If this is a manual duration entry (no start/end times), show duration method
    if (!entry.startTime && !entry.endTime && entry.durationManual) {
      const durationRadio = document.querySelector('input[name="editMethod"][value="duration"]') as HTMLInputElement;
      if (durationRadio) {
        durationRadio.checked = true;
      }
      timesSection?.classList.add('hidden');
      durationSection?.classList.remove('hidden');
    } else {
      // Default to "times" method (start/end times)
      const timesRadio = document.querySelector('input[name="editMethod"][value="times"]') as HTMLInputElement;
      if (timesRadio) {
        timesRadio.checked = true;
      }
      timesSection?.classList.remove('hidden');
      durationSection?.classList.add('hidden');
    }

    // Show modal
    editTimeEntryModal.classList.remove('hidden');
  }

  function closeEditTimeEntryModal() {
    if (editTimeEntryModal) {
      editTimeEntryModal.classList.add('hidden');
      currentEditingEntry = null; // Clear the stored entry
      if (editTimeEntryForm && editTimeEntryForm instanceof HTMLFormElement) {
        editTimeEntryForm.reset();
      }
      
      // Reset radio button to default selection
      const timesRadio = document.querySelector('input[name="editMethod"][value="times"]') as HTMLInputElement;
      if (timesRadio) {
        timesRadio.checked = true;
      }
      
      // Ensure correct sections are shown
      const timesSection = document.getElementById('timesSection');
      const durationSection = document.getElementById('durationSection');
      timesSection?.classList.remove('hidden');
      durationSection?.classList.add('hidden');
    }
  }

  // Close edit modal when Cancel button is clicked
  if (cancelEditTimeEntryBtn) {
    cancelEditTimeEntryBtn.addEventListener('click', closeEditTimeEntryModal);
  }

  // Close edit modal when clicking outside
  document.addEventListener('click', (e) => {
    if (editTimeEntryModal && e.target === editTimeEntryModal) {
      closeEditTimeEntryModal();
    }
  });

  // Close edit modal with Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && editTimeEntryModal && !editTimeEntryModal.classList.contains('hidden')) {
      closeEditTimeEntryModal();
    }
  });

  // Handle edit method radio button changes
  document.addEventListener('change', (e) => {
    const target = e.target as HTMLInputElement;
    if (target.name === 'editMethod') {
      const timesSection = document.getElementById('timesSection');
      const durationSection = document.getElementById('durationSection');
      
      if (target.value === 'times') {
        timesSection?.classList.remove('hidden');
        durationSection?.classList.add('hidden');
      } else {
        timesSection?.classList.add('hidden');
        durationSection?.classList.remove('hidden');
      }
    }
  });

  // Handle edit form submission
  if (editTimeEntryForm) {
    editTimeEntryForm.addEventListener('submit', async (e: Event) => {
      e.preventDefault();
      
      const target = e.target as HTMLFormElement;
      const submitButton = target.querySelector('button[type="submit"]') as HTMLButtonElement;
      const saveButtonText = document.getElementById('saveEditButtonText') as HTMLSpanElement;
      const saveButtonSpinner = document.getElementById('saveEditButtonSpinner') as HTMLElement;
      const originalText = saveButtonText.textContent;
      
      // Show loading state
      submitButton.disabled = true;
      saveButtonText.textContent = 'Saving...';
      saveButtonSpinner.classList.remove('hidden');
      
      const entryId = document.getElementById('editTimeEntryId') as HTMLInputElement;
      const editMethod = document.querySelector('input[name="editMethod"]:checked') as HTMLInputElement;
      const startTimeInput = document.getElementById('editStartTime') as HTMLInputElement;
      const endTimeInput = document.getElementById('editEndTime') as HTMLInputElement;
      const durationInput = document.getElementById('editDuration') as HTMLInputElement;
      const notesInput = document.getElementById('editNotes') as HTMLTextAreaElement;
      
      let updateData: any = {
        notes: notesInput?.value || null
      };

      if (editMethod?.value === 'times') {
        if (!startTimeInput?.value || !endTimeInput?.value) {
          alert('Please fill in both start and end times');
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          saveButtonSpinner.classList.add('hidden');
          return;
        }
        
        // Get the task date from the original entry (use startTime if it exists, otherwise use createdAt)
        const taskDate = currentEditingEntry?.startTime ? new Date(currentEditingEntry.startTime) : new Date(currentEditingEntry?.createdAt);
        
        // Create start time by combining task date with user input (12-hour format)
        const startTimeMatch = startTimeInput.value.match(/^(1[0-2]|0?[1-9]):([0-5][0-9])\s*(am|pm|AM|PM)$/);
        if (!startTimeMatch) {
          alert('Invalid start time format. Please use 12-hour format (e.g., 9:30 AM, 2:45 PM)');
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          saveButtonSpinner.classList.add('hidden');
          return;
        }
        
        let startHours = parseInt(startTimeMatch[1]);
        const startMinutes = parseInt(startTimeMatch[2]);
        const startPeriod = startTimeMatch[3].toLowerCase();
        
        // Convert to 24-hour format
        if (startPeriod === 'pm' && startHours !== 12) {
          startHours += 12;
        } else if (startPeriod === 'am' && startHours === 12) {
          startHours = 0;
        }
        
        const startDateTime = new Date(taskDate);
        startDateTime.setHours(startHours, startMinutes, 0, 0);
        updateData.startTime = startDateTime.toISOString();
        
        // Create end time by combining task date with user input (12-hour format)
        const endTimeMatch = endTimeInput.value.match(/^(1[0-2]|0?[1-9]):([0-5][0-9])\s*(am|pm|AM|PM)$/);
        if (!endTimeMatch) {
          alert('Invalid end time format. Please use 12-hour format (e.g., 9:30 AM, 2:45 PM)');
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          saveButtonSpinner.classList.add('hidden');
          return;
        }
        
        let endHours = parseInt(endTimeMatch[1]);
        const endMinutes = parseInt(endTimeMatch[2]);
        const endPeriod = endTimeMatch[3].toLowerCase();
        
        // Convert to 24-hour format
        if (endPeriod === 'pm' && endHours !== 12) {
          endHours += 12;
        } else if (endPeriod === 'am' && endHours === 12) {
          endHours = 0;
        }
        
        const endDateTime = new Date(taskDate);
        endDateTime.setHours(endHours, endMinutes, 0, 0);
        updateData.endTime = endDateTime.toISOString();
        
        // Validate that end time is after start time
        if (endDateTime <= startDateTime) {
          alert('End time must be after start time');
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          saveButtonSpinner.classList.add('hidden');
          return;
        }
        
        // Clear manual duration since we're now using start/end times
        updateData.durationManual = null;
      } else {
        if (!durationInput?.value) {
          alert('Please enter a duration');
          submitButton.disabled = false;
          saveButtonText.textContent = originalText;
          saveButtonSpinner.classList.add('hidden');
          return;
        }
        updateData.duration = durationInput.value;
        // Clear start and end times for manual duration entries
        updateData.startTime = null;
        updateData.endTime = null;
      }

      try {
        const response = await fetch(`/api/time-entries/${entryId?.value}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(updateData),
        });
        
        if (response.ok) {
          // Show success message
          saveButtonText.textContent = 'Saved!';
          submitButton.classList.add('bg-gray-800');
          saveButtonSpinner.classList.add('hidden');
          
          // Close modal and reload data after a brief delay
          setTimeout(() => {
            closeEditTimeEntryModal();
            loadDashboardData(); // Reload dashboard data to show updated entry
          }, 1000);
        } else {
          const errorData = await response.json();
          alert(`Error updating time entry: ${errorData.error || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error:', error);
        alert('Error updating time entry');
      } finally {
        // Reset button state
        submitButton.disabled = false;
        saveButtonText.textContent = originalText;
        submitButton.classList.remove('bg-gray-800');
        saveButtonSpinner.classList.add('hidden');
      }
    });
  }

  // Handle delete time entry
  if (deleteTimeEntryBtn) {
    deleteTimeEntryBtn.addEventListener('click', async () => {
      const entryId = document.getElementById('editTimeEntryId') as HTMLInputElement;
      
      if (!entryId?.value) {
        alert('No time entry selected for deletion');
        return;
      }

      if (!confirm('Are you sure you want to delete this time entry? This action cannot be undone.')) {
        return;
      }

      try {
        const response = await fetch(`/api/time-entries/${entryId.value}`, {
          method: 'DELETE',
        });
        
        if (response.ok) {
          // Close modal and reload data
          closeEditTimeEntryModal();
          loadDashboardData(); // Reload dashboard data to reflect deletion
        } else {
          const errorData = await response.json();
          alert(`Error deleting time entry: ${errorData.error || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error:', error);
        alert('Error deleting time entry');
      }
    });
  }

  // Time input handling for recent entries
  document.addEventListener('DOMContentLoaded', function() {
    // Function to handle time input changes
    function handleTimeInputChange() {
      const timeInputs = document.querySelectorAll('.time-input');
      
      timeInputs.forEach((input: Element) => {
        const timeInput = input as HTMLInputElement;
        
        // Store the original value when the input is focused
        timeInput.addEventListener('focus', function() {
          this.setAttribute('data-original-value', this.value);
        });
        
        timeInput.addEventListener('blur', async function() {
          const entryId = this.getAttribute('data-entry-id');
          const timeType = this.getAttribute('data-time-type');
          const timeValue = this.value.trim();
          
          // Skip if empty or if it's the placeholder value
          if (!timeValue || timeValue === '--:-- --') return;
          
          // Skip if the value hasn't changed
          const originalValue = this.getAttribute('data-original-value');
          if (timeValue === originalValue) return;
          
          // Check if this is a manual duration entry (readonly input)
          if (this.hasAttribute('readonly')) {
            return; // Don't allow editing manual duration entries
          }
          
          // Validate time format (12-hour with AM/PM)
          const timeRegex = /^(1[0-2]|0?[1-9]):[0-5][0-9]\s*(am|pm|AM|PM)$/;
          if (!timeRegex.test(timeValue)) {
            alert('Please enter a valid time in 12-hour format (e.g., 9:30 AM, 2:45 PM)');
            this.focus();
            return;
          }
          
          try {
            // Get the current entry data to determine if this is a manual duration entry
            const row = this.closest('tr');
            const editBtn = row?.querySelector('.edit-time-entry-btn') as HTMLElement;
            const entryData = editBtn?.getAttribute('data-entry');
            let currentEntry = null;
            
            if (entryData) {
              try {
                currentEntry = JSON.parse(entryData);
              } catch (e) {
                console.error('Error parsing entry data:', e);
              }
            }
            
            // Get the task date from the current entry
            const taskDate = currentEntry?.startTime ? new Date(currentEntry.startTime) : new Date(currentEntry?.createdAt);
            
            // Parse the time input and create a proper datetime (12-hour format)
            const timeMatch = timeValue.match(/^(1[0-2]|0?[1-9]):([0-5][0-9])\s*(am|pm|AM|PM)$/);
            if (!timeMatch) {
              alert('Invalid time format. Please use 12-hour format (e.g., 9:30 AM, 2:45 PM)');
              this.focus();
              return;
            }
            
            let hours = parseInt(timeMatch[1]);
            const minutes = parseInt(timeMatch[2]);
            const period = timeMatch[3].toLowerCase();
            
            // Convert to 24-hour format
            if (period === 'pm' && hours !== 12) {
              hours += 12;
            } else if (period === 'am' && hours === 12) {
              hours = 0;
            }
            
            const newDateTime = new Date(taskDate);
            newDateTime.setHours(hours, minutes, 0, 0);
            
            const updateData: { startTime?: string; endTime?: string; durationManual?: number | null } = {};
            if (timeType === 'start') {
              updateData.startTime = newDateTime.toISOString();
            } else if (timeType === 'end') {
              updateData.endTime = newDateTime.toISOString();
            }
            
            // If this was a manual duration entry and we're adding times, clear the manual duration
            if (currentEntry?.durationManual && !currentEntry?.endTime) {
              updateData.durationManual = null;
            }
            
            // Validate that end time is after start time if both times are being set
            if (timeType === 'end' && currentEntry?.startTime) {
              const existingStartTime = new Date(currentEntry.startTime);
              if (newDateTime <= existingStartTime) {
                alert('End time must be after start time');
                this.focus();
                return;
              }
            } else if (timeType === 'start' && currentEntry?.endTime) {
              const existingEndTime = new Date(currentEntry.endTime);
              if (newDateTime >= existingEndTime) {
                alert('Start time must be before end time');
                this.focus();
                return;
              }
            }
            
            // Show loading state
            this.style.borderColor = '#3B82F6';
            this.style.backgroundColor = '#F0F9FF';
            
            const response = await fetch(`/api/time-entries/${entryId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(updateData)
            });
            
            if (response.ok) {
              const result = await response.json();
              const row = this.closest('tr');
              
              // Update the duration cell
              const durationCell = row?.querySelector('td:nth-child(7)'); // Duration column
              if (durationCell && result.data) {
                const duration = result.data.durationManual ? result.data.durationManual / 3600 : 0;
                durationCell.textContent = `${duration ? Math.round(duration * 10) / 10 : 0} hours`;
              }
              
              // Update the time input values to reflect the new data
              if (result.data) {
                const startTimeInput = row?.querySelector('input[data-time-type="start"]') as HTMLInputElement;
                const endTimeInput = row?.querySelector('input[data-time-type="end"]') as HTMLInputElement;
                
                if (startTimeInput && result.data.startTime) {
                  const startDate = new Date(result.data.startTime);
                  startTimeInput.value = startDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
                } else if (startTimeInput && !result.data.startTime) {
                  startTimeInput.value = '--:-- --';
                }
                
                if (endTimeInput && result.data.endTime) {
                  const endDate = new Date(result.data.endTime);
                  endTimeInput.value = endDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
                } else if (endTimeInput && !result.data.endTime) {
                  endTimeInput.value = '--:-- --';
                }
              }
              
              // Reload weekly stats to update "This Week" hours
              const userId = await getCurrentUserId();
              if (userId) {
                const statsResponse = await fetch('/api/reports/weekly-stats?userId=' + encodeURIComponent(userId));
                if (statsResponse.ok) {
                  const statsData = await statsResponse.json();
                  updateWeeklyStats(statsData);
                }
              }
              
              // Show success feedback
              this.style.borderColor = '#10B981';
              this.style.backgroundColor = '';
              setTimeout(() => {
                this.style.borderColor = '';
              }, 2000);
                         } else {
               const error = await response.json();
               
               if (response.status === 401) {
                 // Authentication error - redirect to login
                 alert('Your session has expired. Please log in again.');
                 window.location.href = '/login';
                 return;
               }
               
               alert(`Error: ${error.error}`);
               // Reset to original value on error
               this.focus();
             }
                      } catch (error) {
              console.error('Error updating time:', error);
              // Reset styling on error
              this.style.borderColor = '';
              this.style.backgroundColor = '';
              alert('Error updating time. Please check your input and try again.');
              this.focus();
            }
        });
        
        // Handle Enter key
        timeInput.addEventListener('keypress', function(e: KeyboardEvent) {
          if (e.key === 'Enter') {
            this.blur();
          }
        });
      });
    }

    // Initial setup
    handleTimeInputChange();

      // Re-setup after data reload using a MutationObserver
  const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      if (mutation.type === 'childList') {
        // Check if time inputs were added
        const timeInputs = document.querySelectorAll('.time-input');
        if (timeInputs.length > 0) {
          handleTimeInputChange();
        }
      }
    });
  });

  // Start observing the recent entries container
  const recentEntriesContainer = document.getElementById('recentEntries');
  if (recentEntriesContainer) {
    observer.observe(recentEntriesContainer, { childList: true, subtree: true });
  }
  });
</script> 